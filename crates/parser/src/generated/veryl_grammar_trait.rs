// ---------------------------------------------------------
// This file was generated by parol.
// It is not intended for manual editing and changes will be
// lost after next build.
// ---------------------------------------------------------

// Disable clippy warnings that can result in the way how parol generates code.
#![allow(clippy::enum_variant_names)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::upper_case_acronyms)]

use parol_runtime::log::trace;
#[allow(unused_imports)]
use parol_runtime::parol_macros::{pop_and_reverse_item, pop_item};
use parol_runtime::parser::{ParseTreeType, UserActionsTrait};
use parol_runtime::{ParserError, Result, Token};
use std::marker::PhantomData;

/// Semantic actions trait generated for the user grammar
/// All functions have default implementations.
pub trait VerylGrammarTrait {
    /// Semantic action for non-terminal 'CommentsTerm'
    fn comments_term(&mut self, _arg: &CommentsTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StringLiteralTerm'
    fn string_literal_term(&mut self, _arg: &StringLiteralTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExponentTerm'
    fn exponent_term(&mut self, _arg: &ExponentTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FixedPointTerm'
    fn fixed_point_term(&mut self, _arg: &FixedPointTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedTerm'
    fn based_term(&mut self, _arg: &BasedTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AllBitTerm'
    fn all_bit_term(&mut self, _arg: &AllBitTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BaseLessTerm'
    fn base_less_term(&mut self, _arg: &BaseLessTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusColonTerm'
    fn minus_colon_term(&mut self, _arg: &MinusColonTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusGTTerm'
    fn minus_g_t_term(&mut self, _arg: &MinusGTTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LTMinusTerm'
    fn l_t_minus_term(&mut self, _arg: &LTMinusTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PlusColonTerm'
    fn plus_colon_term(&mut self, _arg: &PlusColonTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignmentOperatorTerm'
    fn assignment_operator_term(&mut self, _arg: &AssignmentOperatorTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DiamondOperatorTerm'
    fn diamond_operator_term(&mut self, _arg: &DiamondOperatorTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator12Term'
    fn operator12_term(&mut self, _arg: &Operator12Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator11Term'
    fn operator11_term(&mut self, _arg: &Operator11Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator10Term'
    fn operator10_term(&mut self, _arg: &Operator10Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator09Term'
    fn operator09_term(&mut self, _arg: &Operator09Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator08Term'
    fn operator08_term(&mut self, _arg: &Operator08Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator07Term'
    fn operator07_term(&mut self, _arg: &Operator07Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator03Term'
    fn operator03_term(&mut self, _arg: &Operator03Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator02Term'
    fn operator02_term(&mut self, _arg: &Operator02Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator06Term'
    fn operator06_term(&mut self, _arg: &Operator06Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator05Term'
    fn operator05_term(&mut self, _arg: &Operator05Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator04Term'
    fn operator04_term(&mut self, _arg: &Operator04Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UnaryOperatorTerm'
    fn unary_operator_term(&mut self, _arg: &UnaryOperatorTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonColonLAngleTerm'
    fn colon_colon_l_angle_term(&mut self, _arg: &ColonColonLAngleTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonColonTerm'
    fn colon_colon_term(&mut self, _arg: &ColonColonTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonTerm'
    fn colon_term(&mut self, _arg: &ColonTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CommaTerm'
    fn comma_term(&mut self, _arg: &CommaTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotDotEquTerm'
    fn dot_dot_equ_term(&mut self, _arg: &DotDotEquTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotDotTerm'
    fn dot_dot_term(&mut self, _arg: &DotDotTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotTerm'
    fn dot_term(&mut self, _arg: &DotTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EquTerm'
    fn equ_term(&mut self, _arg: &EquTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HashLBracketTerm'
    fn hash_l_bracket_term(&mut self, _arg: &HashLBracketTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HashTerm'
    fn hash_term(&mut self, _arg: &HashTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LAngleTerm'
    fn l_angle_term(&mut self, _arg: &LAngleTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QuestionTerm'
    fn question_term(&mut self, _arg: &QuestionTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QuoteLBraceTerm'
    fn quote_l_brace_term(&mut self, _arg: &QuoteLBraceTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QuoteTerm'
    fn quote_term(&mut self, _arg: &QuoteTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EscapedLBraceTerm'
    fn escaped_l_brace_term(&mut self, _arg: &EscapedLBraceTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TripleLBraceTerm'
    fn triple_l_brace_term(&mut self, _arg: &TripleLBraceTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBraceTerm'
    fn l_brace_term(&mut self, _arg: &LBraceTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBracketTerm'
    fn l_bracket_term(&mut self, _arg: &LBracketTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParenTerm'
    fn l_paren_term(&mut self, _arg: &LParenTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RAngleTerm'
    fn r_angle_term(&mut self, _arg: &RAngleTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EscapedRBraceTerm'
    fn escaped_r_brace_term(&mut self, _arg: &EscapedRBraceTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TripleRBraceTerm'
    fn triple_r_brace_term(&mut self, _arg: &TripleRBraceTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBraceTerm'
    fn r_brace_term(&mut self, _arg: &RBraceTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBracketTerm'
    fn r_bracket_term(&mut self, _arg: &RBracketTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParenTerm'
    fn r_paren_term(&mut self, _arg: &RParenTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SemicolonTerm'
    fn semicolon_term(&mut self, _arg: &SemicolonTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StarTerm'
    fn star_term(&mut self, _arg: &StarTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AliasTerm'
    fn alias_term(&mut self, _arg: &AliasTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysCombTerm'
    fn always_comb_term(&mut self, _arg: &AlwaysCombTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfTerm'
    fn always_ff_term(&mut self, _arg: &AlwaysFfTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignTerm'
    fn assign_term(&mut self, _arg: &AssignTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AsTerm'
    fn as_term(&mut self, _arg: &AsTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BindTerm'
    fn bind_term(&mut self, _arg: &BindTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitTerm'
    fn bit_term(&mut self, _arg: &BitTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BoolTerm'
    fn bool_term(&mut self, _arg: &BoolTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CaseTerm'
    fn case_term(&mut self, _arg: &CaseTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ClockTerm'
    fn clock_term(&mut self, _arg: &ClockTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ClockPosedgeTerm'
    fn clock_posedge_term(&mut self, _arg: &ClockPosedgeTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ClockNegedgeTerm'
    fn clock_negedge_term(&mut self, _arg: &ClockNegedgeTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConnectTerm'
    fn connect_term(&mut self, _arg: &ConnectTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstTerm'
    fn const_term(&mut self, _arg: &ConstTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConverseTerm'
    fn converse_term(&mut self, _arg: &ConverseTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DefaultTerm'
    fn default_term(&mut self, _arg: &DefaultTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ElseTerm'
    fn else_term(&mut self, _arg: &ElseTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EmbedTerm'
    fn embed_term(&mut self, _arg: &EmbedTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EnumTerm'
    fn enum_term(&mut self, _arg: &EnumTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F32Term'
    fn f32_term(&mut self, _arg: &F32Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F64Term'
    fn f64_term(&mut self, _arg: &F64Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FalseTerm'
    fn false_term(&mut self, _arg: &FalseTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FinalTerm'
    fn final_term(&mut self, _arg: &FinalTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ForTerm'
    fn for_term(&mut self, _arg: &ForTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FunctionTerm'
    fn function_term(&mut self, _arg: &FunctionTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I8Term'
    fn i8_term(&mut self, _arg: &I8Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I16Term'
    fn i16_term(&mut self, _arg: &I16Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I32Term'
    fn i32_term(&mut self, _arg: &I32Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I64Term'
    fn i64_term(&mut self, _arg: &I64Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfResetTerm'
    fn if_reset_term(&mut self, _arg: &IfResetTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfTerm'
    fn if_term(&mut self, _arg: &IfTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ImportTerm'
    fn import_term(&mut self, _arg: &ImportTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IncludeTerm'
    fn include_term(&mut self, _arg: &IncludeTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InitialTerm'
    fn initial_term(&mut self, _arg: &InitialTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InoutTerm'
    fn inout_term(&mut self, _arg: &InoutTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InputTerm'
    fn input_term(&mut self, _arg: &InputTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InsideTerm'
    fn inside_term(&mut self, _arg: &InsideTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstTerm'
    fn inst_term(&mut self, _arg: &InstTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceTerm'
    fn interface_term(&mut self, _arg: &InterfaceTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InTerm'
    fn in_term(&mut self, _arg: &InTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LetTerm'
    fn let_term(&mut self, _arg: &LetTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicTerm'
    fn logic_term(&mut self, _arg: &LogicTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LsbTerm'
    fn lsb_term(&mut self, _arg: &LsbTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportTerm'
    fn modport_term(&mut self, _arg: &ModportTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleTerm'
    fn module_term(&mut self, _arg: &ModuleTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MsbTerm'
    fn msb_term(&mut self, _arg: &MsbTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OutputTerm'
    fn output_term(&mut self, _arg: &OutputTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OutsideTerm'
    fn outside_term(&mut self, _arg: &OutsideTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PackageTerm'
    fn package_term(&mut self, _arg: &PackageTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ParamTerm'
    fn param_term(&mut self, _arg: &ParamTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProtoTerm'
    fn proto_term(&mut self, _arg: &ProtoTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PubTerm'
    fn pub_term(&mut self, _arg: &PubTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RepeatTerm'
    fn repeat_term(&mut self, _arg: &RepeatTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ResetTerm'
    fn reset_term(&mut self, _arg: &ResetTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ResetAsyncHighTerm'
    fn reset_async_high_term(&mut self, _arg: &ResetAsyncHighTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ResetAsyncLowTerm'
    fn reset_async_low_term(&mut self, _arg: &ResetAsyncLowTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ResetSyncHighTerm'
    fn reset_sync_high_term(&mut self, _arg: &ResetSyncHighTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ResetSyncLowTerm'
    fn reset_sync_low_term(&mut self, _arg: &ResetSyncLowTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ReturnTerm'
    fn return_term(&mut self, _arg: &ReturnTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RevTerm'
    fn rev_term(&mut self, _arg: &RevTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BreakTerm'
    fn break_term(&mut self, _arg: &BreakTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SameTerm'
    fn same_term(&mut self, _arg: &SameTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SignedTerm'
    fn signed_term(&mut self, _arg: &SignedTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StepTerm'
    fn step_term(&mut self, _arg: &StepTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StringTerm'
    fn string_term(&mut self, _arg: &StringTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructTerm'
    fn struct_term(&mut self, _arg: &StructTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SwitchTerm'
    fn switch_term(&mut self, _arg: &SwitchTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TriTerm'
    fn tri_term(&mut self, _arg: &TriTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TrueTerm'
    fn true_term(&mut self, _arg: &TrueTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypeTerm'
    fn type_term(&mut self, _arg: &TypeTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U8Term'
    fn u8_term(&mut self, _arg: &U8Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U16Term'
    fn u16_term(&mut self, _arg: &U16Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U32Term'
    fn u32_term(&mut self, _arg: &U32Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U64Term'
    fn u64_term(&mut self, _arg: &U64Term) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UnionTerm'
    fn union_term(&mut self, _arg: &UnionTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UnsafeTerm'
    fn unsafe_term(&mut self, _arg: &UnsafeTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'VarTerm'
    fn var_term(&mut self, _arg: &VarTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DollarIdentifierTerm'
    fn dollar_identifier_term(&mut self, _arg: &DollarIdentifierTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdentifierTerm'
    fn identifier_term(&mut self, _arg: &IdentifierTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AnyTerm'
    fn any_term(&mut self, _arg: &AnyTerm) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comments'
    fn comments(&mut self, _arg: &Comments) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StartToken'
    fn start_token(&mut self, _arg: &StartToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StringLiteralToken'
    fn string_literal_token(&mut self, _arg: &StringLiteralToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExponentToken'
    fn exponent_token(&mut self, _arg: &ExponentToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FixedPointToken'
    fn fixed_point_token(&mut self, _arg: &FixedPointToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BasedToken'
    fn based_token(&mut self, _arg: &BasedToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BaseLessToken'
    fn base_less_token(&mut self, _arg: &BaseLessToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AllBitToken'
    fn all_bit_token(&mut self, _arg: &AllBitToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignmentOperatorToken'
    fn assignment_operator_token(&mut self, _arg: &AssignmentOperatorToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DiamondOperatorToken'
    fn diamond_operator_token(&mut self, _arg: &DiamondOperatorToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator02Token'
    fn operator02_token(&mut self, _arg: &Operator02Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator03Token'
    fn operator03_token(&mut self, _arg: &Operator03Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator04Token'
    fn operator04_token(&mut self, _arg: &Operator04Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator05Token'
    fn operator05_token(&mut self, _arg: &Operator05Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator06Token'
    fn operator06_token(&mut self, _arg: &Operator06Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator07Token'
    fn operator07_token(&mut self, _arg: &Operator07Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator08Token'
    fn operator08_token(&mut self, _arg: &Operator08Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator09Token'
    fn operator09_token(&mut self, _arg: &Operator09Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator10Token'
    fn operator10_token(&mut self, _arg: &Operator10Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator11Token'
    fn operator11_token(&mut self, _arg: &Operator11Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator12Token'
    fn operator12_token(&mut self, _arg: &Operator12Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UnaryOperatorToken'
    fn unary_operator_token(&mut self, _arg: &UnaryOperatorToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonToken'
    fn colon_token(&mut self, _arg: &ColonToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonColonLAngleToken'
    fn colon_colon_l_angle_token(&mut self, _arg: &ColonColonLAngleToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonColonToken'
    fn colon_colon_token(&mut self, _arg: &ColonColonToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CommaToken'
    fn comma_token(&mut self, _arg: &CommaToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotDotToken'
    fn dot_dot_token(&mut self, _arg: &DotDotToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotDotEquToken'
    fn dot_dot_equ_token(&mut self, _arg: &DotDotEquToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotToken'
    fn dot_token(&mut self, _arg: &DotToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EquToken'
    fn equ_token(&mut self, _arg: &EquToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HashLBracketToken'
    fn hash_l_bracket_token(&mut self, _arg: &HashLBracketToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HashToken'
    fn hash_token(&mut self, _arg: &HashToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QuestionToken'
    fn question_token(&mut self, _arg: &QuestionToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QuoteLBraceToken'
    fn quote_l_brace_token(&mut self, _arg: &QuoteLBraceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QuoteToken'
    fn quote_token(&mut self, _arg: &QuoteToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LAngleToken'
    fn l_angle_token(&mut self, _arg: &LAngleToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EmbedLBraceToken'
    fn embed_l_brace_token(&mut self, _arg: &EmbedLBraceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EscapedLBraceToken'
    fn escaped_l_brace_token(&mut self, _arg: &EscapedLBraceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TripleLBraceToken'
    fn triple_l_brace_token(&mut self, _arg: &TripleLBraceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBraceToken'
    fn l_brace_token(&mut self, _arg: &LBraceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBracketToken'
    fn l_bracket_token(&mut self, _arg: &LBracketToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParenToken'
    fn l_paren_token(&mut self, _arg: &LParenToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LTMinusToken'
    fn l_t_minus_token(&mut self, _arg: &LTMinusToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusColonToken'
    fn minus_colon_token(&mut self, _arg: &MinusColonToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusGTToken'
    fn minus_g_t_token(&mut self, _arg: &MinusGTToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PlusColonToken'
    fn plus_colon_token(&mut self, _arg: &PlusColonToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RAngleToken'
    fn r_angle_token(&mut self, _arg: &RAngleToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EmbedRBraceToken'
    fn embed_r_brace_token(&mut self, _arg: &EmbedRBraceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EscapedRBraceToken'
    fn escaped_r_brace_token(&mut self, _arg: &EscapedRBraceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TripleRBraceToken'
    fn triple_r_brace_token(&mut self, _arg: &TripleRBraceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBraceToken'
    fn r_brace_token(&mut self, _arg: &RBraceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBracketToken'
    fn r_bracket_token(&mut self, _arg: &RBracketToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParenToken'
    fn r_paren_token(&mut self, _arg: &RParenToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SemicolonToken'
    fn semicolon_token(&mut self, _arg: &SemicolonToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StarToken'
    fn star_token(&mut self, _arg: &StarToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AliasToken'
    fn alias_token(&mut self, _arg: &AliasToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysCombToken'
    fn always_comb_token(&mut self, _arg: &AlwaysCombToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfToken'
    fn always_ff_token(&mut self, _arg: &AlwaysFfToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AsToken'
    fn as_token(&mut self, _arg: &AsToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignToken'
    fn assign_token(&mut self, _arg: &AssignToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BindToken'
    fn bind_token(&mut self, _arg: &BindToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BitToken'
    fn bit_token(&mut self, _arg: &BitToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BoolToken'
    fn bool_token(&mut self, _arg: &BoolToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CaseToken'
    fn case_token(&mut self, _arg: &CaseToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ClockToken'
    fn clock_token(&mut self, _arg: &ClockToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ClockPosedgeToken'
    fn clock_posedge_token(&mut self, _arg: &ClockPosedgeToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ClockNegedgeToken'
    fn clock_negedge_token(&mut self, _arg: &ClockNegedgeToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConnectToken'
    fn connect_token(&mut self, _arg: &ConnectToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstToken'
    fn const_token(&mut self, _arg: &ConstToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConverseToken'
    fn converse_token(&mut self, _arg: &ConverseToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DefaultToken'
    fn default_token(&mut self, _arg: &DefaultToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ElseToken'
    fn else_token(&mut self, _arg: &ElseToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EmbedToken'
    fn embed_token(&mut self, _arg: &EmbedToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EnumToken'
    fn enum_token(&mut self, _arg: &EnumToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F32Token'
    fn f32_token(&mut self, _arg: &F32Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F64Token'
    fn f64_token(&mut self, _arg: &F64Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FalseToken'
    fn false_token(&mut self, _arg: &FalseToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FinalToken'
    fn final_token(&mut self, _arg: &FinalToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ForToken'
    fn for_token(&mut self, _arg: &ForToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FunctionToken'
    fn function_token(&mut self, _arg: &FunctionToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I8Token'
    fn i8_token(&mut self, _arg: &I8Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I16Token'
    fn i16_token(&mut self, _arg: &I16Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I32Token'
    fn i32_token(&mut self, _arg: &I32Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I64Token'
    fn i64_token(&mut self, _arg: &I64Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfResetToken'
    fn if_reset_token(&mut self, _arg: &IfResetToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfToken'
    fn if_token(&mut self, _arg: &IfToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ImportToken'
    fn import_token(&mut self, _arg: &ImportToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IncludeToken'
    fn include_token(&mut self, _arg: &IncludeToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InitialToken'
    fn initial_token(&mut self, _arg: &InitialToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InoutToken'
    fn inout_token(&mut self, _arg: &InoutToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InputToken'
    fn input_token(&mut self, _arg: &InputToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InsideToken'
    fn inside_token(&mut self, _arg: &InsideToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstToken'
    fn inst_token(&mut self, _arg: &InstToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceToken'
    fn interface_token(&mut self, _arg: &InterfaceToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InToken'
    fn in_token(&mut self, _arg: &InToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LetToken'
    fn let_token(&mut self, _arg: &LetToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LogicToken'
    fn logic_token(&mut self, _arg: &LogicToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LsbToken'
    fn lsb_token(&mut self, _arg: &LsbToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportToken'
    fn modport_token(&mut self, _arg: &ModportToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleToken'
    fn module_token(&mut self, _arg: &ModuleToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MsbToken'
    fn msb_token(&mut self, _arg: &MsbToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OutputToken'
    fn output_token(&mut self, _arg: &OutputToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OutsideToken'
    fn outside_token(&mut self, _arg: &OutsideToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PackageToken'
    fn package_token(&mut self, _arg: &PackageToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ParamToken'
    fn param_token(&mut self, _arg: &ParamToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProtoToken'
    fn proto_token(&mut self, _arg: &ProtoToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PubToken'
    fn pub_token(&mut self, _arg: &PubToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RepeatToken'
    fn repeat_token(&mut self, _arg: &RepeatToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ResetToken'
    fn reset_token(&mut self, _arg: &ResetToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ResetAsyncHighToken'
    fn reset_async_high_token(&mut self, _arg: &ResetAsyncHighToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ResetAsyncLowToken'
    fn reset_async_low_token(&mut self, _arg: &ResetAsyncLowToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ResetSyncHighToken'
    fn reset_sync_high_token(&mut self, _arg: &ResetSyncHighToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ResetSyncLowToken'
    fn reset_sync_low_token(&mut self, _arg: &ResetSyncLowToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ReturnToken'
    fn return_token(&mut self, _arg: &ReturnToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RevToken'
    fn rev_token(&mut self, _arg: &RevToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BreakToken'
    fn break_token(&mut self, _arg: &BreakToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SameToken'
    fn same_token(&mut self, _arg: &SameToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SignedToken'
    fn signed_token(&mut self, _arg: &SignedToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StepToken'
    fn step_token(&mut self, _arg: &StepToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StringToken'
    fn string_token(&mut self, _arg: &StringToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructToken'
    fn struct_token(&mut self, _arg: &StructToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SwitchToken'
    fn switch_token(&mut self, _arg: &SwitchToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TriToken'
    fn tri_token(&mut self, _arg: &TriToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TrueToken'
    fn true_token(&mut self, _arg: &TrueToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypeToken'
    fn type_token(&mut self, _arg: &TypeToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U8Token'
    fn u8_token(&mut self, _arg: &U8Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U16Token'
    fn u16_token(&mut self, _arg: &U16Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U32Token'
    fn u32_token(&mut self, _arg: &U32Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U64Token'
    fn u64_token(&mut self, _arg: &U64Token) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UnionToken'
    fn union_token(&mut self, _arg: &UnionToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UnsafeToken'
    fn unsafe_token(&mut self, _arg: &UnsafeToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'VarToken'
    fn var_token(&mut self, _arg: &VarToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DollarIdentifierToken'
    fn dollar_identifier_token(&mut self, _arg: &DollarIdentifierToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdentifierToken'
    fn identifier_token(&mut self, _arg: &IdentifierToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AnyToken'
    fn any_token(&mut self, _arg: &AnyToken) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Start'
    fn start(&mut self, _arg: &Start) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StringLiteral'
    fn string_literal(&mut self, _arg: &StringLiteral) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Exponent'
    fn exponent(&mut self, _arg: &Exponent) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FixedPoint'
    fn fixed_point(&mut self, _arg: &FixedPoint) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Based'
    fn based(&mut self, _arg: &Based) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BaseLess'
    fn base_less(&mut self, _arg: &BaseLess) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AllBit'
    fn all_bit(&mut self, _arg: &AllBit) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignmentOperator'
    fn assignment_operator(&mut self, _arg: &AssignmentOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DiamondOperator'
    fn diamond_operator(&mut self, _arg: &DiamondOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator02'
    fn operator02(&mut self, _arg: &Operator02) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator03'
    fn operator03(&mut self, _arg: &Operator03) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator04'
    fn operator04(&mut self, _arg: &Operator04) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator05'
    fn operator05(&mut self, _arg: &Operator05) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator06'
    fn operator06(&mut self, _arg: &Operator06) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator07'
    fn operator07(&mut self, _arg: &Operator07) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator08'
    fn operator08(&mut self, _arg: &Operator08) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator09'
    fn operator09(&mut self, _arg: &Operator09) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator10'
    fn operator10(&mut self, _arg: &Operator10) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator11'
    fn operator11(&mut self, _arg: &Operator11) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Operator12'
    fn operator12(&mut self, _arg: &Operator12) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UnaryOperator'
    fn unary_operator(&mut self, _arg: &UnaryOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Colon'
    fn colon(&mut self, _arg: &Colon) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonColonLAngle'
    fn colon_colon_l_angle(&mut self, _arg: &ColonColonLAngle) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ColonColon'
    fn colon_colon(&mut self, _arg: &ColonColon) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Comma'
    fn comma(&mut self, _arg: &Comma) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotDot'
    fn dot_dot(&mut self, _arg: &DotDot) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DotDotEqu'
    fn dot_dot_equ(&mut self, _arg: &DotDotEqu) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Dot'
    fn dot(&mut self, _arg: &Dot) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Equ'
    fn equ(&mut self, _arg: &Equ) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HashLBracket'
    fn hash_l_bracket(&mut self, _arg: &HashLBracket) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Hash'
    fn hash(&mut self, _arg: &Hash) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Question'
    fn question(&mut self, _arg: &Question) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'QuoteLBrace'
    fn quote_l_brace(&mut self, _arg: &QuoteLBrace) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Quote'
    fn quote(&mut self, _arg: &Quote) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LAngle'
    fn l_angle(&mut self, _arg: &LAngle) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EmbedLBrace'
    fn embed_l_brace(&mut self, _arg: &EmbedLBrace) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EscapedLBrace'
    fn escaped_l_brace(&mut self, _arg: &EscapedLBrace) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TripleLBrace'
    fn triple_l_brace(&mut self, _arg: &TripleLBrace) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBrace'
    fn l_brace(&mut self, _arg: &LBrace) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LBracket'
    fn l_bracket(&mut self, _arg: &LBracket) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LParen'
    fn l_paren(&mut self, _arg: &LParen) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LTMinus'
    fn l_t_minus(&mut self, _arg: &LTMinus) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusColon'
    fn minus_colon(&mut self, _arg: &MinusColon) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'MinusGT'
    fn minus_g_t(&mut self, _arg: &MinusGT) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PlusColon'
    fn plus_colon(&mut self, _arg: &PlusColon) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RAngle'
    fn r_angle(&mut self, _arg: &RAngle) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EmbedRBrace'
    fn embed_r_brace(&mut self, _arg: &EmbedRBrace) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EscapedRBrace'
    fn escaped_r_brace(&mut self, _arg: &EscapedRBrace) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TripleRBrace'
    fn triple_r_brace(&mut self, _arg: &TripleRBrace) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBrace'
    fn r_brace(&mut self, _arg: &RBrace) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RBracket'
    fn r_bracket(&mut self, _arg: &RBracket) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RParen'
    fn r_paren(&mut self, _arg: &RParen) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Semicolon'
    fn semicolon(&mut self, _arg: &Semicolon) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Star'
    fn star(&mut self, _arg: &Star) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Alias'
    fn alias(&mut self, _arg: &Alias) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysComb'
    fn always_comb(&mut self, _arg: &AlwaysComb) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFf'
    fn always_ff(&mut self, _arg: &AlwaysFf) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'As'
    fn r#as(&mut self, _arg: &As) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Assign'
    fn assign(&mut self, _arg: &Assign) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bind'
    fn bind(&mut self, _arg: &Bind) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bit'
    fn bit(&mut self, _arg: &Bit) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Bool'
    fn bool(&mut self, _arg: &Bool) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Break'
    fn r#break(&mut self, _arg: &Break) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Case'
    fn case(&mut self, _arg: &Case) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Clock'
    fn clock(&mut self, _arg: &Clock) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ClockPosedge'
    fn clock_posedge(&mut self, _arg: &ClockPosedge) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ClockNegedge'
    fn clock_negedge(&mut self, _arg: &ClockNegedge) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Connect'
    fn connect(&mut self, _arg: &Connect) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Const'
    fn r#const(&mut self, _arg: &Const) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Converse'
    fn converse(&mut self, _arg: &Converse) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Defaul'
    fn defaul(&mut self, _arg: &Defaul) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Else'
    fn r#else(&mut self, _arg: &Else) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Embed'
    fn embed(&mut self, _arg: &Embed) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Enum'
    fn r#enum(&mut self, _arg: &Enum) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F32'
    fn f32(&mut self, _arg: &F32) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'F64'
    fn f64(&mut self, _arg: &F64) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'False'
    fn r#false(&mut self, _arg: &False) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Final'
    fn r#final(&mut self, _arg: &Final) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'For'
    fn r#for(&mut self, _arg: &For) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Function'
    fn function(&mut self, _arg: &Function) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I8'
    fn i8(&mut self, _arg: &I8) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I16'
    fn i16(&mut self, _arg: &I16) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I32'
    fn i32(&mut self, _arg: &I32) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'I64'
    fn i64(&mut self, _arg: &I64) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'If'
    fn r#if(&mut self, _arg: &If) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfReset'
    fn if_reset(&mut self, _arg: &IfReset) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Import'
    fn import(&mut self, _arg: &Import) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'In'
    fn r#in(&mut self, _arg: &In) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Include'
    fn include(&mut self, _arg: &Include) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Initial'
    fn initial(&mut self, _arg: &Initial) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Inout'
    fn inout(&mut self, _arg: &Inout) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Input'
    fn input(&mut self, _arg: &Input) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Inside'
    fn inside(&mut self, _arg: &Inside) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Inst'
    fn inst(&mut self, _arg: &Inst) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Interface'
    fn interface(&mut self, _arg: &Interface) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Let'
    fn r#let(&mut self, _arg: &Let) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Logic'
    fn logic(&mut self, _arg: &Logic) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Lsb'
    fn lsb(&mut self, _arg: &Lsb) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Modport'
    fn modport(&mut self, _arg: &Modport) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Module'
    fn module(&mut self, _arg: &Module) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Msb'
    fn msb(&mut self, _arg: &Msb) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Output'
    fn output(&mut self, _arg: &Output) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Outside'
    fn outside(&mut self, _arg: &Outside) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Package'
    fn package(&mut self, _arg: &Package) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Param'
    fn param(&mut self, _arg: &Param) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Proto'
    fn proto(&mut self, _arg: &Proto) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Pub'
    fn r#pub(&mut self, _arg: &Pub) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Repeat'
    fn repeat(&mut self, _arg: &Repeat) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Reset'
    fn reset(&mut self, _arg: &Reset) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ResetAsyncHigh'
    fn reset_async_high(&mut self, _arg: &ResetAsyncHigh) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ResetAsyncLow'
    fn reset_async_low(&mut self, _arg: &ResetAsyncLow) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ResetSyncHigh'
    fn reset_sync_high(&mut self, _arg: &ResetSyncHigh) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ResetSyncLow'
    fn reset_sync_low(&mut self, _arg: &ResetSyncLow) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Return'
    fn r#return(&mut self, _arg: &Return) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Rev'
    fn rev(&mut self, _arg: &Rev) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Same'
    fn same(&mut self, _arg: &Same) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Signed'
    fn signed(&mut self, _arg: &Signed) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Step'
    fn step(&mut self, _arg: &Step) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Strin'
    fn strin(&mut self, _arg: &Strin) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Struct'
    fn r#struct(&mut self, _arg: &Struct) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Switch'
    fn switch(&mut self, _arg: &Switch) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Tri'
    fn tri(&mut self, _arg: &Tri) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'True'
    fn r#true(&mut self, _arg: &True) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Type'
    fn r#type(&mut self, _arg: &Type) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U8'
    fn u8(&mut self, _arg: &U8) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U16'
    fn u16(&mut self, _arg: &U16) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U32'
    fn u32(&mut self, _arg: &U32) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'U64'
    fn u64(&mut self, _arg: &U64) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Union'
    fn r#union(&mut self, _arg: &Union) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Unsafe'
    fn r#unsafe(&mut self, _arg: &Unsafe) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Var'
    fn var(&mut self, _arg: &Var) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DollarIdentifier'
    fn dollar_identifier(&mut self, _arg: &DollarIdentifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Identifier'
    fn identifier(&mut self, _arg: &Identifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Any'
    fn any(&mut self, _arg: &Any) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Number'
    fn number(&mut self, _arg: &Number) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IntegralNumber'
    fn integral_number(&mut self, _arg: &IntegralNumber) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RealNumber'
    fn real_number(&mut self, _arg: &RealNumber) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'HierarchicalIdentifier'
    fn hierarchical_identifier(&mut self, _arg: &HierarchicalIdentifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScopedIdentifier'
    fn scoped_identifier(&mut self, _arg: &ScopedIdentifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ExpressionIdentifier'
    fn expression_identifier(&mut self, _arg: &ExpressionIdentifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GenericArgIdentifier'
    fn generic_arg_identifier(&mut self, _arg: &GenericArgIdentifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression'
    fn expression(&mut self, _arg: &Expression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfExpression'
    fn if_expression(&mut self, _arg: &IfExpression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression01'
    fn expression01(&mut self, _arg: &Expression01) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression02'
    fn expression02(&mut self, _arg: &Expression02) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression03'
    fn expression03(&mut self, _arg: &Expression03) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression04'
    fn expression04(&mut self, _arg: &Expression04) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression05'
    fn expression05(&mut self, _arg: &Expression05) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression06'
    fn expression06(&mut self, _arg: &Expression06) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression07'
    fn expression07(&mut self, _arg: &Expression07) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression08'
    fn expression08(&mut self, _arg: &Expression08) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression09'
    fn expression09(&mut self, _arg: &Expression09) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression10'
    fn expression10(&mut self, _arg: &Expression10) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression11'
    fn expression11(&mut self, _arg: &Expression11) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression12'
    fn expression12(&mut self, _arg: &Expression12) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Expression13'
    fn expression13(&mut self, _arg: &Expression13) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Factor'
    fn factor(&mut self, _arg: &Factor) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BooleanLiteral'
    fn boolean_literal(&mut self, _arg: &BooleanLiteral) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdentifierFactor'
    fn identifier_factor(&mut self, _arg: &IdentifierFactor) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FactorTypeFactor'
    fn factor_type_factor(&mut self, _arg: &FactorTypeFactor) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FunctionCall'
    fn function_call(&mut self, _arg: &FunctionCall) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArgumentList'
    fn argument_list(&mut self, _arg: &ArgumentList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArgumentItem'
    fn argument_item(&mut self, _arg: &ArgumentItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArgumentExpression'
    fn argument_expression(&mut self, _arg: &ArgumentExpression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructConstructor'
    fn struct_constructor(&mut self, _arg: &StructConstructor) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructConstructorList'
    fn struct_constructor_list(&mut self, _arg: &StructConstructorList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructConstructorItem'
    fn struct_constructor_item(&mut self, _arg: &StructConstructorItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConcatenationList'
    fn concatenation_list(&mut self, _arg: &ConcatenationList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConcatenationItem'
    fn concatenation_item(&mut self, _arg: &ConcatenationItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayLiteralList'
    fn array_literal_list(&mut self, _arg: &ArrayLiteralList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayLiteralItem'
    fn array_literal_item(&mut self, _arg: &ArrayLiteralItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CaseExpression'
    fn case_expression(&mut self, _arg: &CaseExpression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SwitchExpression'
    fn switch_expression(&mut self, _arg: &SwitchExpression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypeExpression'
    fn type_expression(&mut self, _arg: &TypeExpression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InsideExpression'
    fn inside_expression(&mut self, _arg: &InsideExpression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'OutsideExpression'
    fn outside_expression(&mut self, _arg: &OutsideExpression) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RangeList'
    fn range_list(&mut self, _arg: &RangeList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RangeItem'
    fn range_item(&mut self, _arg: &RangeItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Select'
    fn select(&mut self, _arg: &Select) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SelectOperator'
    fn select_operator(&mut self, _arg: &SelectOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Width'
    fn width(&mut self, _arg: &Width) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Array'
    fn array(&mut self, _arg: &Array) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Range'
    fn range(&mut self, _arg: &Range) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'RangeOperator'
    fn range_operator(&mut self, _arg: &RangeOperator) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FixedType'
    fn fixed_type(&mut self, _arg: &FixedType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'VariableType'
    fn variable_type(&mut self, _arg: &VariableType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UserDefinedType'
    fn user_defined_type(&mut self, _arg: &UserDefinedType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypeModifier'
    fn type_modifier(&mut self, _arg: &TypeModifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FactorType'
    fn factor_type(&mut self, _arg: &FactorType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ScalarType'
    fn scalar_type(&mut self, _arg: &ScalarType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ArrayType'
    fn array_type(&mut self, _arg: &ArrayType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CastingType'
    fn casting_type(&mut self, _arg: &CastingType) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ClockDomain'
    fn clock_domain(&mut self, _arg: &ClockDomain) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StatementBlock'
    fn statement_block(&mut self, _arg: &StatementBlock) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StatementBlockGroup'
    fn statement_block_group(&mut self, _arg: &StatementBlockGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StatementBlockItem'
    fn statement_block_item(&mut self, _arg: &StatementBlockItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Statement'
    fn statement(&mut self, _arg: &Statement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LetStatement'
    fn let_statement(&mut self, _arg: &LetStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IdentifierStatement'
    fn identifier_statement(&mut self, _arg: &IdentifierStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Assignment'
    fn assignment(&mut self, _arg: &Assignment) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfStatement'
    fn if_statement(&mut self, _arg: &IfStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IfResetStatement'
    fn if_reset_statement(&mut self, _arg: &IfResetStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ReturnStatement'
    fn return_statement(&mut self, _arg: &ReturnStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BreakStatement'
    fn break_statement(&mut self, _arg: &BreakStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ForStatement'
    fn for_statement(&mut self, _arg: &ForStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CaseStatement'
    fn case_statement(&mut self, _arg: &CaseStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CaseItem'
    fn case_item(&mut self, _arg: &CaseItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'CaseCondition'
    fn case_condition(&mut self, _arg: &CaseCondition) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SwitchStatement'
    fn switch_statement(&mut self, _arg: &SwitchStatement) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SwitchItem'
    fn switch_item(&mut self, _arg: &SwitchItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'SwitchCondition'
    fn switch_condition(&mut self, _arg: &SwitchCondition) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Attribute'
    fn attribute(&mut self, _arg: &Attribute) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AttributeList'
    fn attribute_list(&mut self, _arg: &AttributeList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AttributeItem'
    fn attribute_item(&mut self, _arg: &AttributeItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'LetDeclaration'
    fn let_declaration(&mut self, _arg: &LetDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'VarDeclaration'
    fn var_declaration(&mut self, _arg: &VarDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConstDeclaration'
    fn const_declaration(&mut self, _arg: &ConstDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'TypeDefDeclaration'
    fn type_def_declaration(&mut self, _arg: &TypeDefDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfDeclaration'
    fn always_ff_declaration(&mut self, _arg: &AlwaysFfDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfEventList'
    fn always_ff_event_list(&mut self, _arg: &AlwaysFfEventList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfClock'
    fn always_ff_clock(&mut self, _arg: &AlwaysFfClock) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysFfReset'
    fn always_ff_reset(&mut self, _arg: &AlwaysFfReset) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AlwaysCombDeclaration'
    fn always_comb_declaration(&mut self, _arg: &AlwaysCombDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignDeclaration'
    fn assign_declaration(&mut self, _arg: &AssignDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignDestination'
    fn assign_destination(&mut self, _arg: &AssignDestination) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignConcatenationList'
    fn assign_concatenation_list(&mut self, _arg: &AssignConcatenationList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AssignConcatenationItem'
    fn assign_concatenation_item(&mut self, _arg: &AssignConcatenationItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ConnectDeclaration'
    fn connect_declaration(&mut self, _arg: &ConnectDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportDeclaration'
    fn modport_declaration(&mut self, _arg: &ModportDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportList'
    fn modport_list(&mut self, _arg: &ModportList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportGroup'
    fn modport_group(&mut self, _arg: &ModportGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportItem'
    fn modport_item(&mut self, _arg: &ModportItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModportDefault'
    fn modport_default(&mut self, _arg: &ModportDefault) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EnumDeclaration'
    fn enum_declaration(&mut self, _arg: &EnumDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EnumList'
    fn enum_list(&mut self, _arg: &EnumList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EnumGroup'
    fn enum_group(&mut self, _arg: &EnumGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EnumItem'
    fn enum_item(&mut self, _arg: &EnumItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructUnion'
    fn struct_union(&mut self, _arg: &StructUnion) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructUnionDeclaration'
    fn struct_union_declaration(&mut self, _arg: &StructUnionDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructUnionList'
    fn struct_union_list(&mut self, _arg: &StructUnionList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructUnionGroup'
    fn struct_union_group(&mut self, _arg: &StructUnionGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'StructUnionItem'
    fn struct_union_item(&mut self, _arg: &StructUnionItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InitialDeclaration'
    fn initial_declaration(&mut self, _arg: &InitialDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FinalDeclaration'
    fn final_declaration(&mut self, _arg: &FinalDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstDeclaration'
    fn inst_declaration(&mut self, _arg: &InstDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'BindDeclaration'
    fn bind_declaration(&mut self, _arg: &BindDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ComponentInstantiation'
    fn component_instantiation(&mut self, _arg: &ComponentInstantiation) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstParameter'
    fn inst_parameter(&mut self, _arg: &InstParameter) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstParameterList'
    fn inst_parameter_list(&mut self, _arg: &InstParameterList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstParameterGroup'
    fn inst_parameter_group(&mut self, _arg: &InstParameterGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstParameterItem'
    fn inst_parameter_item(&mut self, _arg: &InstParameterItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstPort'
    fn inst_port(&mut self, _arg: &InstPort) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstPortList'
    fn inst_port_list(&mut self, _arg: &InstPortList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstPortGroup'
    fn inst_port_group(&mut self, _arg: &InstPortGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InstPortItem'
    fn inst_port_item(&mut self, _arg: &InstPortItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithParameter'
    fn with_parameter(&mut self, _arg: &WithParameter) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithParameterList'
    fn with_parameter_list(&mut self, _arg: &WithParameterList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithParameterGroup'
    fn with_parameter_group(&mut self, _arg: &WithParameterGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithParameterItem'
    fn with_parameter_item(&mut self, _arg: &WithParameterItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GenericBound'
    fn generic_bound(&mut self, _arg: &GenericBound) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithGenericParameter'
    fn with_generic_parameter(&mut self, _arg: &WithGenericParameter) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithGenericParameterList'
    fn with_generic_parameter_list(&mut self, _arg: &WithGenericParameterList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithGenericParameterItem'
    fn with_generic_parameter_item(&mut self, _arg: &WithGenericParameterItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GenericProtoBound'
    fn generic_proto_bound(&mut self, _arg: &GenericProtoBound) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithGenericArgument'
    fn with_generic_argument(&mut self, _arg: &WithGenericArgument) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithGenericArgumentList'
    fn with_generic_argument_list(&mut self, _arg: &WithGenericArgumentList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'WithGenericArgumentItem'
    fn with_generic_argument_item(&mut self, _arg: &WithGenericArgumentItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PortDeclaration'
    fn port_declaration(&mut self, _arg: &PortDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PortDeclarationList'
    fn port_declaration_list(&mut self, _arg: &PortDeclarationList) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PortDeclarationGroup'
    fn port_declaration_group(&mut self, _arg: &PortDeclarationGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PortDeclarationItem'
    fn port_declaration_item(&mut self, _arg: &PortDeclarationItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PortTypeConcrete'
    fn port_type_concrete(&mut self, _arg: &PortTypeConcrete) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PortDefaultValue'
    fn port_default_value(&mut self, _arg: &PortDefaultValue) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PortTypeAbstract'
    fn port_type_abstract(&mut self, _arg: &PortTypeAbstract) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Direction'
    fn direction(&mut self, _arg: &Direction) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'FunctionDeclaration'
    fn function_declaration(&mut self, _arg: &FunctionDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ImportDeclaration'
    fn import_declaration(&mut self, _arg: &ImportDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'UnsafeBlock'
    fn unsafe_block(&mut self, _arg: &UnsafeBlock) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleDeclaration'
    fn module_declaration(&mut self, _arg: &ModuleDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleGroup'
    fn module_group(&mut self, _arg: &ModuleGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ModuleItem'
    fn module_item(&mut self, _arg: &ModuleItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceDeclaration'
    fn interface_declaration(&mut self, _arg: &InterfaceDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceGroup'
    fn interface_group(&mut self, _arg: &InterfaceGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'InterfaceItem'
    fn interface_item(&mut self, _arg: &InterfaceItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GenerateIfDeclaration'
    fn generate_if_declaration(&mut self, _arg: &GenerateIfDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GenerateForDeclaration'
    fn generate_for_declaration(&mut self, _arg: &GenerateForDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GenerateBlockDeclaration'
    fn generate_block_declaration(&mut self, _arg: &GenerateBlockDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GenerateNamedBlock'
    fn generate_named_block(&mut self, _arg: &GenerateNamedBlock) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GenerateOptionalNamedBlock'
    fn generate_optional_named_block(&mut self, _arg: &GenerateOptionalNamedBlock) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GenerateGroup'
    fn generate_group(&mut self, _arg: &GenerateGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'GenerateItem'
    fn generate_item(&mut self, _arg: &GenerateItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PackageDeclaration'
    fn package_declaration(&mut self, _arg: &PackageDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PackageGroup'
    fn package_group(&mut self, _arg: &PackageGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PackageItem'
    fn package_item(&mut self, _arg: &PackageItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'AliasDeclaration'
    fn alias_declaration(&mut self, _arg: &AliasDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProtoDeclaration'
    fn proto_declaration(&mut self, _arg: &ProtoDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProtoModuleDeclaration'
    fn proto_module_declaration(&mut self, _arg: &ProtoModuleDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProtoInterfaceDeclaration'
    fn proto_interface_declaration(&mut self, _arg: &ProtoInterfaceDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProtoInterfaceItem'
    fn proto_interface_item(&mut self, _arg: &ProtoInterfaceItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProtoPackageDeclaration'
    fn proto_package_declaration(&mut self, _arg: &ProtoPackageDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProtoPacakgeItem'
    fn proto_pacakge_item(&mut self, _arg: &ProtoPacakgeItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProtoConstDeclaration'
    fn proto_const_declaration(&mut self, _arg: &ProtoConstDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProtoTypeDefDeclaration'
    fn proto_type_def_declaration(&mut self, _arg: &ProtoTypeDefDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProtoFunctionDeclaration'
    fn proto_function_declaration(&mut self, _arg: &ProtoFunctionDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'ProtoAliasDeclaration'
    fn proto_alias_declaration(&mut self, _arg: &ProtoAliasDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EmbedDeclaration'
    fn embed_declaration(&mut self, _arg: &EmbedDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EmbedContent'
    fn embed_content(&mut self, _arg: &EmbedContent) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EmbedScopedIdentifier'
    fn embed_scoped_identifier(&mut self, _arg: &EmbedScopedIdentifier) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'EmbedItem'
    fn embed_item(&mut self, _arg: &EmbedItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'IncludeDeclaration'
    fn include_declaration(&mut self, _arg: &IncludeDeclaration) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DescriptionGroup'
    fn description_group(&mut self, _arg: &DescriptionGroup) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'DescriptionItem'
    fn description_item(&mut self, _arg: &DescriptionItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'PublicDescriptionItem'
    fn public_description_item(&mut self, _arg: &PublicDescriptionItem) -> Result<()> {
        Ok(())
    }

    /// Semantic action for non-terminal 'Veryl'
    fn veryl(&mut self, _arg: &Veryl) -> Result<()> {
        Ok(())
    }

    /// This method provides skipped language comments.
    /// If you need comments please provide your own implementation of this method.
    fn on_comment(&mut self, _token: Token<'_>) {}
}

// -------------------------------------------------------------------------------------------------
//
// Output Types of productions deduced from the structure of the transformed grammar
//

///
/// Type derived for production 403
///
/// `Number: IntegralNumber;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct NumberIntegralNumber {
    pub integral_number: Box<IntegralNumber>,
}

///
/// Type derived for production 404
///
/// `Number: RealNumber;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct NumberRealNumber {
    pub real_number: Box<RealNumber>,
}

///
/// Type derived for production 405
///
/// `IntegralNumber: Based;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IntegralNumberBased {
    pub based: Box<Based>,
}

///
/// Type derived for production 406
///
/// `IntegralNumber: BaseLess;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IntegralNumberBaseLess {
    pub base_less: Box<BaseLess>,
}

///
/// Type derived for production 407
///
/// `IntegralNumber: AllBit;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IntegralNumberAllBit {
    pub all_bit: Box<AllBit>,
}

///
/// Type derived for production 408
///
/// `RealNumber: FixedPoint;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RealNumberFixedPoint {
    pub fixed_point: Box<FixedPoint>,
}

///
/// Type derived for production 409
///
/// `RealNumber: Exponent;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RealNumberExponent {
    pub exponent: Box<Exponent>,
}

///
/// Type derived for production 418
///
/// `ScopedIdentifierGroup: DollarIdentifier;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScopedIdentifierGroupDollarIdentifier {
    pub dollar_identifier: Box<DollarIdentifier>,
}

///
/// Type derived for production 419
///
/// `ScopedIdentifierGroup: Identifier ScopedIdentifierOpt /* Option */;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScopedIdentifierGroupIdentifierScopedIdentifierOpt {
    pub identifier: Box<Identifier>,
    pub scoped_identifier_opt: Option<ScopedIdentifierOpt>,
}

///
/// Type derived for production 471
///
/// `Expression10ListGroup: Operator11;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression10ListGroupOperator11 {
    pub operator11: Box<Operator11>,
}

///
/// Type derived for production 472
///
/// `Expression10ListGroup: Star;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression10ListGroupStar {
    pub star: Box<Star>,
}

///
/// Type derived for production 482
///
/// `Expression13ListGroup: UnaryOperator;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression13ListGroupUnaryOperator {
    pub unary_operator: Box<UnaryOperator>,
}

///
/// Type derived for production 483
///
/// `Expression13ListGroup: Operator10;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression13ListGroupOperator10 {
    pub operator10: Box<Operator10>,
}

///
/// Type derived for production 484
///
/// `Expression13ListGroup: Operator06;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression13ListGroupOperator06 {
    pub operator06: Box<Operator06>,
}

///
/// Type derived for production 485
///
/// `Expression13ListGroup: Operator04;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression13ListGroupOperator04 {
    pub operator04: Box<Operator04>,
}

///
/// Type derived for production 486
///
/// `Expression13ListGroup: Operator05;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression13ListGroupOperator05 {
    pub operator05: Box<Operator05>,
}

///
/// Type derived for production 488
///
/// `Factor: Number;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorNumber {
    pub number: Box<Number>,
}

///
/// Type derived for production 489
///
/// `Factor: BooleanLiteral;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorBooleanLiteral {
    pub boolean_literal: Box<BooleanLiteral>,
}

///
/// Type derived for production 490
///
/// `Factor: IdentifierFactor;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorIdentifierFactor {
    pub identifier_factor: Box<IdentifierFactor>,
}

///
/// Type derived for production 491
///
/// `Factor: LParen Expression RParen;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorLParenExpressionRParen {
    pub l_paren: Box<LParen>,
    pub expression: Box<Expression>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for production 492
///
/// `Factor: LBrace ConcatenationList RBrace;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorLBraceConcatenationListRBrace {
    pub l_brace: Box<LBrace>,
    pub concatenation_list: Box<ConcatenationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 493
///
/// `Factor: QuoteLBrace ArrayLiteralList RBrace;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorQuoteLBraceArrayLiteralListRBrace {
    pub quote_l_brace: Box<QuoteLBrace>,
    pub array_literal_list: Box<ArrayLiteralList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 494
///
/// `Factor: CaseExpression;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorCaseExpression {
    pub case_expression: Box<CaseExpression>,
}

///
/// Type derived for production 495
///
/// `Factor: SwitchExpression;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorSwitchExpression {
    pub switch_expression: Box<SwitchExpression>,
}

///
/// Type derived for production 496
///
/// `Factor: StringLiteral;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorStringLiteral {
    pub string_literal: Box<StringLiteral>,
}

///
/// Type derived for production 497
///
/// `Factor: FactorGroup;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorFactorGroup {
    pub factor_group: Box<FactorGroup>,
}

///
/// Type derived for production 498
///
/// `FactorGroup: Msb;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorGroupMsb {
    pub msb: Box<Msb>,
}

///
/// Type derived for production 499
///
/// `FactorGroup: Lsb;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorGroupLsb {
    pub lsb: Box<Lsb>,
}

///
/// Type derived for production 500
///
/// `Factor: InsideExpression;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorInsideExpression {
    pub inside_expression: Box<InsideExpression>,
}

///
/// Type derived for production 501
///
/// `Factor: OutsideExpression;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorOutsideExpression {
    pub outside_expression: Box<OutsideExpression>,
}

///
/// Type derived for production 502
///
/// `Factor: TypeExpression;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorTypeExpression {
    pub type_expression: Box<TypeExpression>,
}

///
/// Type derived for production 503
///
/// `Factor: FactorTypeFactor;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorFactorTypeFactor {
    pub factor_type_factor: Box<FactorTypeFactor>,
}

///
/// Type derived for production 504
///
/// `BooleanLiteral: True;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BooleanLiteralTrue {
    pub r#true: Box<True>,
}

///
/// Type derived for production 505
///
/// `BooleanLiteral: False;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BooleanLiteralFalse {
    pub r#false: Box<False>,
}

///
/// Type derived for production 508
///
/// `IdentifierFactorOptGroup: FunctionCall;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IdentifierFactorOptGroupFunctionCall {
    pub function_call: Box<FunctionCall>,
}

///
/// Type derived for production 509
///
/// `IdentifierFactorOptGroup: StructConstructor;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IdentifierFactorOptGroupStructConstructor {
    pub struct_constructor: Box<StructConstructor>,
}

///
/// Type derived for production 549
///
/// `ArrayLiteralItemGroup: Expression ArrayLiteralItemOpt /* Option */;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayLiteralItemGroupExpressionArrayLiteralItemOpt {
    pub expression: Box<Expression>,
    pub array_literal_item_opt: Option<ArrayLiteralItemOpt>,
}

///
/// Type derived for production 550
///
/// `ArrayLiteralItemGroup: Defaul Colon Expression;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayLiteralItemGroupDefaulColonExpression {
    pub defaul: Box<Defaul>,
    pub colon: Box<Colon>,
    pub expression: Box<Expression>,
}

///
/// Type derived for production 575
///
/// `SelectOperator: Colon;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SelectOperatorColon {
    pub colon: Box<Colon>,
}

///
/// Type derived for production 576
///
/// `SelectOperator: PlusColon;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SelectOperatorPlusColon {
    pub plus_colon: Box<PlusColon>,
}

///
/// Type derived for production 577
///
/// `SelectOperator: MinusColon;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SelectOperatorMinusColon {
    pub minus_colon: Box<MinusColon>,
}

///
/// Type derived for production 578
///
/// `SelectOperator: Step;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SelectOperatorStep {
    pub step: Box<Step>,
}

///
/// Type derived for production 588
///
/// `RangeOperator: DotDot;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RangeOperatorDotDot {
    pub dot_dot: Box<DotDot>,
}

///
/// Type derived for production 589
///
/// `RangeOperator: DotDotEqu;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RangeOperatorDotDotEqu {
    pub dot_dot_equ: Box<DotDotEqu>,
}

///
/// Type derived for production 590
///
/// `FixedType: U8;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FixedTypeU8 {
    pub u8: Box<U8>,
}

///
/// Type derived for production 591
///
/// `FixedType: U16;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FixedTypeU16 {
    pub u16: Box<U16>,
}

///
/// Type derived for production 592
///
/// `FixedType: U32;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FixedTypeU32 {
    pub u32: Box<U32>,
}

///
/// Type derived for production 593
///
/// `FixedType: U64;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FixedTypeU64 {
    pub u64: Box<U64>,
}

///
/// Type derived for production 594
///
/// `FixedType: I8;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FixedTypeI8 {
    pub i8: Box<I8>,
}

///
/// Type derived for production 595
///
/// `FixedType: I16;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FixedTypeI16 {
    pub i16: Box<I16>,
}

///
/// Type derived for production 596
///
/// `FixedType: I32;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FixedTypeI32 {
    pub i32: Box<I32>,
}

///
/// Type derived for production 597
///
/// `FixedType: I64;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FixedTypeI64 {
    pub i64: Box<I64>,
}

///
/// Type derived for production 598
///
/// `FixedType: F32;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FixedTypeF32 {
    pub f32: Box<F32>,
}

///
/// Type derived for production 599
///
/// `FixedType: F64;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FixedTypeF64 {
    pub f64: Box<F64>,
}

///
/// Type derived for production 600
///
/// `FixedType: Bool;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FixedTypeBool {
    pub bool: Box<Bool>,
}

///
/// Type derived for production 601
///
/// `FixedType: Strin;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FixedTypeStrin {
    pub strin: Box<Strin>,
}

///
/// Type derived for production 602
///
/// `VariableType: Clock;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct VariableTypeClock {
    pub clock: Box<Clock>,
}

///
/// Type derived for production 603
///
/// `VariableType: ClockPosedge;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct VariableTypeClockPosedge {
    pub clock_posedge: Box<ClockPosedge>,
}

///
/// Type derived for production 604
///
/// `VariableType: ClockNegedge;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct VariableTypeClockNegedge {
    pub clock_negedge: Box<ClockNegedge>,
}

///
/// Type derived for production 605
///
/// `VariableType: Reset;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct VariableTypeReset {
    pub reset: Box<Reset>,
}

///
/// Type derived for production 606
///
/// `VariableType: ResetAsyncHigh;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct VariableTypeResetAsyncHigh {
    pub reset_async_high: Box<ResetAsyncHigh>,
}

///
/// Type derived for production 607
///
/// `VariableType: ResetAsyncLow;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct VariableTypeResetAsyncLow {
    pub reset_async_low: Box<ResetAsyncLow>,
}

///
/// Type derived for production 608
///
/// `VariableType: ResetSyncHigh;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct VariableTypeResetSyncHigh {
    pub reset_sync_high: Box<ResetSyncHigh>,
}

///
/// Type derived for production 609
///
/// `VariableType: ResetSyncLow;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct VariableTypeResetSyncLow {
    pub reset_sync_low: Box<ResetSyncLow>,
}

///
/// Type derived for production 610
///
/// `VariableType: Logic;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct VariableTypeLogic {
    pub logic: Box<Logic>,
}

///
/// Type derived for production 611
///
/// `VariableType: Bit;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct VariableTypeBit {
    pub bit: Box<Bit>,
}

///
/// Type derived for production 613
///
/// `TypeModifier: Tri;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TypeModifierTri {
    pub tri: Box<Tri>,
}

///
/// Type derived for production 614
///
/// `TypeModifier: Signed;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TypeModifierSigned {
    pub signed: Box<Signed>,
}

///
/// Type derived for production 615
///
/// `TypeModifier: Defaul;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TypeModifierDefaul {
    pub defaul: Box<Defaul>,
}

///
/// Type derived for production 617
///
/// `FactorTypeGroup: VariableType FactorTypeOpt /* Option */;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorTypeGroupVariableTypeFactorTypeOpt {
    pub variable_type: Box<VariableType>,
    pub factor_type_opt: Option<FactorTypeOpt>,
}

///
/// Type derived for production 618
///
/// `FactorTypeGroup: FixedType;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorTypeGroupFixedType {
    pub fixed_type: Box<FixedType>,
}

///
/// Type derived for production 622
///
/// `ScalarTypeGroup: UserDefinedType ScalarTypeOpt /* Option */;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScalarTypeGroupUserDefinedTypeScalarTypeOpt {
    pub user_defined_type: Box<UserDefinedType>,
    pub scalar_type_opt: Option<ScalarTypeOpt>,
}

///
/// Type derived for production 623
///
/// `ScalarTypeGroup: FactorType;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScalarTypeGroupFactorType {
    pub factor_type: Box<FactorType>,
}

///
/// Type derived for production 631
///
/// `CastingType: U8;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeU8 {
    pub u8: Box<U8>,
}

///
/// Type derived for production 632
///
/// `CastingType: U16;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeU16 {
    pub u16: Box<U16>,
}

///
/// Type derived for production 633
///
/// `CastingType: U32;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeU32 {
    pub u32: Box<U32>,
}

///
/// Type derived for production 634
///
/// `CastingType: U64;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeU64 {
    pub u64: Box<U64>,
}

///
/// Type derived for production 635
///
/// `CastingType: I8;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeI8 {
    pub i8: Box<I8>,
}

///
/// Type derived for production 636
///
/// `CastingType: I16;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeI16 {
    pub i16: Box<I16>,
}

///
/// Type derived for production 637
///
/// `CastingType: I32;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeI32 {
    pub i32: Box<I32>,
}

///
/// Type derived for production 638
///
/// `CastingType: I64;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeI64 {
    pub i64: Box<I64>,
}

///
/// Type derived for production 639
///
/// `CastingType: F32;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeF32 {
    pub f32: Box<F32>,
}

///
/// Type derived for production 640
///
/// `CastingType: F64;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeF64 {
    pub f64: Box<F64>,
}

///
/// Type derived for production 641
///
/// `CastingType: Bool;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeBool {
    pub bool: Box<Bool>,
}

///
/// Type derived for production 642
///
/// `CastingType: Clock;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeClock {
    pub clock: Box<Clock>,
}

///
/// Type derived for production 643
///
/// `CastingType: ClockPosedge;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeClockPosedge {
    pub clock_posedge: Box<ClockPosedge>,
}

///
/// Type derived for production 644
///
/// `CastingType: ClockNegedge;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeClockNegedge {
    pub clock_negedge: Box<ClockNegedge>,
}

///
/// Type derived for production 645
///
/// `CastingType: Reset;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeReset {
    pub reset: Box<Reset>,
}

///
/// Type derived for production 646
///
/// `CastingType: ResetAsyncHigh;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeResetAsyncHigh {
    pub reset_async_high: Box<ResetAsyncHigh>,
}

///
/// Type derived for production 647
///
/// `CastingType: ResetAsyncLow;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeResetAsyncLow {
    pub reset_async_low: Box<ResetAsyncLow>,
}

///
/// Type derived for production 648
///
/// `CastingType: ResetSyncHigh;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeResetSyncHigh {
    pub reset_sync_high: Box<ResetSyncHigh>,
}

///
/// Type derived for production 649
///
/// `CastingType: ResetSyncLow;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeResetSyncLow {
    pub reset_sync_low: Box<ResetSyncLow>,
}

///
/// Type derived for production 650
///
/// `CastingType: UserDefinedType;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeUserDefinedType {
    pub user_defined_type: Box<UserDefinedType>,
}

///
/// Type derived for production 651
///
/// `CastingType: Based;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeBased {
    pub based: Box<Based>,
}

///
/// Type derived for production 652
///
/// `CastingType: BaseLess;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CastingTypeBaseLess {
    pub base_less: Box<BaseLess>,
}

///
/// Type derived for production 658
///
/// `StatementBlockGroupGroup: LBrace StatementBlockGroupGroupList /* Vec */ RBrace;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StatementBlockGroupGroupLBraceStatementBlockGroupGroupListRBrace {
    pub l_brace: Box<LBrace>,
    pub statement_block_group_group_list: Vec<StatementBlockGroupGroupList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 661
///
/// `StatementBlockGroupGroup: StatementBlockItem;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StatementBlockGroupGroupStatementBlockItem {
    pub statement_block_item: Box<StatementBlockItem>,
}

///
/// Type derived for production 664
///
/// `StatementBlockItem: VarDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StatementBlockItemVarDeclaration {
    pub var_declaration: Box<VarDeclaration>,
}

///
/// Type derived for production 665
///
/// `StatementBlockItem: LetStatement;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StatementBlockItemLetStatement {
    pub let_statement: Box<LetStatement>,
}

///
/// Type derived for production 666
///
/// `StatementBlockItem: ConstDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StatementBlockItemConstDeclaration {
    pub const_declaration: Box<ConstDeclaration>,
}

///
/// Type derived for production 667
///
/// `StatementBlockItem: Statement;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StatementBlockItemStatement {
    pub statement: Box<Statement>,
}

///
/// Type derived for production 668
///
/// `Statement: IdentifierStatement;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StatementIdentifierStatement {
    pub identifier_statement: Box<IdentifierStatement>,
}

///
/// Type derived for production 669
///
/// `Statement: IfStatement;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StatementIfStatement {
    pub if_statement: Box<IfStatement>,
}

///
/// Type derived for production 670
///
/// `Statement: IfResetStatement;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StatementIfResetStatement {
    pub if_reset_statement: Box<IfResetStatement>,
}

///
/// Type derived for production 671
///
/// `Statement: ReturnStatement;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StatementReturnStatement {
    pub return_statement: Box<ReturnStatement>,
}

///
/// Type derived for production 672
///
/// `Statement: BreakStatement;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StatementBreakStatement {
    pub break_statement: Box<BreakStatement>,
}

///
/// Type derived for production 673
///
/// `Statement: ForStatement;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StatementForStatement {
    pub for_statement: Box<ForStatement>,
}

///
/// Type derived for production 674
///
/// `Statement: CaseStatement;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StatementCaseStatement {
    pub case_statement: Box<CaseStatement>,
}

///
/// Type derived for production 675
///
/// `Statement: SwitchStatement;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StatementSwitchStatement {
    pub switch_statement: Box<SwitchStatement>,
}

///
/// Type derived for production 680
///
/// `IdentifierStatementGroup: FunctionCall;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IdentifierStatementGroupFunctionCall {
    pub function_call: Box<FunctionCall>,
}

///
/// Type derived for production 681
///
/// `IdentifierStatementGroup: Assignment;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IdentifierStatementGroupAssignment {
    pub assignment: Box<Assignment>,
}

///
/// Type derived for production 683
///
/// `AssignmentGroup: Equ;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AssignmentGroupEqu {
    pub equ: Box<Equ>,
}

///
/// Type derived for production 684
///
/// `AssignmentGroup: AssignmentOperator;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AssignmentGroupAssignmentOperator {
    pub assignment_operator: Box<AssignmentOperator>,
}

///
/// Type derived for production 685
///
/// `AssignmentGroup: DiamondOperator;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AssignmentGroupDiamondOperator {
    pub diamond_operator: Box<DiamondOperator>,
}

///
/// Type derived for production 707
///
/// `CaseItemGroup0: Statement;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CaseItemGroup0Statement {
    pub statement: Box<Statement>,
}

///
/// Type derived for production 708
///
/// `CaseItemGroup0: StatementBlock;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CaseItemGroup0StatementBlock {
    pub statement_block: Box<StatementBlock>,
}

///
/// Type derived for production 709
///
/// `CaseItemGroup: CaseCondition;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CaseItemGroupCaseCondition {
    pub case_condition: Box<CaseCondition>,
}

///
/// Type derived for production 710
///
/// `CaseItemGroup: Defaul;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CaseItemGroupDefaul {
    pub defaul: Box<Defaul>,
}

///
/// Type derived for production 718
///
/// `SwitchItemGroup0: Statement;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SwitchItemGroup0Statement {
    pub statement: Box<Statement>,
}

///
/// Type derived for production 719
///
/// `SwitchItemGroup0: StatementBlock;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SwitchItemGroup0StatementBlock {
    pub statement_block: Box<StatementBlock>,
}

///
/// Type derived for production 720
///
/// `SwitchItemGroup: SwitchCondition;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SwitchItemGroupSwitchCondition {
    pub switch_condition: Box<SwitchCondition>,
}

///
/// Type derived for production 721
///
/// `SwitchItemGroup: Defaul;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SwitchItemGroupDefaul {
    pub defaul: Box<Defaul>,
}

///
/// Type derived for production 733
///
/// `AttributeItem: Identifier;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AttributeItemIdentifier {
    pub identifier: Box<Identifier>,
}

///
/// Type derived for production 734
///
/// `AttributeItem: StringLiteral;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AttributeItemStringLiteral {
    pub string_literal: Box<StringLiteral>,
}

///
/// Type derived for production 742
///
/// `ConstDeclarationGroup: ArrayType;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConstDeclarationGroupArrayType {
    pub array_type: Box<ArrayType>,
}

///
/// Type derived for production 743
///
/// `ConstDeclarationGroup: Type;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConstDeclarationGroupType {
    pub r#type: Box<Type>,
}

///
/// Type derived for production 755
///
/// `AssignDestination: HierarchicalIdentifier;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AssignDestinationHierarchicalIdentifier {
    pub hierarchical_identifier: Box<HierarchicalIdentifier>,
}

///
/// Type derived for production 756
///
/// `AssignDestination: LBrace AssignConcatenationList RBrace;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AssignDestinationLBraceAssignConcatenationListRBrace {
    pub l_brace: Box<LBrace>,
    pub assign_concatenation_list: Box<AssignConcatenationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 775
///
/// `ModportGroupGroup: LBrace ModportList RBrace;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModportGroupGroupLBraceModportListRBrace {
    pub l_brace: Box<LBrace>,
    pub modport_list: Box<ModportList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 776
///
/// `ModportGroupGroup: ModportItem;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModportGroupGroupModportItem {
    pub modport_item: Box<ModportItem>,
}

///
/// Type derived for production 780
///
/// `ModportDefault: Input;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModportDefaultInput {
    pub input: Box<Input>,
}

///
/// Type derived for production 781
///
/// `ModportDefault: Output;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModportDefaultOutput {
    pub output: Box<Output>,
}

///
/// Type derived for production 782
///
/// `ModportDefault: Same LParen Identifier RParen;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModportDefaultSameLParenIdentifierRParen {
    pub same: Box<Same>,
    pub l_paren: Box<LParen>,
    pub identifier: Box<Identifier>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for production 783
///
/// `ModportDefault: Converse LParen Identifier RParen;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModportDefaultConverseLParenIdentifierRParen {
    pub converse: Box<Converse>,
    pub l_paren: Box<LParen>,
    pub identifier: Box<Identifier>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for production 793
///
/// `EnumGroupGroup: LBrace EnumList RBrace;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EnumGroupGroupLBraceEnumListRBrace {
    pub l_brace: Box<LBrace>,
    pub enum_list: Box<EnumList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 794
///
/// `EnumGroupGroup: EnumItem;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EnumGroupGroupEnumItem {
    pub enum_item: Box<EnumItem>,
}

///
/// Type derived for production 800
///
/// `StructUnion: Struct;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructUnionStruct {
    pub r#struct: Box<Struct>,
}

///
/// Type derived for production 801
///
/// `StructUnion: Union;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructUnionUnion {
    pub r#union: Box<Union>,
}

///
/// Type derived for production 811
///
/// `StructUnionGroupGroup: LBrace StructUnionList RBrace;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructUnionGroupGroupLBraceStructUnionListRBrace {
    pub l_brace: Box<LBrace>,
    pub struct_union_list: Box<StructUnionList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 812
///
/// `StructUnionGroupGroup: StructUnionItem;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructUnionGroupGroupStructUnionItem {
    pub struct_union_item: Box<StructUnionItem>,
}

///
/// Type derived for production 838
///
/// `InstParameterGroupGroup: LBrace InstParameterList RBrace;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstParameterGroupGroupLBraceInstParameterListRBrace {
    pub l_brace: Box<LBrace>,
    pub inst_parameter_list: Box<InstParameterList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 839
///
/// `InstParameterGroupGroup: InstParameterItem;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstParameterGroupGroupInstParameterItem {
    pub inst_parameter_item: Box<InstParameterItem>,
}

///
/// Type derived for production 854
///
/// `InstPortGroupGroup: LBrace InstPortList RBrace;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstPortGroupGroupLBraceInstPortListRBrace {
    pub l_brace: Box<LBrace>,
    pub inst_port_list: Box<InstPortList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 855
///
/// `InstPortGroupGroup: InstPortItem;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstPortGroupGroupInstPortItem {
    pub inst_port_item: Box<InstPortItem>,
}

///
/// Type derived for production 870
///
/// `WithParameterGroupGroup: LBrace WithParameterList RBrace;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithParameterGroupGroupLBraceWithParameterListRBrace {
    pub l_brace: Box<LBrace>,
    pub with_parameter_list: Box<WithParameterList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 871
///
/// `WithParameterGroupGroup: WithParameterItem;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithParameterGroupGroupWithParameterItem {
    pub with_parameter_item: Box<WithParameterItem>,
}

///
/// Type derived for production 875
///
/// `WithParameterItemGroup0: ArrayType;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithParameterItemGroup0ArrayType {
    pub array_type: Box<ArrayType>,
}

///
/// Type derived for production 876
///
/// `WithParameterItemGroup0: Type;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithParameterItemGroup0Type {
    pub r#type: Box<Type>,
}

///
/// Type derived for production 877
///
/// `WithParameterItemGroup: Param;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithParameterItemGroupParam {
    pub param: Box<Param>,
}

///
/// Type derived for production 878
///
/// `WithParameterItemGroup: Const;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithParameterItemGroupConst {
    pub r#const: Box<Const>,
}

///
/// Type derived for production 881
///
/// `GenericBound: Type;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenericBoundType {
    pub r#type: Box<Type>,
}

///
/// Type derived for production 882
///
/// `GenericBound: Inst ScopedIdentifier;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenericBoundInstScopedIdentifier {
    pub inst: Box<Inst>,
    pub scoped_identifier: Box<ScopedIdentifier>,
}

///
/// Type derived for production 883
///
/// `GenericBound: GenericProtoBound;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenericBoundGenericProtoBound {
    pub generic_proto_bound: Box<GenericProtoBound>,
}

///
/// Type derived for production 893
///
/// `GenericProtoBound: ScopedIdentifier;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenericProtoBoundScopedIdentifier {
    pub scoped_identifier: Box<ScopedIdentifier>,
}

///
/// Type derived for production 894
///
/// `GenericProtoBound: FixedType;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenericProtoBoundFixedType {
    pub fixed_type: Box<FixedType>,
}

///
/// Type derived for production 903
///
/// `WithGenericArgumentItem: GenericArgIdentifier;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithGenericArgumentItemGenericArgIdentifier {
    pub generic_arg_identifier: Box<GenericArgIdentifier>,
}

///
/// Type derived for production 904
///
/// `WithGenericArgumentItem: FixedType;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithGenericArgumentItemFixedType {
    pub fixed_type: Box<FixedType>,
}

///
/// Type derived for production 905
///
/// `WithGenericArgumentItem: Number;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithGenericArgumentItemNumber {
    pub number: Box<Number>,
}

///
/// Type derived for production 906
///
/// `WithGenericArgumentItem: BooleanLiteral;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithGenericArgumentItemBooleanLiteral {
    pub boolean_literal: Box<BooleanLiteral>,
}

///
/// Type derived for production 916
///
/// `PortDeclarationGroupGroup: LBrace PortDeclarationList RBrace;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PortDeclarationGroupGroupLBracePortDeclarationListRBrace {
    pub l_brace: Box<LBrace>,
    pub port_declaration_list: Box<PortDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 917
///
/// `PortDeclarationGroupGroup: PortDeclarationItem;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PortDeclarationGroupGroupPortDeclarationItem {
    pub port_declaration_item: Box<PortDeclarationItem>,
}

///
/// Type derived for production 921
///
/// `PortDeclarationItemGroup: PortTypeConcrete;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PortDeclarationItemGroupPortTypeConcrete {
    pub port_type_concrete: Box<PortTypeConcrete>,
}

///
/// Type derived for production 922
///
/// `PortDeclarationItemGroup: PortTypeAbstract;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PortDeclarationItemGroupPortTypeAbstract {
    pub port_type_abstract: Box<PortTypeAbstract>,
}

///
/// Type derived for production 936
///
/// `Direction: Input;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DirectionInput {
    pub input: Box<Input>,
}

///
/// Type derived for production 937
///
/// `Direction: Output;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DirectionOutput {
    pub output: Box<Output>,
}

///
/// Type derived for production 938
///
/// `Direction: Inout;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DirectionInout {
    pub inout: Box<Inout>,
}

///
/// Type derived for production 939
///
/// `Direction: Modport;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DirectionModport {
    pub modport: Box<Modport>,
}

///
/// Type derived for production 940
///
/// `Direction: Import;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DirectionImport {
    pub import: Box<Import>,
}

///
/// Type derived for production 966
///
/// `ModuleGroupGroup: LBrace ModuleGroupGroupList /* Vec */ RBrace;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModuleGroupGroupLBraceModuleGroupGroupListRBrace {
    pub l_brace: Box<LBrace>,
    pub module_group_group_list: Vec<ModuleGroupGroupList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 969
///
/// `ModuleGroupGroup: ModuleItem;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModuleGroupGroupModuleItem {
    pub module_item: Box<ModuleItem>,
}

///
/// Type derived for production 983
///
/// `InterfaceGroupGroup: LBrace InterfaceGroupGroupList /* Vec */ RBrace;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InterfaceGroupGroupLBraceInterfaceGroupGroupListRBrace {
    pub l_brace: Box<LBrace>,
    pub interface_group_group_list: Vec<InterfaceGroupGroupList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 986
///
/// `InterfaceGroupGroup: InterfaceItem;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InterfaceGroupGroupInterfaceItem {
    pub interface_item: Box<InterfaceItem>,
}

///
/// Type derived for production 989
///
/// `InterfaceItem: GenerateItem;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InterfaceItemGenerateItem {
    pub generate_item: Box<GenerateItem>,
}

///
/// Type derived for production 990
///
/// `InterfaceItem: ModportDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InterfaceItemModportDeclaration {
    pub modport_declaration: Box<ModportDeclaration>,
}

///
/// Type derived for production 1011
///
/// `GenerateGroupGroup: LBrace GenerateGroupGroupList /* Vec */ RBrace;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateGroupGroupLBraceGenerateGroupGroupListRBrace {
    pub l_brace: Box<LBrace>,
    pub generate_group_group_list: Vec<GenerateGroupGroupList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 1014
///
/// `GenerateGroupGroup: GenerateItem;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateGroupGroupGenerateItem {
    pub generate_item: Box<GenerateItem>,
}

///
/// Type derived for production 1017
///
/// `GenerateItem: LetDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemLetDeclaration {
    pub let_declaration: Box<LetDeclaration>,
}

///
/// Type derived for production 1018
///
/// `GenerateItem: VarDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemVarDeclaration {
    pub var_declaration: Box<VarDeclaration>,
}

///
/// Type derived for production 1019
///
/// `GenerateItem: InstDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemInstDeclaration {
    pub inst_declaration: Box<InstDeclaration>,
}

///
/// Type derived for production 1020
///
/// `GenerateItem: BindDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemBindDeclaration {
    pub bind_declaration: Box<BindDeclaration>,
}

///
/// Type derived for production 1021
///
/// `GenerateItem: ConstDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemConstDeclaration {
    pub const_declaration: Box<ConstDeclaration>,
}

///
/// Type derived for production 1022
///
/// `GenerateItem: AlwaysFfDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemAlwaysFfDeclaration {
    pub always_ff_declaration: Box<AlwaysFfDeclaration>,
}

///
/// Type derived for production 1023
///
/// `GenerateItem: AlwaysCombDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemAlwaysCombDeclaration {
    pub always_comb_declaration: Box<AlwaysCombDeclaration>,
}

///
/// Type derived for production 1024
///
/// `GenerateItem: AssignDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemAssignDeclaration {
    pub assign_declaration: Box<AssignDeclaration>,
}

///
/// Type derived for production 1025
///
/// `GenerateItem: ConnectDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemConnectDeclaration {
    pub connect_declaration: Box<ConnectDeclaration>,
}

///
/// Type derived for production 1026
///
/// `GenerateItem: FunctionDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemFunctionDeclaration {
    pub function_declaration: Box<FunctionDeclaration>,
}

///
/// Type derived for production 1027
///
/// `GenerateItem: GenerateIfDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemGenerateIfDeclaration {
    pub generate_if_declaration: Box<GenerateIfDeclaration>,
}

///
/// Type derived for production 1028
///
/// `GenerateItem: GenerateForDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemGenerateForDeclaration {
    pub generate_for_declaration: Box<GenerateForDeclaration>,
}

///
/// Type derived for production 1029
///
/// `GenerateItem: GenerateBlockDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemGenerateBlockDeclaration {
    pub generate_block_declaration: Box<GenerateBlockDeclaration>,
}

///
/// Type derived for production 1030
///
/// `GenerateItem: TypeDefDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemTypeDefDeclaration {
    pub type_def_declaration: Box<TypeDefDeclaration>,
}

///
/// Type derived for production 1031
///
/// `GenerateItem: EnumDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemEnumDeclaration {
    pub enum_declaration: Box<EnumDeclaration>,
}

///
/// Type derived for production 1032
///
/// `GenerateItem: StructUnionDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemStructUnionDeclaration {
    pub struct_union_declaration: Box<StructUnionDeclaration>,
}

///
/// Type derived for production 1033
///
/// `GenerateItem: ImportDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemImportDeclaration {
    pub import_declaration: Box<ImportDeclaration>,
}

///
/// Type derived for production 1034
///
/// `GenerateItem: AliasDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemAliasDeclaration {
    pub alias_declaration: Box<AliasDeclaration>,
}

///
/// Type derived for production 1035
///
/// `GenerateItem: InitialDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemInitialDeclaration {
    pub initial_declaration: Box<InitialDeclaration>,
}

///
/// Type derived for production 1036
///
/// `GenerateItem: FinalDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemFinalDeclaration {
    pub final_declaration: Box<FinalDeclaration>,
}

///
/// Type derived for production 1037
///
/// `GenerateItem: UnsafeBlock;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemUnsafeBlock {
    pub unsafe_block: Box<UnsafeBlock>,
}

///
/// Type derived for production 1038
///
/// `GenerateItem: EmbedDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateItemEmbedDeclaration {
    pub embed_declaration: Box<EmbedDeclaration>,
}

///
/// Type derived for production 1047
///
/// `PackageGroupGroup: LBrace PackageGroupGroupList /* Vec */ RBrace;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PackageGroupGroupLBracePackageGroupGroupListRBrace {
    pub l_brace: Box<LBrace>,
    pub package_group_group_list: Vec<PackageGroupGroupList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 1050
///
/// `PackageGroupGroup: PackageItem;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PackageGroupGroupPackageItem {
    pub package_item: Box<PackageItem>,
}

///
/// Type derived for production 1053
///
/// `PackageItem: ConstDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PackageItemConstDeclaration {
    pub const_declaration: Box<ConstDeclaration>,
}

///
/// Type derived for production 1054
///
/// `PackageItem: TypeDefDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PackageItemTypeDefDeclaration {
    pub type_def_declaration: Box<TypeDefDeclaration>,
}

///
/// Type derived for production 1055
///
/// `PackageItem: EnumDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PackageItemEnumDeclaration {
    pub enum_declaration: Box<EnumDeclaration>,
}

///
/// Type derived for production 1056
///
/// `PackageItem: StructUnionDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PackageItemStructUnionDeclaration {
    pub struct_union_declaration: Box<StructUnionDeclaration>,
}

///
/// Type derived for production 1057
///
/// `PackageItem: FunctionDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PackageItemFunctionDeclaration {
    pub function_declaration: Box<FunctionDeclaration>,
}

///
/// Type derived for production 1058
///
/// `PackageItem: ImportDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PackageItemImportDeclaration {
    pub import_declaration: Box<ImportDeclaration>,
}

///
/// Type derived for production 1059
///
/// `PackageItem: AliasDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PackageItemAliasDeclaration {
    pub alias_declaration: Box<AliasDeclaration>,
}

///
/// Type derived for production 1060
///
/// `PackageItem: EmbedDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PackageItemEmbedDeclaration {
    pub embed_declaration: Box<EmbedDeclaration>,
}

///
/// Type derived for production 1062
///
/// `AliasDeclarationGroup: Module;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AliasDeclarationGroupModule {
    pub module: Box<Module>,
}

///
/// Type derived for production 1063
///
/// `AliasDeclarationGroup: Interface;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AliasDeclarationGroupInterface {
    pub interface: Box<Interface>,
}

///
/// Type derived for production 1064
///
/// `AliasDeclarationGroup: Package;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AliasDeclarationGroupPackage {
    pub package: Box<Package>,
}

///
/// Type derived for production 1066
///
/// `ProtoDeclarationGroup: ProtoModuleDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoDeclarationGroupProtoModuleDeclaration {
    pub proto_module_declaration: Box<ProtoModuleDeclaration>,
}

///
/// Type derived for production 1067
///
/// `ProtoDeclarationGroup: ProtoInterfaceDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoDeclarationGroupProtoInterfaceDeclaration {
    pub proto_interface_declaration: Box<ProtoInterfaceDeclaration>,
}

///
/// Type derived for production 1068
///
/// `ProtoDeclarationGroup: ProtoPackageDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoDeclarationGroupProtoPackageDeclaration {
    pub proto_package_declaration: Box<ProtoPackageDeclaration>,
}

///
/// Type derived for production 1079
///
/// `ProtoInterfaceItem: VarDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoInterfaceItemVarDeclaration {
    pub var_declaration: Box<VarDeclaration>,
}

///
/// Type derived for production 1080
///
/// `ProtoInterfaceItem: ProtoConstDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoInterfaceItemProtoConstDeclaration {
    pub proto_const_declaration: Box<ProtoConstDeclaration>,
}

///
/// Type derived for production 1081
///
/// `ProtoInterfaceItem: ProtoFunctionDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoInterfaceItemProtoFunctionDeclaration {
    pub proto_function_declaration: Box<ProtoFunctionDeclaration>,
}

///
/// Type derived for production 1082
///
/// `ProtoInterfaceItem: ProtoTypeDefDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoInterfaceItemProtoTypeDefDeclaration {
    pub proto_type_def_declaration: Box<ProtoTypeDefDeclaration>,
}

///
/// Type derived for production 1083
///
/// `ProtoInterfaceItem: ProtoAliasDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoInterfaceItemProtoAliasDeclaration {
    pub proto_alias_declaration: Box<ProtoAliasDeclaration>,
}

///
/// Type derived for production 1084
///
/// `ProtoInterfaceItem: ModportDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoInterfaceItemModportDeclaration {
    pub modport_declaration: Box<ModportDeclaration>,
}

///
/// Type derived for production 1085
///
/// `ProtoInterfaceItem: ImportDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoInterfaceItemImportDeclaration {
    pub import_declaration: Box<ImportDeclaration>,
}

///
/// Type derived for production 1089
///
/// `ProtoPacakgeItem: ProtoConstDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoPacakgeItemProtoConstDeclaration {
    pub proto_const_declaration: Box<ProtoConstDeclaration>,
}

///
/// Type derived for production 1090
///
/// `ProtoPacakgeItem: ProtoTypeDefDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoPacakgeItemProtoTypeDefDeclaration {
    pub proto_type_def_declaration: Box<ProtoTypeDefDeclaration>,
}

///
/// Type derived for production 1091
///
/// `ProtoPacakgeItem: EnumDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoPacakgeItemEnumDeclaration {
    pub enum_declaration: Box<EnumDeclaration>,
}

///
/// Type derived for production 1092
///
/// `ProtoPacakgeItem: StructUnionDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoPacakgeItemStructUnionDeclaration {
    pub struct_union_declaration: Box<StructUnionDeclaration>,
}

///
/// Type derived for production 1093
///
/// `ProtoPacakgeItem: ProtoFunctionDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoPacakgeItemProtoFunctionDeclaration {
    pub proto_function_declaration: Box<ProtoFunctionDeclaration>,
}

///
/// Type derived for production 1094
///
/// `ProtoPacakgeItem: ProtoAliasDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoPacakgeItemProtoAliasDeclaration {
    pub proto_alias_declaration: Box<ProtoAliasDeclaration>,
}

///
/// Type derived for production 1095
///
/// `ProtoPacakgeItem: ImportDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoPacakgeItemImportDeclaration {
    pub import_declaration: Box<ImportDeclaration>,
}

///
/// Type derived for production 1097
///
/// `ProtoConstDeclarationGroup: ArrayType;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoConstDeclarationGroupArrayType {
    pub array_type: Box<ArrayType>,
}

///
/// Type derived for production 1098
///
/// `ProtoConstDeclarationGroup: Type;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoConstDeclarationGroupType {
    pub r#type: Box<Type>,
}

///
/// Type derived for production 1110
///
/// `ProtoAliasDeclarationGroup: Module;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoAliasDeclarationGroupModule {
    pub module: Box<Module>,
}

///
/// Type derived for production 1111
///
/// `ProtoAliasDeclarationGroup: Interface;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoAliasDeclarationGroupInterface {
    pub interface: Box<Interface>,
}

///
/// Type derived for production 1112
///
/// `ProtoAliasDeclarationGroup: Package;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoAliasDeclarationGroupPackage {
    pub package: Box<Package>,
}

///
/// Type derived for production 1118
///
/// `EmbedItem: EmbedLBrace EmbedItemList /* Vec */ EmbedRBrace;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EmbedItemEmbedLBraceEmbedItemListEmbedRBrace {
    pub embed_l_brace: Box<EmbedLBrace>,
    pub embed_item_list: Vec<EmbedItemList>,
    pub embed_r_brace: Box<EmbedRBrace>,
}

///
/// Type derived for production 1121
///
/// `EmbedItem: EmbedScopedIdentifier;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EmbedItemEmbedScopedIdentifier {
    pub embed_scoped_identifier: Box<EmbedScopedIdentifier>,
}

///
/// Type derived for production 1122
///
/// `EmbedItem: Any;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EmbedItemAny {
    pub any: Box<Any>,
}

///
/// Type derived for production 1125
///
/// `DescriptionGroupGroup: LBrace DescriptionGroupGroupList /* Vec */ RBrace;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DescriptionGroupGroupLBraceDescriptionGroupGroupListRBrace {
    pub l_brace: Box<LBrace>,
    pub description_group_group_list: Vec<DescriptionGroupGroupList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for production 1128
///
/// `DescriptionGroupGroup: DescriptionItem;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DescriptionGroupGroupDescriptionItem {
    pub description_item: Box<DescriptionItem>,
}

///
/// Type derived for production 1131
///
/// `DescriptionItem: DescriptionItemOpt /* Option */ PublicDescriptionItem;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DescriptionItemDescriptionItemOptPublicDescriptionItem {
    pub description_item_opt: Option<DescriptionItemOpt>,
    pub public_description_item: Box<PublicDescriptionItem>,
}

///
/// Type derived for production 1132
///
/// `DescriptionItem: ImportDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DescriptionItemImportDeclaration {
    pub import_declaration: Box<ImportDeclaration>,
}

///
/// Type derived for production 1133
///
/// `DescriptionItem: BindDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DescriptionItemBindDeclaration {
    pub bind_declaration: Box<BindDeclaration>,
}

///
/// Type derived for production 1134
///
/// `DescriptionItem: EmbedDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DescriptionItemEmbedDeclaration {
    pub embed_declaration: Box<EmbedDeclaration>,
}

///
/// Type derived for production 1135
///
/// `DescriptionItem: IncludeDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DescriptionItemIncludeDeclaration {
    pub include_declaration: Box<IncludeDeclaration>,
}

///
/// Type derived for production 1138
///
/// `PublicDescriptionItem: ModuleDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PublicDescriptionItemModuleDeclaration {
    pub module_declaration: Box<ModuleDeclaration>,
}

///
/// Type derived for production 1139
///
/// `PublicDescriptionItem: InterfaceDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PublicDescriptionItemInterfaceDeclaration {
    pub interface_declaration: Box<InterfaceDeclaration>,
}

///
/// Type derived for production 1140
///
/// `PublicDescriptionItem: PackageDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PublicDescriptionItemPackageDeclaration {
    pub package_declaration: Box<PackageDeclaration>,
}

///
/// Type derived for production 1141
///
/// `PublicDescriptionItem: AliasDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PublicDescriptionItemAliasDeclaration {
    pub alias_declaration: Box<AliasDeclaration>,
}

///
/// Type derived for production 1142
///
/// `PublicDescriptionItem: ProtoDeclaration;`
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PublicDescriptionItemProtoDeclaration {
    pub proto_declaration: Box<ProtoDeclaration>,
}

// -------------------------------------------------------------------------------------------------
//
// Types of non-terminals deduced from the structure of the transformed grammar
//

///
/// Type derived for non-terminal Alias
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Alias {
    pub alias_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AliasDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AliasDeclaration {
    pub alias: Box<Alias>,
    pub alias_declaration_group: Box<AliasDeclarationGroup>,
    pub identifier: Box<Identifier>,
    pub equ: Box<Equ>,
    pub scoped_identifier: Box<ScopedIdentifier>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal AliasDeclarationGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AliasDeclarationGroup {
    Module(AliasDeclarationGroupModule),
    Interface(AliasDeclarationGroupInterface),
    Package(AliasDeclarationGroupPackage),
}

///
/// Type derived for non-terminal AliasTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AliasTerm {
    pub alias_term: crate::veryl_token::Token, /* alias */
}

///
/// Type derived for non-terminal AliasToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AliasToken {
    pub alias_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal AllBit
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AllBit {
    pub all_bit_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AllBitTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AllBitTerm {
    pub all_bit_term: crate::veryl_token::Token, /* (?:[0-9]+(?:_[0-9]+)*)?'[01xzXZ] */
}

///
/// Type derived for non-terminal AllBitToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AllBitToken {
    pub all_bit_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal AlwaysComb
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AlwaysComb {
    pub always_comb_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AlwaysCombDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AlwaysCombDeclaration {
    pub always_comb: Box<AlwaysComb>,
    pub statement_block: Box<StatementBlock>,
}

///
/// Type derived for non-terminal AlwaysCombTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AlwaysCombTerm {
    pub always_comb_term: crate::veryl_token::Token, /* always_comb */
}

///
/// Type derived for non-terminal AlwaysCombToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AlwaysCombToken {
    pub always_comb_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal AlwaysFf
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AlwaysFf {
    pub always_ff_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AlwaysFfClock
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AlwaysFfClock {
    pub hierarchical_identifier: Box<HierarchicalIdentifier>,
}

///
/// Type derived for non-terminal AlwaysFfDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AlwaysFfDeclaration {
    pub always_ff: Box<AlwaysFf>,
    pub always_ff_declaration_opt: Option<AlwaysFfDeclarationOpt>,
    pub statement_block: Box<StatementBlock>,
}

///
/// Type derived for non-terminal AlwaysFfDeclarationOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AlwaysFfDeclarationOpt {
    pub always_ff_event_list: Box<AlwaysFfEventList>,
}

///
/// Type derived for non-terminal AlwaysFfEventList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AlwaysFfEventList {
    pub l_paren: Box<LParen>,
    pub always_ff_clock: Box<AlwaysFfClock>,
    pub always_ff_event_list_opt: Option<AlwaysFfEventListOpt>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal AlwaysFfEventListOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AlwaysFfEventListOpt {
    pub comma: Box<Comma>,
    pub always_ff_reset: Box<AlwaysFfReset>,
}

///
/// Type derived for non-terminal AlwaysFfReset
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AlwaysFfReset {
    pub hierarchical_identifier: Box<HierarchicalIdentifier>,
}

///
/// Type derived for non-terminal AlwaysFfTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AlwaysFfTerm {
    pub always_ff_term: crate::veryl_token::Token, /* always_ff */
}

///
/// Type derived for non-terminal AlwaysFfToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AlwaysFfToken {
    pub always_ff_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Any
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Any {
    pub any_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AnyTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AnyTerm {
    pub any_term: crate::veryl_token::Token, /* (?:[^{}\\]|\\[^{])+ */
}

///
/// Type derived for non-terminal AnyToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AnyToken {
    pub any_term: crate::veryl_token::Token,
}

///
/// Type derived for non-terminal ArgumentExpression
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArgumentExpression {
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal ArgumentItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArgumentItem {
    pub argument_expression: Box<ArgumentExpression>,
    pub argument_item_opt: Option<ArgumentItemOpt>,
}

///
/// Type derived for non-terminal ArgumentItemOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArgumentItemOpt {
    pub colon: Box<Colon>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal ArgumentList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArgumentList {
    pub argument_item: Box<ArgumentItem>,
    pub argument_list_list: Vec<ArgumentListList>,
    pub argument_list_opt: Option<ArgumentListOpt>,
}

///
/// Type derived for non-terminal ArgumentListList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArgumentListList {
    pub comma: Box<Comma>,
    pub argument_item: Box<ArgumentItem>,
}

///
/// Type derived for non-terminal ArgumentListOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArgumentListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal Array
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Array {
    pub l_bracket: Box<LBracket>,
    pub expression: Box<Expression>,
    pub array_list: Vec<ArrayList>,
    pub r_bracket: Box<RBracket>,
}

///
/// Type derived for non-terminal ArrayList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayList {
    pub comma: Box<Comma>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal ArrayLiteralItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayLiteralItem {
    pub array_literal_item_group: Box<ArrayLiteralItemGroup>,
}

///
/// Type derived for non-terminal ArrayLiteralItemGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ArrayLiteralItemGroup {
    ExpressionArrayLiteralItemOpt(ArrayLiteralItemGroupExpressionArrayLiteralItemOpt),
    DefaulColonExpression(ArrayLiteralItemGroupDefaulColonExpression),
}

///
/// Type derived for non-terminal ArrayLiteralItemOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayLiteralItemOpt {
    pub repeat: Box<Repeat>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal ArrayLiteralList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayLiteralList {
    pub array_literal_item: Box<ArrayLiteralItem>,
    pub array_literal_list_list: Vec<ArrayLiteralListList>,
    pub array_literal_list_opt: Option<ArrayLiteralListOpt>,
}

///
/// Type derived for non-terminal ArrayLiteralListList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayLiteralListList {
    pub comma: Box<Comma>,
    pub array_literal_item: Box<ArrayLiteralItem>,
}

///
/// Type derived for non-terminal ArrayLiteralListOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayLiteralListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal ArrayType
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayType {
    pub scalar_type: Box<ScalarType>,
    pub array_type_opt: Option<ArrayTypeOpt>,
}

///
/// Type derived for non-terminal ArrayTypeOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ArrayTypeOpt {
    pub array: Box<Array>,
}

///
/// Type derived for non-terminal As
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct As {
    pub as_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AsTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AsTerm {
    pub as_term: crate::veryl_token::Token, /* as */
}

///
/// Type derived for non-terminal AsToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AsToken {
    pub as_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Assign
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Assign {
    pub assign_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AssignConcatenationItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AssignConcatenationItem {
    pub hierarchical_identifier: Box<HierarchicalIdentifier>,
}

///
/// Type derived for non-terminal AssignConcatenationList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AssignConcatenationList {
    pub assign_concatenation_item: Box<AssignConcatenationItem>,
    pub assign_concatenation_list_list: Vec<AssignConcatenationListList>,
    pub assign_concatenation_list_opt: Option<AssignConcatenationListOpt>,
}

///
/// Type derived for non-terminal AssignConcatenationListList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AssignConcatenationListList {
    pub comma: Box<Comma>,
    pub assign_concatenation_item: Box<AssignConcatenationItem>,
}

///
/// Type derived for non-terminal AssignConcatenationListOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AssignConcatenationListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal AssignDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AssignDeclaration {
    pub assign: Box<Assign>,
    pub assign_destination: Box<AssignDestination>,
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal AssignDestination
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AssignDestination {
    HierarchicalIdentifier(AssignDestinationHierarchicalIdentifier),
    LBraceAssignConcatenationListRBrace(AssignDestinationLBraceAssignConcatenationListRBrace),
}

///
/// Type derived for non-terminal AssignTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AssignTerm {
    pub assign_term: crate::veryl_token::Token, /* assign */
}

///
/// Type derived for non-terminal AssignToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AssignToken {
    pub assign_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Assignment
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Assignment {
    pub assignment_group: Box<AssignmentGroup>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal AssignmentGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AssignmentGroup {
    Equ(AssignmentGroupEqu),
    AssignmentOperator(AssignmentGroupAssignmentOperator),
    DiamondOperator(AssignmentGroupDiamondOperator),
}

///
/// Type derived for non-terminal AssignmentOperator
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AssignmentOperator {
    pub assignment_operator_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal AssignmentOperatorTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AssignmentOperatorTerm {
    pub assignment_operator_term: crate::veryl_token::Token, /* \+=|-=|\*=|/=|%=|&=|\|=|\^=|<<=|>>=|<<<=|>>>= */
}

///
/// Type derived for non-terminal AssignmentOperatorToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AssignmentOperatorToken {
    pub assignment_operator_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Attribute
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Attribute {
    pub hash_l_bracket: Box<HashLBracket>,
    pub identifier: Box<Identifier>,
    pub attribute_opt: Option<AttributeOpt>,
    pub r_bracket: Box<RBracket>,
}

///
/// Type derived for non-terminal AttributeItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum AttributeItem {
    Identifier(AttributeItemIdentifier),
    StringLiteral(AttributeItemStringLiteral),
}

///
/// Type derived for non-terminal AttributeList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AttributeList {
    pub attribute_item: Box<AttributeItem>,
    pub attribute_list_list: Vec<AttributeListList>,
    pub attribute_list_opt: Option<AttributeListOpt>,
}

///
/// Type derived for non-terminal AttributeListList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AttributeListList {
    pub comma: Box<Comma>,
    pub attribute_item: Box<AttributeItem>,
}

///
/// Type derived for non-terminal AttributeListOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AttributeListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal AttributeOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct AttributeOpt {
    pub l_paren: Box<LParen>,
    pub attribute_list: Box<AttributeList>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal BaseLess
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BaseLess {
    pub base_less_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BaseLessTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BaseLessTerm {
    pub base_less_term: crate::veryl_token::Token, /* [0-9]+(?:_[0-9]+)* */
}

///
/// Type derived for non-terminal BaseLessToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BaseLessToken {
    pub base_less_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Based
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Based {
    pub based_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BasedTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BasedTerm {
    pub based_term: crate::veryl_token::Token, /* (?:[0-9]+(?:_[0-9]+)*)?'s?[bodh][0-9a-fA-FxzXZ]+(?:_[0-9a-fA-FxzXZ]+)* */
}

///
/// Type derived for non-terminal BasedToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BasedToken {
    pub based_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Bind
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Bind {
    pub bind_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BindDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BindDeclaration {
    pub bind: Box<Bind>,
    pub scoped_identifier: Box<ScopedIdentifier>,
    pub l_t_minus: Box<LTMinus>,
    pub component_instantiation: Box<ComponentInstantiation>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal BindTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BindTerm {
    pub bind_term: crate::veryl_token::Token, /* bind */
}

///
/// Type derived for non-terminal BindToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BindToken {
    pub bind_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Bit
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Bit {
    pub bit_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BitTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BitTerm {
    pub bit_term: crate::veryl_token::Token, /* bit */
}

///
/// Type derived for non-terminal BitToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BitToken {
    pub bit_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Bool
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Bool {
    pub bool_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BoolTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BoolTerm {
    pub bool_term: crate::veryl_token::Token, /* bool */
}

///
/// Type derived for non-terminal BoolToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BoolToken {
    pub bool_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal BooleanLiteral
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum BooleanLiteral {
    True(BooleanLiteralTrue),
    False(BooleanLiteralFalse),
}

///
/// Type derived for non-terminal Break
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Break {
    pub break_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal BreakStatement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BreakStatement {
    pub r#break: Box<Break>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal BreakTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BreakTerm {
    pub break_term: crate::veryl_token::Token, /* break */
}

///
/// Type derived for non-terminal BreakToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct BreakToken {
    pub break_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Case
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Case {
    pub case_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal CaseCondition
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CaseCondition {
    pub range_item: Box<RangeItem>,
    pub case_condition_list: Vec<CaseConditionList>,
}

///
/// Type derived for non-terminal CaseConditionList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CaseConditionList {
    pub comma: Box<Comma>,
    pub range_item: Box<RangeItem>,
}

///
/// Type derived for non-terminal CaseExpression
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CaseExpression {
    pub case: Box<Case>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub case_condition: Box<CaseCondition>,
    pub colon: Box<Colon>,
    pub expression0: Box<Expression>,
    pub comma: Box<Comma>,
    pub case_expression_list: Vec<CaseExpressionList>,
    pub defaul: Box<Defaul>,
    pub colon0: Box<Colon>,
    pub expression1: Box<Expression>,
    pub case_expression_opt: Option<CaseExpressionOpt>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal CaseExpressionList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CaseExpressionList {
    pub case_condition: Box<CaseCondition>,
    pub colon: Box<Colon>,
    pub expression: Box<Expression>,
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal CaseExpressionOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CaseExpressionOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal CaseItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CaseItem {
    pub case_item_group: Box<CaseItemGroup>,
    pub colon: Box<Colon>,
    pub case_item_group0: Box<CaseItemGroup0>,
}

///
/// Type derived for non-terminal CaseItemGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum CaseItemGroup {
    CaseCondition(CaseItemGroupCaseCondition),
    Defaul(CaseItemGroupDefaul),
}

///
/// Type derived for non-terminal CaseItemGroup0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum CaseItemGroup0 {
    Statement(CaseItemGroup0Statement),
    StatementBlock(CaseItemGroup0StatementBlock),
}

///
/// Type derived for non-terminal CaseStatement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CaseStatement {
    pub case: Box<Case>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub case_statement_list: Vec<CaseStatementList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal CaseStatementList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CaseStatementList {
    pub case_item: Box<CaseItem>,
}

///
/// Type derived for non-terminal CaseTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CaseTerm {
    pub case_term: crate::veryl_token::Token, /* case */
}

///
/// Type derived for non-terminal CaseToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CaseToken {
    pub case_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal CastingType
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum CastingType {
    U8(CastingTypeU8),
    U16(CastingTypeU16),
    U32(CastingTypeU32),
    U64(CastingTypeU64),
    I8(CastingTypeI8),
    I16(CastingTypeI16),
    I32(CastingTypeI32),
    I64(CastingTypeI64),
    F32(CastingTypeF32),
    F64(CastingTypeF64),
    Bool(CastingTypeBool),
    Clock(CastingTypeClock),
    ClockPosedge(CastingTypeClockPosedge),
    ClockNegedge(CastingTypeClockNegedge),
    Reset(CastingTypeReset),
    ResetAsyncHigh(CastingTypeResetAsyncHigh),
    ResetAsyncLow(CastingTypeResetAsyncLow),
    ResetSyncHigh(CastingTypeResetSyncHigh),
    ResetSyncLow(CastingTypeResetSyncLow),
    UserDefinedType(CastingTypeUserDefinedType),
    Based(CastingTypeBased),
    BaseLess(CastingTypeBaseLess),
}

///
/// Type derived for non-terminal Clock
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Clock {
    pub clock_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ClockDomain
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ClockDomain {
    pub quote: Box<Quote>,
    pub identifier: Box<Identifier>,
}

///
/// Type derived for non-terminal ClockNegedge
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ClockNegedge {
    pub clock_negedge_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ClockNegedgeTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ClockNegedgeTerm {
    pub clock_negedge_term: crate::veryl_token::Token, /* clock_negedge */
}

///
/// Type derived for non-terminal ClockNegedgeToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ClockNegedgeToken {
    pub clock_negedge_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal ClockPosedge
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ClockPosedge {
    pub clock_posedge_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ClockPosedgeTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ClockPosedgeTerm {
    pub clock_posedge_term: crate::veryl_token::Token, /* clock_posedge */
}

///
/// Type derived for non-terminal ClockPosedgeToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ClockPosedgeToken {
    pub clock_posedge_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal ClockTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ClockTerm {
    pub clock_term: crate::veryl_token::Token, /* clock */
}

///
/// Type derived for non-terminal ClockToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ClockToken {
    pub clock_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Colon
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Colon {
    pub colon_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ColonColon
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ColonColon {
    pub colon_colon_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ColonColonLAngle
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ColonColonLAngle {
    pub colon_colon_l_angle_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ColonColonLAngleTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ColonColonLAngleTerm {
    pub colon_colon_l_angle_term: crate::veryl_token::Token, /* ::< */
}

///
/// Type derived for non-terminal ColonColonLAngleToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ColonColonLAngleToken {
    pub colon_colon_l_angle_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal ColonColonTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ColonColonTerm {
    pub colon_colon_term: crate::veryl_token::Token, /* :: */
}

///
/// Type derived for non-terminal ColonColonToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ColonColonToken {
    pub colon_colon_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal ColonTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ColonTerm {
    pub colon_term: crate::veryl_token::Token, /* : */
}

///
/// Type derived for non-terminal ColonToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ColonToken {
    pub colon_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Comma
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Comma {
    pub comma_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal CommaTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CommaTerm {
    pub comma_term: crate::veryl_token::Token, /* , */
}

///
/// Type derived for non-terminal CommaToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CommaToken {
    pub comma_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Comments
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Comments {
    pub comments_opt: Option<CommentsOpt>,
}

///
/// Type derived for non-terminal CommentsOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CommentsOpt {
    pub comments_term: Box<CommentsTerm>,
}

///
/// Type derived for non-terminal CommentsTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct CommentsTerm {
    pub comments_term: crate::veryl_token::Token, /* (?:(?:(?://.*(?:\r\n|\r|\n)?)|(?:(?ms)/\*\/?([^/]|[^*]/)*\*\/))\s*)+ */
}

///
/// Type derived for non-terminal ComponentInstantiation
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ComponentInstantiation {
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub component_instantiation_opt: Option<ComponentInstantiationOpt>,
    pub scoped_identifier: Box<ScopedIdentifier>,
    pub component_instantiation_opt0: Option<ComponentInstantiationOpt0>,
    pub component_instantiation_opt1: Option<ComponentInstantiationOpt1>,
    pub component_instantiation_opt2: Option<ComponentInstantiationOpt2>,
}

///
/// Type derived for non-terminal ComponentInstantiationOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ComponentInstantiationOpt {
    pub clock_domain: Box<ClockDomain>,
}

///
/// Type derived for non-terminal ComponentInstantiationOpt0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ComponentInstantiationOpt0 {
    pub array: Box<Array>,
}

///
/// Type derived for non-terminal ComponentInstantiationOpt1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ComponentInstantiationOpt1 {
    pub inst_parameter: Box<InstParameter>,
}

///
/// Type derived for non-terminal ComponentInstantiationOpt2
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ComponentInstantiationOpt2 {
    pub inst_port: Box<InstPort>,
}

///
/// Type derived for non-terminal ConcatenationItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConcatenationItem {
    pub expression: Box<Expression>,
    pub concatenation_item_opt: Option<ConcatenationItemOpt>,
}

///
/// Type derived for non-terminal ConcatenationItemOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConcatenationItemOpt {
    pub repeat: Box<Repeat>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal ConcatenationList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConcatenationList {
    pub concatenation_item: Box<ConcatenationItem>,
    pub concatenation_list_list: Vec<ConcatenationListList>,
    pub concatenation_list_opt: Option<ConcatenationListOpt>,
}

///
/// Type derived for non-terminal ConcatenationListList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConcatenationListList {
    pub comma: Box<Comma>,
    pub concatenation_item: Box<ConcatenationItem>,
}

///
/// Type derived for non-terminal ConcatenationListOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConcatenationListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal Connect
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Connect {
    pub connect_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ConnectDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConnectDeclaration {
    pub connect: Box<Connect>,
    pub hierarchical_identifier: Box<HierarchicalIdentifier>,
    pub diamond_operator: Box<DiamondOperator>,
    pub expression: Box<Expression>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal ConnectTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConnectTerm {
    pub connect_term: crate::veryl_token::Token, /* connect */
}

///
/// Type derived for non-terminal ConnectToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConnectToken {
    pub connect_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Const
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Const {
    pub const_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ConstDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConstDeclaration {
    pub r#const: Box<Const>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub const_declaration_group: Box<ConstDeclarationGroup>,
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal ConstDeclarationGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ConstDeclarationGroup {
    ArrayType(ConstDeclarationGroupArrayType),
    Type(ConstDeclarationGroupType),
}

///
/// Type derived for non-terminal ConstTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConstTerm {
    pub const_term: crate::veryl_token::Token, /* const */
}

///
/// Type derived for non-terminal ConstToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConstToken {
    pub const_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Converse
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Converse {
    pub converse_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ConverseTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConverseTerm {
    pub converse_term: crate::veryl_token::Token, /* converse */
}

///
/// Type derived for non-terminal ConverseToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ConverseToken {
    pub converse_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Defaul
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Defaul {
    pub default_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal DefaultTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DefaultTerm {
    pub default_term: crate::veryl_token::Token, /* default */
}

///
/// Type derived for non-terminal DefaultToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DefaultToken {
    pub default_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal DescriptionGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DescriptionGroup {
    pub description_group_list: Vec<DescriptionGroupList>,
    pub description_group_group: Box<DescriptionGroupGroup>,
}

///
/// Type derived for non-terminal DescriptionGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DescriptionGroupGroup {
    LBraceDescriptionGroupGroupListRBrace(
        DescriptionGroupGroupLBraceDescriptionGroupGroupListRBrace,
    ),
    DescriptionItem(DescriptionGroupGroupDescriptionItem),
}

///
/// Type derived for non-terminal DescriptionGroupGroupList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DescriptionGroupGroupList {
    pub description_group: Box<DescriptionGroup>,
}

///
/// Type derived for non-terminal DescriptionGroupList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DescriptionGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal DescriptionItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum DescriptionItem {
    DescriptionItemOptPublicDescriptionItem(DescriptionItemDescriptionItemOptPublicDescriptionItem),
    ImportDeclaration(DescriptionItemImportDeclaration),
    BindDeclaration(DescriptionItemBindDeclaration),
    EmbedDeclaration(DescriptionItemEmbedDeclaration),
    IncludeDeclaration(DescriptionItemIncludeDeclaration),
}

///
/// Type derived for non-terminal DescriptionItemOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DescriptionItemOpt {
    pub r#pub: Box<Pub>,
}

///
/// Type derived for non-terminal DiamondOperator
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DiamondOperator {
    pub diamond_operator_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal DiamondOperatorTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DiamondOperatorTerm {
    pub diamond_operator_term: crate::veryl_token::Token, /* <> */
}

///
/// Type derived for non-terminal DiamondOperatorToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DiamondOperatorToken {
    pub diamond_operator_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Direction
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Direction {
    Input(DirectionInput),
    Output(DirectionOutput),
    Inout(DirectionInout),
    Modport(DirectionModport),
    Import(DirectionImport),
}

///
/// Type derived for non-terminal DollarIdentifier
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DollarIdentifier {
    pub dollar_identifier_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal DollarIdentifierTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DollarIdentifierTerm {
    pub dollar_identifier_term: crate::veryl_token::Token, /* \$[a-zA-Z_][0-9a-zA-Z_$]* */
}

///
/// Type derived for non-terminal DollarIdentifierToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DollarIdentifierToken {
    pub dollar_identifier_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Dot
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Dot {
    pub dot_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal DotDot
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DotDot {
    pub dot_dot_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal DotDotEqu
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DotDotEqu {
    pub dot_dot_equ_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal DotDotEquTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DotDotEquTerm {
    pub dot_dot_equ_term: crate::veryl_token::Token, /* ..= */
}

///
/// Type derived for non-terminal DotDotEquToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DotDotEquToken {
    pub dot_dot_equ_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal DotDotTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DotDotTerm {
    pub dot_dot_term: crate::veryl_token::Token, /* .. */
}

///
/// Type derived for non-terminal DotDotToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DotDotToken {
    pub dot_dot_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal DotTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DotTerm {
    pub dot_term: crate::veryl_token::Token, /* . */
}

///
/// Type derived for non-terminal DotToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct DotToken {
    pub dot_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Else
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Else {
    pub else_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ElseTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ElseTerm {
    pub else_term: crate::veryl_token::Token, /* else */
}

///
/// Type derived for non-terminal ElseToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ElseToken {
    pub else_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Embed
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Embed {
    pub embed_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal EmbedContent
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EmbedContent {
    pub triple_l_brace: Box<TripleLBrace>,
    pub embed_content_list: Vec<EmbedContentList>,
    pub triple_r_brace: Box<TripleRBrace>,
}

///
/// Type derived for non-terminal EmbedContentList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EmbedContentList {
    pub embed_item: Box<EmbedItem>,
}

///
/// Type derived for non-terminal EmbedDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EmbedDeclaration {
    pub embed: Box<Embed>,
    pub l_paren: Box<LParen>,
    pub identifier: Box<Identifier>,
    pub r_paren: Box<RParen>,
    pub identifier0: Box<Identifier>,
    pub embed_content: Box<EmbedContent>,
}

///
/// Type derived for non-terminal EmbedItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum EmbedItem {
    EmbedLBraceEmbedItemListEmbedRBrace(EmbedItemEmbedLBraceEmbedItemListEmbedRBrace),
    EmbedScopedIdentifier(EmbedItemEmbedScopedIdentifier),
    Any(EmbedItemAny),
}

///
/// Type derived for non-terminal EmbedItemList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EmbedItemList {
    pub embed_item: Box<EmbedItem>,
}

///
/// Type derived for non-terminal EmbedLBrace
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EmbedLBrace {
    pub embed_l_brace_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal EmbedLBraceToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EmbedLBraceToken {
    pub l_brace_term: crate::veryl_token::Token,
}

///
/// Type derived for non-terminal EmbedRBrace
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EmbedRBrace {
    pub embed_r_brace_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal EmbedRBraceToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EmbedRBraceToken {
    pub r_brace_term: crate::veryl_token::Token,
}

///
/// Type derived for non-terminal EmbedScopedIdentifier
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EmbedScopedIdentifier {
    pub escaped_l_brace: Box<EscapedLBrace>,
    pub scoped_identifier: Box<ScopedIdentifier>,
    pub escaped_r_brace: Box<EscapedRBrace>,
}

///
/// Type derived for non-terminal EmbedTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EmbedTerm {
    pub embed_term: crate::veryl_token::Token, /* embed */
}

///
/// Type derived for non-terminal EmbedToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EmbedToken {
    pub embed_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Enum
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Enum {
    pub enum_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal EnumDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EnumDeclaration {
    pub r#enum: Box<Enum>,
    pub identifier: Box<Identifier>,
    pub enum_declaration_opt: Option<EnumDeclarationOpt>,
    pub l_brace: Box<LBrace>,
    pub enum_list: Box<EnumList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal EnumDeclarationOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EnumDeclarationOpt {
    pub colon: Box<Colon>,
    pub scalar_type: Box<ScalarType>,
}

///
/// Type derived for non-terminal EnumGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EnumGroup {
    pub enum_group_list: Vec<EnumGroupList>,
    pub enum_group_group: Box<EnumGroupGroup>,
}

///
/// Type derived for non-terminal EnumGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum EnumGroupGroup {
    LBraceEnumListRBrace(EnumGroupGroupLBraceEnumListRBrace),
    EnumItem(EnumGroupGroupEnumItem),
}

///
/// Type derived for non-terminal EnumGroupList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EnumGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal EnumItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EnumItem {
    pub identifier: Box<Identifier>,
    pub enum_item_opt: Option<EnumItemOpt>,
}

///
/// Type derived for non-terminal EnumItemOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EnumItemOpt {
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal EnumList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EnumList {
    pub enum_group: Box<EnumGroup>,
    pub enum_list_list: Vec<EnumListList>,
    pub enum_list_opt: Option<EnumListOpt>,
}

///
/// Type derived for non-terminal EnumListList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EnumListList {
    pub comma: Box<Comma>,
    pub enum_group: Box<EnumGroup>,
}

///
/// Type derived for non-terminal EnumListOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EnumListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal EnumTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EnumTerm {
    pub enum_term: crate::veryl_token::Token, /* enum */
}

///
/// Type derived for non-terminal EnumToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EnumToken {
    pub enum_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Equ
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Equ {
    pub equ_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal EquTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EquTerm {
    pub equ_term: crate::veryl_token::Token, /* = */
}

///
/// Type derived for non-terminal EquToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EquToken {
    pub equ_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal EscapedLBrace
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EscapedLBrace {
    pub escaped_l_brace_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal EscapedLBraceTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EscapedLBraceTerm {
    pub escaped_l_brace_term: crate::veryl_token::Token, /* \{ */
}

///
/// Type derived for non-terminal EscapedLBraceToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EscapedLBraceToken {
    pub escaped_l_brace_term: crate::veryl_token::Token,
}

///
/// Type derived for non-terminal EscapedRBrace
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EscapedRBrace {
    pub escaped_r_brace_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal EscapedRBraceTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EscapedRBraceTerm {
    pub escaped_r_brace_term: crate::veryl_token::Token, /* \} */
}

///
/// Type derived for non-terminal EscapedRBraceToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct EscapedRBraceToken {
    pub escaped_r_brace_term: crate::veryl_token::Token,
}

///
/// Type derived for non-terminal Exponent
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Exponent {
    pub exponent_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ExponentTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ExponentTerm {
    pub exponent_term: crate::veryl_token::Token, /* [0-9]+(?:_[0-9]+)*\.[0-9]+(?:_[0-9]+)*[eE][+-]?[0-9]+(?:_[0-9]+)* */
}

///
/// Type derived for non-terminal ExponentToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ExponentToken {
    pub exponent_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Expression
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression {
    pub if_expression: Box<IfExpression>,
}

///
/// Type derived for non-terminal Expression01
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression01 {
    pub expression02: Box<Expression02>,
    pub expression01_list: Vec<Expression01List>,
}

///
/// Type derived for non-terminal Expression01List
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression01List {
    pub operator02: Box<Operator02>,
    pub expression02: Box<Expression02>,
}

///
/// Type derived for non-terminal Expression02
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression02 {
    pub expression03: Box<Expression03>,
    pub expression02_list: Vec<Expression02List>,
}

///
/// Type derived for non-terminal Expression02List
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression02List {
    pub operator03: Box<Operator03>,
    pub expression03: Box<Expression03>,
}

///
/// Type derived for non-terminal Expression03
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression03 {
    pub expression04: Box<Expression04>,
    pub expression03_list: Vec<Expression03List>,
}

///
/// Type derived for non-terminal Expression03List
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression03List {
    pub operator04: Box<Operator04>,
    pub expression04: Box<Expression04>,
}

///
/// Type derived for non-terminal Expression04
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression04 {
    pub expression05: Box<Expression05>,
    pub expression04_list: Vec<Expression04List>,
}

///
/// Type derived for non-terminal Expression04List
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression04List {
    pub operator05: Box<Operator05>,
    pub expression05: Box<Expression05>,
}

///
/// Type derived for non-terminal Expression05
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression05 {
    pub expression06: Box<Expression06>,
    pub expression05_list: Vec<Expression05List>,
}

///
/// Type derived for non-terminal Expression05List
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression05List {
    pub operator06: Box<Operator06>,
    pub expression06: Box<Expression06>,
}

///
/// Type derived for non-terminal Expression06
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression06 {
    pub expression07: Box<Expression07>,
    pub expression06_list: Vec<Expression06List>,
}

///
/// Type derived for non-terminal Expression06List
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression06List {
    pub operator07: Box<Operator07>,
    pub expression07: Box<Expression07>,
}

///
/// Type derived for non-terminal Expression07
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression07 {
    pub expression08: Box<Expression08>,
    pub expression07_list: Vec<Expression07List>,
}

///
/// Type derived for non-terminal Expression07List
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression07List {
    pub operator08: Box<Operator08>,
    pub expression08: Box<Expression08>,
}

///
/// Type derived for non-terminal Expression08
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression08 {
    pub expression09: Box<Expression09>,
    pub expression08_list: Vec<Expression08List>,
}

///
/// Type derived for non-terminal Expression08List
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression08List {
    pub operator09: Box<Operator09>,
    pub expression09: Box<Expression09>,
}

///
/// Type derived for non-terminal Expression09
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression09 {
    pub expression10: Box<Expression10>,
    pub expression09_list: Vec<Expression09List>,
}

///
/// Type derived for non-terminal Expression09List
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression09List {
    pub operator10: Box<Operator10>,
    pub expression10: Box<Expression10>,
}

///
/// Type derived for non-terminal Expression10
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression10 {
    pub expression11: Box<Expression11>,
    pub expression10_list: Vec<Expression10List>,
}

///
/// Type derived for non-terminal Expression10List
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression10List {
    pub expression10_list_group: Box<Expression10ListGroup>,
    pub expression11: Box<Expression11>,
}

///
/// Type derived for non-terminal Expression10ListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Expression10ListGroup {
    Operator11(Expression10ListGroupOperator11),
    Star(Expression10ListGroupStar),
}

///
/// Type derived for non-terminal Expression11
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression11 {
    pub expression12: Box<Expression12>,
    pub expression11_list: Vec<Expression11List>,
}

///
/// Type derived for non-terminal Expression11List
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression11List {
    pub operator12: Box<Operator12>,
    pub expression12: Box<Expression12>,
}

///
/// Type derived for non-terminal Expression12
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression12 {
    pub expression13: Box<Expression13>,
    pub expression12_opt: Option<Expression12Opt>,
}

///
/// Type derived for non-terminal Expression12Opt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression12Opt {
    pub r#as: Box<As>,
    pub casting_type: Box<CastingType>,
}

///
/// Type derived for non-terminal Expression13
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression13 {
    pub expression13_list: Vec<Expression13List>,
    pub factor: Box<Factor>,
}

///
/// Type derived for non-terminal Expression13List
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Expression13List {
    pub expression13_list_group: Box<Expression13ListGroup>,
}

///
/// Type derived for non-terminal Expression13ListGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Expression13ListGroup {
    UnaryOperator(Expression13ListGroupUnaryOperator),
    Operator10(Expression13ListGroupOperator10),
    Operator06(Expression13ListGroupOperator06),
    Operator04(Expression13ListGroupOperator04),
    Operator05(Expression13ListGroupOperator05),
}

///
/// Type derived for non-terminal ExpressionIdentifier
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ExpressionIdentifier {
    pub scoped_identifier: Box<ScopedIdentifier>,
    pub expression_identifier_opt: Option<ExpressionIdentifierOpt>,
    pub expression_identifier_list: Vec<ExpressionIdentifierList>,
    pub expression_identifier_list0: Vec<ExpressionIdentifierList0>,
}

///
/// Type derived for non-terminal ExpressionIdentifierList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ExpressionIdentifierList {
    pub select: Box<Select>,
}

///
/// Type derived for non-terminal ExpressionIdentifierList0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ExpressionIdentifierList0 {
    pub dot: Box<Dot>,
    pub identifier: Box<Identifier>,
    pub expression_identifier_list0_list: Vec<ExpressionIdentifierList0List>,
}

///
/// Type derived for non-terminal ExpressionIdentifierList0List
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ExpressionIdentifierList0List {
    pub select: Box<Select>,
}

///
/// Type derived for non-terminal ExpressionIdentifierOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ExpressionIdentifierOpt {
    pub width: Box<Width>,
}

///
/// Type derived for non-terminal F32
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct F32 {
    pub f32_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal F32Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct F32Term {
    pub f32_term: crate::veryl_token::Token, /* f32 */
}

///
/// Type derived for non-terminal F32Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct F32Token {
    pub f32_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal F64
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct F64 {
    pub f64_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal F64Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct F64Term {
    pub f64_term: crate::veryl_token::Token, /* f64 */
}

///
/// Type derived for non-terminal F64Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct F64Token {
    pub f64_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Factor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Factor {
    Number(FactorNumber),
    BooleanLiteral(FactorBooleanLiteral),
    IdentifierFactor(FactorIdentifierFactor),
    LParenExpressionRParen(FactorLParenExpressionRParen),
    LBraceConcatenationListRBrace(FactorLBraceConcatenationListRBrace),
    QuoteLBraceArrayLiteralListRBrace(FactorQuoteLBraceArrayLiteralListRBrace),
    CaseExpression(FactorCaseExpression),
    SwitchExpression(FactorSwitchExpression),
    StringLiteral(FactorStringLiteral),
    FactorGroup(FactorFactorGroup),
    InsideExpression(FactorInsideExpression),
    OutsideExpression(FactorOutsideExpression),
    TypeExpression(FactorTypeExpression),
    FactorTypeFactor(FactorFactorTypeFactor),
}

///
/// Type derived for non-terminal FactorGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum FactorGroup {
    Msb(FactorGroupMsb),
    Lsb(FactorGroupLsb),
}

///
/// Type derived for non-terminal FactorType
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorType {
    pub factor_type_group: Box<FactorTypeGroup>,
}

///
/// Type derived for non-terminal FactorTypeFactor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorTypeFactor {
    pub factor_type_factor_list: Vec<FactorTypeFactorList>,
    pub factor_type: Box<FactorType>,
}

///
/// Type derived for non-terminal FactorTypeFactorList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorTypeFactorList {
    pub type_modifier: Box<TypeModifier>,
}

///
/// Type derived for non-terminal FactorTypeGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum FactorTypeGroup {
    VariableTypeFactorTypeOpt(FactorTypeGroupVariableTypeFactorTypeOpt),
    FixedType(FactorTypeGroupFixedType),
}

///
/// Type derived for non-terminal FactorTypeOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FactorTypeOpt {
    pub width: Box<Width>,
}

///
/// Type derived for non-terminal False
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct False {
    pub false_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal FalseTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FalseTerm {
    pub false_term: crate::veryl_token::Token, /* false */
}

///
/// Type derived for non-terminal FalseToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FalseToken {
    pub false_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Final
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Final {
    pub final_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal FinalDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FinalDeclaration {
    pub r#final: Box<Final>,
    pub statement_block: Box<StatementBlock>,
}

///
/// Type derived for non-terminal FinalTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FinalTerm {
    pub final_term: crate::veryl_token::Token, /* final */
}

///
/// Type derived for non-terminal FinalToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FinalToken {
    pub final_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal FixedPoint
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FixedPoint {
    pub fixed_point_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal FixedPointTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FixedPointTerm {
    pub fixed_point_term: crate::veryl_token::Token, /* [0-9]+(?:_[0-9]+)*\.[0-9]+(?:_[0-9]+)* */
}

///
/// Type derived for non-terminal FixedPointToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FixedPointToken {
    pub fixed_point_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal FixedType
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum FixedType {
    U8(FixedTypeU8),
    U16(FixedTypeU16),
    U32(FixedTypeU32),
    U64(FixedTypeU64),
    I8(FixedTypeI8),
    I16(FixedTypeI16),
    I32(FixedTypeI32),
    I64(FixedTypeI64),
    F32(FixedTypeF32),
    F64(FixedTypeF64),
    Bool(FixedTypeBool),
    Strin(FixedTypeStrin),
}

///
/// Type derived for non-terminal For
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct For {
    pub for_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ForStatement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ForStatement {
    pub r#for: Box<For>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub scalar_type: Box<ScalarType>,
    pub r#in: Box<In>,
    pub for_statement_opt: Option<ForStatementOpt>,
    pub range: Box<Range>,
    pub for_statement_opt0: Option<ForStatementOpt0>,
    pub statement_block: Box<StatementBlock>,
}

///
/// Type derived for non-terminal ForStatementOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ForStatementOpt {
    pub rev: Box<Rev>,
}

///
/// Type derived for non-terminal ForStatementOpt0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ForStatementOpt0 {
    pub step: Box<Step>,
    pub assignment_operator: Box<AssignmentOperator>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal ForTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ForTerm {
    pub for_term: crate::veryl_token::Token, /* for */
}

///
/// Type derived for non-terminal ForToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ForToken {
    pub for_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Function
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Function {
    pub function_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal FunctionCall
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FunctionCall {
    pub l_paren: Box<LParen>,
    pub function_call_opt: Option<FunctionCallOpt>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal FunctionCallOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FunctionCallOpt {
    pub argument_list: Box<ArgumentList>,
}

///
/// Type derived for non-terminal FunctionDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FunctionDeclaration {
    pub function: Box<Function>,
    pub identifier: Box<Identifier>,
    pub function_declaration_opt: Option<FunctionDeclarationOpt>,
    pub function_declaration_opt0: Option<FunctionDeclarationOpt0>,
    pub function_declaration_opt1: Option<FunctionDeclarationOpt1>,
    pub statement_block: Box<StatementBlock>,
}

///
/// Type derived for non-terminal FunctionDeclarationOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FunctionDeclarationOpt {
    pub with_generic_parameter: Box<WithGenericParameter>,
}

///
/// Type derived for non-terminal FunctionDeclarationOpt0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FunctionDeclarationOpt0 {
    pub port_declaration: Box<PortDeclaration>,
}

///
/// Type derived for non-terminal FunctionDeclarationOpt1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FunctionDeclarationOpt1 {
    pub minus_g_t: Box<MinusGT>,
    pub scalar_type: Box<ScalarType>,
}

///
/// Type derived for non-terminal FunctionTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FunctionTerm {
    pub function_term: crate::veryl_token::Token, /* function */
}

///
/// Type derived for non-terminal FunctionToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct FunctionToken {
    pub function_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal GenerateBlockDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateBlockDeclaration {
    pub generate_named_block: Box<GenerateNamedBlock>,
}

///
/// Type derived for non-terminal GenerateForDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateForDeclaration {
    pub r#for: Box<For>,
    pub identifier: Box<Identifier>,
    pub r#in: Box<In>,
    pub generate_for_declaration_opt: Option<GenerateForDeclarationOpt>,
    pub range: Box<Range>,
    pub generate_for_declaration_opt0: Option<GenerateForDeclarationOpt0>,
    pub generate_named_block: Box<GenerateNamedBlock>,
}

///
/// Type derived for non-terminal GenerateForDeclarationOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateForDeclarationOpt {
    pub rev: Box<Rev>,
}

///
/// Type derived for non-terminal GenerateForDeclarationOpt0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateForDeclarationOpt0 {
    pub step: Box<Step>,
    pub assignment_operator: Box<AssignmentOperator>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal GenerateGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateGroup {
    pub generate_group_list: Vec<GenerateGroupList>,
    pub generate_group_group: Box<GenerateGroupGroup>,
}

///
/// Type derived for non-terminal GenerateGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum GenerateGroupGroup {
    LBraceGenerateGroupGroupListRBrace(GenerateGroupGroupLBraceGenerateGroupGroupListRBrace),
    GenerateItem(GenerateGroupGroupGenerateItem),
}

///
/// Type derived for non-terminal GenerateGroupGroupList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateGroupGroupList {
    pub generate_group: Box<GenerateGroup>,
}

///
/// Type derived for non-terminal GenerateGroupList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal GenerateIfDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateIfDeclaration {
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub generate_named_block: Box<GenerateNamedBlock>,
    pub generate_if_declaration_list: Vec<GenerateIfDeclarationList>,
    pub generate_if_declaration_opt: Option<GenerateIfDeclarationOpt>,
}

///
/// Type derived for non-terminal GenerateIfDeclarationList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateIfDeclarationList {
    pub r#else: Box<Else>,
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub generate_optional_named_block: Box<GenerateOptionalNamedBlock>,
}

///
/// Type derived for non-terminal GenerateIfDeclarationOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateIfDeclarationOpt {
    pub r#else: Box<Else>,
    pub generate_optional_named_block: Box<GenerateOptionalNamedBlock>,
}

///
/// Type derived for non-terminal GenerateItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum GenerateItem {
    LetDeclaration(GenerateItemLetDeclaration),
    VarDeclaration(GenerateItemVarDeclaration),
    InstDeclaration(GenerateItemInstDeclaration),
    BindDeclaration(GenerateItemBindDeclaration),
    ConstDeclaration(GenerateItemConstDeclaration),
    AlwaysFfDeclaration(GenerateItemAlwaysFfDeclaration),
    AlwaysCombDeclaration(GenerateItemAlwaysCombDeclaration),
    AssignDeclaration(GenerateItemAssignDeclaration),
    ConnectDeclaration(GenerateItemConnectDeclaration),
    FunctionDeclaration(GenerateItemFunctionDeclaration),
    GenerateIfDeclaration(GenerateItemGenerateIfDeclaration),
    GenerateForDeclaration(GenerateItemGenerateForDeclaration),
    GenerateBlockDeclaration(GenerateItemGenerateBlockDeclaration),
    TypeDefDeclaration(GenerateItemTypeDefDeclaration),
    EnumDeclaration(GenerateItemEnumDeclaration),
    StructUnionDeclaration(GenerateItemStructUnionDeclaration),
    ImportDeclaration(GenerateItemImportDeclaration),
    AliasDeclaration(GenerateItemAliasDeclaration),
    InitialDeclaration(GenerateItemInitialDeclaration),
    FinalDeclaration(GenerateItemFinalDeclaration),
    UnsafeBlock(GenerateItemUnsafeBlock),
    EmbedDeclaration(GenerateItemEmbedDeclaration),
}

///
/// Type derived for non-terminal GenerateNamedBlock
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateNamedBlock {
    pub colon: Box<Colon>,
    pub identifier: Box<Identifier>,
    pub l_brace: Box<LBrace>,
    pub generate_named_block_list: Vec<GenerateNamedBlockList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal GenerateNamedBlockList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateNamedBlockList {
    pub generate_group: Box<GenerateGroup>,
}

///
/// Type derived for non-terminal GenerateOptionalNamedBlock
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateOptionalNamedBlock {
    pub generate_optional_named_block_opt: Option<GenerateOptionalNamedBlockOpt>,
    pub l_brace: Box<LBrace>,
    pub generate_optional_named_block_list: Vec<GenerateOptionalNamedBlockList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal GenerateOptionalNamedBlockList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateOptionalNamedBlockList {
    pub generate_group: Box<GenerateGroup>,
}

///
/// Type derived for non-terminal GenerateOptionalNamedBlockOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenerateOptionalNamedBlockOpt {
    pub colon: Box<Colon>,
    pub identifier: Box<Identifier>,
}

///
/// Type derived for non-terminal GenericArgIdentifier
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenericArgIdentifier {
    pub scoped_identifier: Box<ScopedIdentifier>,
    pub generic_arg_identifier_list: Vec<GenericArgIdentifierList>,
}

///
/// Type derived for non-terminal GenericArgIdentifierList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct GenericArgIdentifierList {
    pub dot: Box<Dot>,
    pub identifier: Box<Identifier>,
}

///
/// Type derived for non-terminal GenericBound
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum GenericBound {
    Type(GenericBoundType),
    InstScopedIdentifier(GenericBoundInstScopedIdentifier),
    GenericProtoBound(GenericBoundGenericProtoBound),
}

///
/// Type derived for non-terminal GenericProtoBound
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum GenericProtoBound {
    ScopedIdentifier(GenericProtoBoundScopedIdentifier),
    FixedType(GenericProtoBoundFixedType),
}

///
/// Type derived for non-terminal Hash
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Hash {
    pub hash_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal HashLBracket
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct HashLBracket {
    pub hash_l_bracket_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal HashLBracketTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct HashLBracketTerm {
    pub hash_l_bracket_term: crate::veryl_token::Token, /* #[ */
}

///
/// Type derived for non-terminal HashLBracketToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct HashLBracketToken {
    pub hash_l_bracket_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal HashTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct HashTerm {
    pub hash_term: crate::veryl_token::Token, /* # */
}

///
/// Type derived for non-terminal HashToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct HashToken {
    pub hash_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal HierarchicalIdentifier
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct HierarchicalIdentifier {
    pub identifier: Box<Identifier>,
    pub hierarchical_identifier_list: Vec<HierarchicalIdentifierList>,
    pub hierarchical_identifier_list0: Vec<HierarchicalIdentifierList0>,
}

///
/// Type derived for non-terminal HierarchicalIdentifierList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct HierarchicalIdentifierList {
    pub select: Box<Select>,
}

///
/// Type derived for non-terminal HierarchicalIdentifierList0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct HierarchicalIdentifierList0 {
    pub dot: Box<Dot>,
    pub identifier: Box<Identifier>,
    pub hierarchical_identifier_list0_list: Vec<HierarchicalIdentifierList0List>,
}

///
/// Type derived for non-terminal HierarchicalIdentifierList0List
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct HierarchicalIdentifierList0List {
    pub select: Box<Select>,
}

///
/// Type derived for non-terminal I16
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct I16 {
    pub i16_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal I16Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct I16Term {
    pub i16_term: crate::veryl_token::Token, /* i16 */
}

///
/// Type derived for non-terminal I16Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct I16Token {
    pub i16_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal I32
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct I32 {
    pub i32_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal I32Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct I32Term {
    pub i32_term: crate::veryl_token::Token, /* i32 */
}

///
/// Type derived for non-terminal I32Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct I32Token {
    pub i32_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal I64
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct I64 {
    pub i64_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal I64Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct I64Term {
    pub i64_term: crate::veryl_token::Token, /* i64 */
}

///
/// Type derived for non-terminal I64Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct I64Token {
    pub i64_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal I8
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct I8 {
    pub i8_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal I8Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct I8Term {
    pub i8_term: crate::veryl_token::Token, /* i8 */
}

///
/// Type derived for non-terminal I8Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct I8Token {
    pub i8_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Identifier
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Identifier {
    pub identifier_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal IdentifierFactor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IdentifierFactor {
    pub expression_identifier: Box<ExpressionIdentifier>,
    pub identifier_factor_opt: Option<IdentifierFactorOpt>,
}

///
/// Type derived for non-terminal IdentifierFactorOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IdentifierFactorOpt {
    pub identifier_factor_opt_group: Box<IdentifierFactorOptGroup>,
}

///
/// Type derived for non-terminal IdentifierFactorOptGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum IdentifierFactorOptGroup {
    FunctionCall(IdentifierFactorOptGroupFunctionCall),
    StructConstructor(IdentifierFactorOptGroupStructConstructor),
}

///
/// Type derived for non-terminal IdentifierStatement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IdentifierStatement {
    pub expression_identifier: Box<ExpressionIdentifier>,
    pub identifier_statement_group: Box<IdentifierStatementGroup>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal IdentifierStatementGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum IdentifierStatementGroup {
    FunctionCall(IdentifierStatementGroupFunctionCall),
    Assignment(IdentifierStatementGroupAssignment),
}

///
/// Type derived for non-terminal IdentifierTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IdentifierTerm {
    pub identifier_term: crate::veryl_token::Token, /* (?:r#)?[a-zA-Z_][0-9a-zA-Z_$]* */
}

///
/// Type derived for non-terminal IdentifierToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IdentifierToken {
    pub identifier_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal If
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct If {
    pub if_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal IfExpression
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IfExpression {
    pub if_expression_list: Vec<IfExpressionList>,
    pub expression01: Box<Expression01>,
}

///
/// Type derived for non-terminal IfExpressionList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IfExpressionList {
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub question: Box<Question>,
    pub expression0: Box<Expression>,
    pub colon: Box<Colon>,
}

///
/// Type derived for non-terminal IfReset
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IfReset {
    pub if_reset_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal IfResetStatement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IfResetStatement {
    pub if_reset: Box<IfReset>,
    pub statement_block: Box<StatementBlock>,
    pub if_reset_statement_list: Vec<IfResetStatementList>,
    pub if_reset_statement_opt: Option<IfResetStatementOpt>,
}

///
/// Type derived for non-terminal IfResetStatementList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IfResetStatementList {
    pub r#else: Box<Else>,
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub statement_block: Box<StatementBlock>,
}

///
/// Type derived for non-terminal IfResetStatementOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IfResetStatementOpt {
    pub r#else: Box<Else>,
    pub statement_block: Box<StatementBlock>,
}

///
/// Type derived for non-terminal IfResetTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IfResetTerm {
    pub if_reset_term: crate::veryl_token::Token, /* if_reset */
}

///
/// Type derived for non-terminal IfResetToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IfResetToken {
    pub if_reset_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal IfStatement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IfStatement {
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub statement_block: Box<StatementBlock>,
    pub if_statement_list: Vec<IfStatementList>,
    pub if_statement_opt: Option<IfStatementOpt>,
}

///
/// Type derived for non-terminal IfStatementList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IfStatementList {
    pub r#else: Box<Else>,
    pub r#if: Box<If>,
    pub expression: Box<Expression>,
    pub statement_block: Box<StatementBlock>,
}

///
/// Type derived for non-terminal IfStatementOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IfStatementOpt {
    pub r#else: Box<Else>,
    pub statement_block: Box<StatementBlock>,
}

///
/// Type derived for non-terminal IfTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IfTerm {
    pub if_term: crate::veryl_token::Token, /* if */
}

///
/// Type derived for non-terminal IfToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IfToken {
    pub if_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Import
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Import {
    pub import_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ImportDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ImportDeclaration {
    pub import: Box<Import>,
    pub scoped_identifier: Box<ScopedIdentifier>,
    pub import_declaration_opt: Option<ImportDeclarationOpt>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal ImportDeclarationOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ImportDeclarationOpt {
    pub colon_colon: Box<ColonColon>,
    pub star: Box<Star>,
}

///
/// Type derived for non-terminal ImportTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ImportTerm {
    pub import_term: crate::veryl_token::Token, /* import */
}

///
/// Type derived for non-terminal ImportToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ImportToken {
    pub import_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal In
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct In {
    pub in_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InTerm {
    pub in_term: crate::veryl_token::Token, /* in */
}

///
/// Type derived for non-terminal InToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InToken {
    pub in_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Include
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Include {
    pub include_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal IncludeDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IncludeDeclaration {
    pub include: Box<Include>,
    pub l_paren: Box<LParen>,
    pub identifier: Box<Identifier>,
    pub comma: Box<Comma>,
    pub string_literal: Box<StringLiteral>,
    pub r_paren: Box<RParen>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal IncludeTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IncludeTerm {
    pub include_term: crate::veryl_token::Token, /* include */
}

///
/// Type derived for non-terminal IncludeToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct IncludeToken {
    pub include_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Initial
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Initial {
    pub initial_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InitialDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InitialDeclaration {
    pub initial: Box<Initial>,
    pub statement_block: Box<StatementBlock>,
}

///
/// Type derived for non-terminal InitialTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InitialTerm {
    pub initial_term: crate::veryl_token::Token, /* initial */
}

///
/// Type derived for non-terminal InitialToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InitialToken {
    pub initial_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Inout
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Inout {
    pub inout_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InoutTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InoutTerm {
    pub inout_term: crate::veryl_token::Token, /* inout */
}

///
/// Type derived for non-terminal InoutToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InoutToken {
    pub inout_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Input
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Input {
    pub input_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InputTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InputTerm {
    pub input_term: crate::veryl_token::Token, /* input */
}

///
/// Type derived for non-terminal InputToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InputToken {
    pub input_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Inside
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Inside {
    pub inside_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InsideExpression
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InsideExpression {
    pub inside: Box<Inside>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub range_list: Box<RangeList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal InsideTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InsideTerm {
    pub inside_term: crate::veryl_token::Token, /* inside */
}

///
/// Type derived for non-terminal InsideToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InsideToken {
    pub inside_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Inst
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Inst {
    pub inst_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InstDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstDeclaration {
    pub inst: Box<Inst>,
    pub component_instantiation: Box<ComponentInstantiation>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal InstParameter
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstParameter {
    pub hash: Box<Hash>,
    pub l_paren: Box<LParen>,
    pub inst_parameter_opt: Option<InstParameterOpt>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal InstParameterGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstParameterGroup {
    pub inst_parameter_group_list: Vec<InstParameterGroupList>,
    pub inst_parameter_group_group: Box<InstParameterGroupGroup>,
}

///
/// Type derived for non-terminal InstParameterGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum InstParameterGroupGroup {
    LBraceInstParameterListRBrace(InstParameterGroupGroupLBraceInstParameterListRBrace),
    InstParameterItem(InstParameterGroupGroupInstParameterItem),
}

///
/// Type derived for non-terminal InstParameterGroupList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstParameterGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal InstParameterItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstParameterItem {
    pub identifier: Box<Identifier>,
    pub inst_parameter_item_opt: Option<InstParameterItemOpt>,
}

///
/// Type derived for non-terminal InstParameterItemOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstParameterItemOpt {
    pub colon: Box<Colon>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal InstParameterList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstParameterList {
    pub inst_parameter_group: Box<InstParameterGroup>,
    pub inst_parameter_list_list: Vec<InstParameterListList>,
    pub inst_parameter_list_opt: Option<InstParameterListOpt>,
}

///
/// Type derived for non-terminal InstParameterListList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstParameterListList {
    pub comma: Box<Comma>,
    pub inst_parameter_group: Box<InstParameterGroup>,
}

///
/// Type derived for non-terminal InstParameterListOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstParameterListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal InstParameterOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstParameterOpt {
    pub inst_parameter_list: Box<InstParameterList>,
}

///
/// Type derived for non-terminal InstPort
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstPort {
    pub l_paren: Box<LParen>,
    pub inst_port_opt: Option<InstPortOpt>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal InstPortGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstPortGroup {
    pub inst_port_group_list: Vec<InstPortGroupList>,
    pub inst_port_group_group: Box<InstPortGroupGroup>,
}

///
/// Type derived for non-terminal InstPortGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum InstPortGroupGroup {
    LBraceInstPortListRBrace(InstPortGroupGroupLBraceInstPortListRBrace),
    InstPortItem(InstPortGroupGroupInstPortItem),
}

///
/// Type derived for non-terminal InstPortGroupList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstPortGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal InstPortItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstPortItem {
    pub identifier: Box<Identifier>,
    pub inst_port_item_opt: Option<InstPortItemOpt>,
}

///
/// Type derived for non-terminal InstPortItemOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstPortItemOpt {
    pub colon: Box<Colon>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal InstPortList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstPortList {
    pub inst_port_group: Box<InstPortGroup>,
    pub inst_port_list_list: Vec<InstPortListList>,
    pub inst_port_list_opt: Option<InstPortListOpt>,
}

///
/// Type derived for non-terminal InstPortListList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstPortListList {
    pub comma: Box<Comma>,
    pub inst_port_group: Box<InstPortGroup>,
}

///
/// Type derived for non-terminal InstPortListOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstPortListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal InstPortOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstPortOpt {
    pub inst_port_list: Box<InstPortList>,
}

///
/// Type derived for non-terminal InstTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstTerm {
    pub inst_term: crate::veryl_token::Token, /* inst */
}

///
/// Type derived for non-terminal InstToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InstToken {
    pub inst_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal IntegralNumber
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum IntegralNumber {
    Based(IntegralNumberBased),
    BaseLess(IntegralNumberBaseLess),
    AllBit(IntegralNumberAllBit),
}

///
/// Type derived for non-terminal Interface
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Interface {
    pub interface_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal InterfaceDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InterfaceDeclaration {
    pub interface: Box<Interface>,
    pub identifier: Box<Identifier>,
    pub interface_declaration_opt: Option<InterfaceDeclarationOpt>,
    pub interface_declaration_opt0: Option<InterfaceDeclarationOpt0>,
    pub interface_declaration_opt1: Option<InterfaceDeclarationOpt1>,
    pub l_brace: Box<LBrace>,
    pub interface_declaration_list: Vec<InterfaceDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal InterfaceDeclarationList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InterfaceDeclarationList {
    pub interface_group: Box<InterfaceGroup>,
}

///
/// Type derived for non-terminal InterfaceDeclarationOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InterfaceDeclarationOpt {
    pub with_generic_parameter: Box<WithGenericParameter>,
}

///
/// Type derived for non-terminal InterfaceDeclarationOpt0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InterfaceDeclarationOpt0 {
    pub r#for: Box<For>,
    pub scoped_identifier: Box<ScopedIdentifier>,
}

///
/// Type derived for non-terminal InterfaceDeclarationOpt1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InterfaceDeclarationOpt1 {
    pub with_parameter: Box<WithParameter>,
}

///
/// Type derived for non-terminal InterfaceGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InterfaceGroup {
    pub interface_group_list: Vec<InterfaceGroupList>,
    pub interface_group_group: Box<InterfaceGroupGroup>,
}

///
/// Type derived for non-terminal InterfaceGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum InterfaceGroupGroup {
    LBraceInterfaceGroupGroupListRBrace(InterfaceGroupGroupLBraceInterfaceGroupGroupListRBrace),
    InterfaceItem(InterfaceGroupGroupInterfaceItem),
}

///
/// Type derived for non-terminal InterfaceGroupGroupList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InterfaceGroupGroupList {
    pub interface_group: Box<InterfaceGroup>,
}

///
/// Type derived for non-terminal InterfaceGroupList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InterfaceGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal InterfaceItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum InterfaceItem {
    GenerateItem(InterfaceItemGenerateItem),
    ModportDeclaration(InterfaceItemModportDeclaration),
}

///
/// Type derived for non-terminal InterfaceTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InterfaceTerm {
    pub interface_term: crate::veryl_token::Token, /* interface */
}

///
/// Type derived for non-terminal InterfaceToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct InterfaceToken {
    pub interface_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LAngle
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LAngle {
    pub l_angle_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LAngleTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LAngleTerm {
    pub l_angle_term: crate::veryl_token::Token, /* < */
}

///
/// Type derived for non-terminal LAngleToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LAngleToken {
    pub l_angle_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LBrace
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LBrace {
    pub l_brace_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LBraceTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LBraceTerm {
    pub l_brace_term: crate::veryl_token::Token, /* { */
}

///
/// Type derived for non-terminal LBraceToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LBraceToken {
    pub l_brace_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LBracket
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LBracket {
    pub l_bracket_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LBracketTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LBracketTerm {
    pub l_bracket_term: crate::veryl_token::Token, /* [ */
}

///
/// Type derived for non-terminal LBracketToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LBracketToken {
    pub l_bracket_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LParen
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LParen {
    pub l_paren_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LParenTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LParenTerm {
    pub l_paren_term: crate::veryl_token::Token, /* ( */
}

///
/// Type derived for non-terminal LParenToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LParenToken {
    pub l_paren_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal LTMinus
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LTMinus {
    pub l_t_minus_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LTMinusTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LTMinusTerm {
    pub l_t_minus_term: crate::veryl_token::Token, /* <- */
}

///
/// Type derived for non-terminal LTMinusToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LTMinusToken {
    pub l_t_minus_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Let
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Let {
    pub let_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LetDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LetDeclaration {
    pub r#let: Box<Let>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub let_declaration_opt: Option<LetDeclarationOpt>,
    pub array_type: Box<ArrayType>,
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal LetDeclarationOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LetDeclarationOpt {
    pub clock_domain: Box<ClockDomain>,
}

///
/// Type derived for non-terminal LetStatement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LetStatement {
    pub r#let: Box<Let>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub let_statement_opt: Option<LetStatementOpt>,
    pub array_type: Box<ArrayType>,
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal LetStatementOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LetStatementOpt {
    pub clock_domain: Box<ClockDomain>,
}

///
/// Type derived for non-terminal LetTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LetTerm {
    pub let_term: crate::veryl_token::Token, /* let */
}

///
/// Type derived for non-terminal LetToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LetToken {
    pub let_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Logic
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Logic {
    pub logic_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LogicTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LogicTerm {
    pub logic_term: crate::veryl_token::Token, /* logic */
}

///
/// Type derived for non-terminal LogicToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LogicToken {
    pub logic_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Lsb
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Lsb {
    pub lsb_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal LsbTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LsbTerm {
    pub lsb_term: crate::veryl_token::Token, /* lsb */
}

///
/// Type derived for non-terminal LsbToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct LsbToken {
    pub lsb_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal MinusColon
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct MinusColon {
    pub minus_colon_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal MinusColonTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct MinusColonTerm {
    pub minus_colon_term: crate::veryl_token::Token, /* -: */
}

///
/// Type derived for non-terminal MinusColonToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct MinusColonToken {
    pub minus_colon_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal MinusGT
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct MinusGT {
    pub minus_g_t_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal MinusGTTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct MinusGTTerm {
    pub minus_g_t_term: crate::veryl_token::Token, /* -> */
}

///
/// Type derived for non-terminal MinusGTToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct MinusGTToken {
    pub minus_g_t_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Modport
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Modport {
    pub modport_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ModportDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModportDeclaration {
    pub modport: Box<Modport>,
    pub identifier: Box<Identifier>,
    pub l_brace: Box<LBrace>,
    pub modport_declaration_opt: Option<ModportDeclarationOpt>,
    pub modport_declaration_opt0: Option<ModportDeclarationOpt0>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal ModportDeclarationOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModportDeclarationOpt {
    pub modport_list: Box<ModportList>,
}

///
/// Type derived for non-terminal ModportDeclarationOpt0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModportDeclarationOpt0 {
    pub dot_dot: Box<DotDot>,
    pub modport_default: Box<ModportDefault>,
}

///
/// Type derived for non-terminal ModportDefault
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ModportDefault {
    Input(ModportDefaultInput),
    Output(ModportDefaultOutput),
    SameLParenIdentifierRParen(ModportDefaultSameLParenIdentifierRParen),
    ConverseLParenIdentifierRParen(ModportDefaultConverseLParenIdentifierRParen),
}

///
/// Type derived for non-terminal ModportGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModportGroup {
    pub modport_group_list: Vec<ModportGroupList>,
    pub modport_group_group: Box<ModportGroupGroup>,
}

///
/// Type derived for non-terminal ModportGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ModportGroupGroup {
    LBraceModportListRBrace(ModportGroupGroupLBraceModportListRBrace),
    ModportItem(ModportGroupGroupModportItem),
}

///
/// Type derived for non-terminal ModportGroupList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModportGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal ModportItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModportItem {
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub direction: Box<Direction>,
}

///
/// Type derived for non-terminal ModportList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModportList {
    pub modport_group: Box<ModportGroup>,
    pub modport_list_list: Vec<ModportListList>,
    pub modport_list_opt: Option<ModportListOpt>,
}

///
/// Type derived for non-terminal ModportListList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModportListList {
    pub comma: Box<Comma>,
    pub modport_group: Box<ModportGroup>,
}

///
/// Type derived for non-terminal ModportListOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModportListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal ModportTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModportTerm {
    pub modport_term: crate::veryl_token::Token, /* modport */
}

///
/// Type derived for non-terminal ModportToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModportToken {
    pub modport_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Module
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Module {
    pub module_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ModuleDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModuleDeclaration {
    pub module: Box<Module>,
    pub identifier: Box<Identifier>,
    pub module_declaration_opt: Option<ModuleDeclarationOpt>,
    pub module_declaration_opt0: Option<ModuleDeclarationOpt0>,
    pub module_declaration_opt1: Option<ModuleDeclarationOpt1>,
    pub module_declaration_opt2: Option<ModuleDeclarationOpt2>,
    pub l_brace: Box<LBrace>,
    pub module_declaration_list: Vec<ModuleDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal ModuleDeclarationList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModuleDeclarationList {
    pub module_group: Box<ModuleGroup>,
}

///
/// Type derived for non-terminal ModuleDeclarationOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModuleDeclarationOpt {
    pub with_generic_parameter: Box<WithGenericParameter>,
}

///
/// Type derived for non-terminal ModuleDeclarationOpt0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModuleDeclarationOpt0 {
    pub r#for: Box<For>,
    pub scoped_identifier: Box<ScopedIdentifier>,
}

///
/// Type derived for non-terminal ModuleDeclarationOpt1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModuleDeclarationOpt1 {
    pub with_parameter: Box<WithParameter>,
}

///
/// Type derived for non-terminal ModuleDeclarationOpt2
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModuleDeclarationOpt2 {
    pub port_declaration: Box<PortDeclaration>,
}

///
/// Type derived for non-terminal ModuleGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModuleGroup {
    pub module_group_list: Vec<ModuleGroupList>,
    pub module_group_group: Box<ModuleGroupGroup>,
}

///
/// Type derived for non-terminal ModuleGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ModuleGroupGroup {
    LBraceModuleGroupGroupListRBrace(ModuleGroupGroupLBraceModuleGroupGroupListRBrace),
    ModuleItem(ModuleGroupGroupModuleItem),
}

///
/// Type derived for non-terminal ModuleGroupGroupList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModuleGroupGroupList {
    pub module_group: Box<ModuleGroup>,
}

///
/// Type derived for non-terminal ModuleGroupList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModuleGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal ModuleItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModuleItem {
    pub generate_item: Box<GenerateItem>,
}

///
/// Type derived for non-terminal ModuleTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModuleTerm {
    pub module_term: crate::veryl_token::Token, /* module */
}

///
/// Type derived for non-terminal ModuleToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ModuleToken {
    pub module_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Msb
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Msb {
    pub msb_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal MsbTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct MsbTerm {
    pub msb_term: crate::veryl_token::Token, /* msb */
}

///
/// Type derived for non-terminal MsbToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct MsbToken {
    pub msb_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Number
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Number {
    IntegralNumber(NumberIntegralNumber),
    RealNumber(NumberRealNumber),
}

///
/// Type derived for non-terminal Operator02
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator02 {
    pub operator02_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator02Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator02Term {
    pub operator02_term: crate::veryl_token::Token, /* \|\| */
}

///
/// Type derived for non-terminal Operator02Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator02Token {
    pub operator02_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator03
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator03 {
    pub operator03_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator03Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator03Term {
    pub operator03_term: crate::veryl_token::Token, /* && */
}

///
/// Type derived for non-terminal Operator03Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator03Token {
    pub operator03_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator04
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator04 {
    pub operator04_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator04Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator04Term {
    pub operator04_term: crate::veryl_token::Token, /* \| */
}

///
/// Type derived for non-terminal Operator04Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator04Token {
    pub operator04_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator05
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator05 {
    pub operator05_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator05Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator05Term {
    pub operator05_term: crate::veryl_token::Token, /* \^|~\^ */
}

///
/// Type derived for non-terminal Operator05Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator05Token {
    pub operator05_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator06
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator06 {
    pub operator06_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator06Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator06Term {
    pub operator06_term: crate::veryl_token::Token, /* & */
}

///
/// Type derived for non-terminal Operator06Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator06Token {
    pub operator06_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator07
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator07 {
    pub operator07_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator07Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator07Term {
    pub operator07_term: crate::veryl_token::Token, /* ==\?|!=\?|==|!= */
}

///
/// Type derived for non-terminal Operator07Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator07Token {
    pub operator07_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator08
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator08 {
    pub operator08_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator08Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator08Term {
    pub operator08_term: crate::veryl_token::Token, /* <=|>=|<:|>: */
}

///
/// Type derived for non-terminal Operator08Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator08Token {
    pub operator08_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator09
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator09 {
    pub operator09_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator09Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator09Term {
    pub operator09_term: crate::veryl_token::Token, /* <<<|>>>|<<|>> */
}

///
/// Type derived for non-terminal Operator09Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator09Token {
    pub operator09_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator10
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator10 {
    pub operator10_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator10Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator10Term {
    pub operator10_term: crate::veryl_token::Token, /* \+|- */
}

///
/// Type derived for non-terminal Operator10Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator10Token {
    pub operator10_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator11
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator11 {
    pub operator11_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator11Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator11Term {
    pub operator11_term: crate::veryl_token::Token, /* /|% */
}

///
/// Type derived for non-terminal Operator11Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator11Token {
    pub operator11_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Operator12
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator12 {
    pub operator12_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal Operator12Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator12Term {
    pub operator12_term: crate::veryl_token::Token, /* \*\* */
}

///
/// Type derived for non-terminal Operator12Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Operator12Token {
    pub operator12_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Output
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Output {
    pub output_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal OutputTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct OutputTerm {
    pub output_term: crate::veryl_token::Token, /* output */
}

///
/// Type derived for non-terminal OutputToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct OutputToken {
    pub output_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Outside
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Outside {
    pub outside_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal OutsideExpression
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct OutsideExpression {
    pub outside: Box<Outside>,
    pub expression: Box<Expression>,
    pub l_brace: Box<LBrace>,
    pub range_list: Box<RangeList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal OutsideTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct OutsideTerm {
    pub outside_term: crate::veryl_token::Token, /* outside */
}

///
/// Type derived for non-terminal OutsideToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct OutsideToken {
    pub outside_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Package
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Package {
    pub package_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal PackageDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PackageDeclaration {
    pub package: Box<Package>,
    pub identifier: Box<Identifier>,
    pub package_declaration_opt: Option<PackageDeclarationOpt>,
    pub package_declaration_opt0: Option<PackageDeclarationOpt0>,
    pub l_brace: Box<LBrace>,
    pub package_declaration_list: Vec<PackageDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal PackageDeclarationList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PackageDeclarationList {
    pub package_group: Box<PackageGroup>,
}

///
/// Type derived for non-terminal PackageDeclarationOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PackageDeclarationOpt {
    pub with_generic_parameter: Box<WithGenericParameter>,
}

///
/// Type derived for non-terminal PackageDeclarationOpt0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PackageDeclarationOpt0 {
    pub r#for: Box<For>,
    pub scoped_identifier: Box<ScopedIdentifier>,
}

///
/// Type derived for non-terminal PackageGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PackageGroup {
    pub package_group_list: Vec<PackageGroupList>,
    pub package_group_group: Box<PackageGroupGroup>,
}

///
/// Type derived for non-terminal PackageGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum PackageGroupGroup {
    LBracePackageGroupGroupListRBrace(PackageGroupGroupLBracePackageGroupGroupListRBrace),
    PackageItem(PackageGroupGroupPackageItem),
}

///
/// Type derived for non-terminal PackageGroupGroupList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PackageGroupGroupList {
    pub package_group: Box<PackageGroup>,
}

///
/// Type derived for non-terminal PackageGroupList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PackageGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal PackageItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum PackageItem {
    ConstDeclaration(PackageItemConstDeclaration),
    TypeDefDeclaration(PackageItemTypeDefDeclaration),
    EnumDeclaration(PackageItemEnumDeclaration),
    StructUnionDeclaration(PackageItemStructUnionDeclaration),
    FunctionDeclaration(PackageItemFunctionDeclaration),
    ImportDeclaration(PackageItemImportDeclaration),
    AliasDeclaration(PackageItemAliasDeclaration),
    EmbedDeclaration(PackageItemEmbedDeclaration),
}

///
/// Type derived for non-terminal PackageTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PackageTerm {
    pub package_term: crate::veryl_token::Token, /* package */
}

///
/// Type derived for non-terminal PackageToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PackageToken {
    pub package_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Param
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Param {
    pub param_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ParamTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ParamTerm {
    pub param_term: crate::veryl_token::Token, /* param */
}

///
/// Type derived for non-terminal ParamToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ParamToken {
    pub param_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal PlusColon
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PlusColon {
    pub plus_colon_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal PlusColonTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PlusColonTerm {
    pub plus_colon_term: crate::veryl_token::Token, /* +: */
}

///
/// Type derived for non-terminal PlusColonToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PlusColonToken {
    pub plus_colon_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal PortDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PortDeclaration {
    pub l_paren: Box<LParen>,
    pub port_declaration_opt: Option<PortDeclarationOpt>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal PortDeclarationGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PortDeclarationGroup {
    pub port_declaration_group_list: Vec<PortDeclarationGroupList>,
    pub port_declaration_group_group: Box<PortDeclarationGroupGroup>,
}

///
/// Type derived for non-terminal PortDeclarationGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum PortDeclarationGroupGroup {
    LBracePortDeclarationListRBrace(PortDeclarationGroupGroupLBracePortDeclarationListRBrace),
    PortDeclarationItem(PortDeclarationGroupGroupPortDeclarationItem),
}

///
/// Type derived for non-terminal PortDeclarationGroupList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PortDeclarationGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal PortDeclarationItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PortDeclarationItem {
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub port_declaration_item_group: Box<PortDeclarationItemGroup>,
}

///
/// Type derived for non-terminal PortDeclarationItemGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum PortDeclarationItemGroup {
    PortTypeConcrete(PortDeclarationItemGroupPortTypeConcrete),
    PortTypeAbstract(PortDeclarationItemGroupPortTypeAbstract),
}

///
/// Type derived for non-terminal PortDeclarationList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PortDeclarationList {
    pub port_declaration_group: Box<PortDeclarationGroup>,
    pub port_declaration_list_list: Vec<PortDeclarationListList>,
    pub port_declaration_list_opt: Option<PortDeclarationListOpt>,
}

///
/// Type derived for non-terminal PortDeclarationListList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PortDeclarationListList {
    pub comma: Box<Comma>,
    pub port_declaration_group: Box<PortDeclarationGroup>,
}

///
/// Type derived for non-terminal PortDeclarationListOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PortDeclarationListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal PortDeclarationOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PortDeclarationOpt {
    pub port_declaration_list: Box<PortDeclarationList>,
}

///
/// Type derived for non-terminal PortDefaultValue
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PortDefaultValue {
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal PortTypeAbstract
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PortTypeAbstract {
    pub port_type_abstract_opt: Option<PortTypeAbstractOpt>,
    pub interface: Box<Interface>,
    pub port_type_abstract_opt0: Option<PortTypeAbstractOpt0>,
    pub port_type_abstract_opt1: Option<PortTypeAbstractOpt1>,
}

///
/// Type derived for non-terminal PortTypeAbstractOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PortTypeAbstractOpt {
    pub clock_domain: Box<ClockDomain>,
}

///
/// Type derived for non-terminal PortTypeAbstractOpt0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PortTypeAbstractOpt0 {
    pub colon_colon: Box<ColonColon>,
    pub identifier: Box<Identifier>,
}

///
/// Type derived for non-terminal PortTypeAbstractOpt1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PortTypeAbstractOpt1 {
    pub array: Box<Array>,
}

///
/// Type derived for non-terminal PortTypeConcrete
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PortTypeConcrete {
    pub direction: Box<Direction>,
    pub port_type_concrete_opt: Option<PortTypeConcreteOpt>,
    pub array_type: Box<ArrayType>,
    pub port_type_concrete_opt0: Option<PortTypeConcreteOpt0>,
}

///
/// Type derived for non-terminal PortTypeConcreteOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PortTypeConcreteOpt {
    pub clock_domain: Box<ClockDomain>,
}

///
/// Type derived for non-terminal PortTypeConcreteOpt0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PortTypeConcreteOpt0 {
    pub equ: Box<Equ>,
    pub port_default_value: Box<PortDefaultValue>,
}

///
/// Type derived for non-terminal Proto
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Proto {
    pub proto_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ProtoAliasDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoAliasDeclaration {
    pub alias: Box<Alias>,
    pub proto_alias_declaration_group: Box<ProtoAliasDeclarationGroup>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub scoped_identifier: Box<ScopedIdentifier>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal ProtoAliasDeclarationGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ProtoAliasDeclarationGroup {
    Module(ProtoAliasDeclarationGroupModule),
    Interface(ProtoAliasDeclarationGroupInterface),
    Package(ProtoAliasDeclarationGroupPackage),
}

///
/// Type derived for non-terminal ProtoConstDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoConstDeclaration {
    pub r#const: Box<Const>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub proto_const_declaration_group: Box<ProtoConstDeclarationGroup>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal ProtoConstDeclarationGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ProtoConstDeclarationGroup {
    ArrayType(ProtoConstDeclarationGroupArrayType),
    Type(ProtoConstDeclarationGroupType),
}

///
/// Type derived for non-terminal ProtoDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoDeclaration {
    pub proto: Box<Proto>,
    pub proto_declaration_group: Box<ProtoDeclarationGroup>,
}

///
/// Type derived for non-terminal ProtoDeclarationGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ProtoDeclarationGroup {
    ProtoModuleDeclaration(ProtoDeclarationGroupProtoModuleDeclaration),
    ProtoInterfaceDeclaration(ProtoDeclarationGroupProtoInterfaceDeclaration),
    ProtoPackageDeclaration(ProtoDeclarationGroupProtoPackageDeclaration),
}

///
/// Type derived for non-terminal ProtoFunctionDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoFunctionDeclaration {
    pub function: Box<Function>,
    pub identifier: Box<Identifier>,
    pub proto_function_declaration_opt: Option<ProtoFunctionDeclarationOpt>,
    pub proto_function_declaration_opt0: Option<ProtoFunctionDeclarationOpt0>,
    pub proto_function_declaration_opt1: Option<ProtoFunctionDeclarationOpt1>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal ProtoFunctionDeclarationOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoFunctionDeclarationOpt {
    pub with_generic_parameter: Box<WithGenericParameter>,
}

///
/// Type derived for non-terminal ProtoFunctionDeclarationOpt0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoFunctionDeclarationOpt0 {
    pub port_declaration: Box<PortDeclaration>,
}

///
/// Type derived for non-terminal ProtoFunctionDeclarationOpt1
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoFunctionDeclarationOpt1 {
    pub minus_g_t: Box<MinusGT>,
    pub scalar_type: Box<ScalarType>,
}

///
/// Type derived for non-terminal ProtoInterfaceDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoInterfaceDeclaration {
    pub interface: Box<Interface>,
    pub identifier: Box<Identifier>,
    pub proto_interface_declaration_opt: Option<ProtoInterfaceDeclarationOpt>,
    pub l_brace: Box<LBrace>,
    pub proto_interface_declaration_list: Vec<ProtoInterfaceDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal ProtoInterfaceDeclarationList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoInterfaceDeclarationList {
    pub proto_interface_item: Box<ProtoInterfaceItem>,
}

///
/// Type derived for non-terminal ProtoInterfaceDeclarationOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoInterfaceDeclarationOpt {
    pub with_parameter: Box<WithParameter>,
}

///
/// Type derived for non-terminal ProtoInterfaceItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ProtoInterfaceItem {
    VarDeclaration(ProtoInterfaceItemVarDeclaration),
    ProtoConstDeclaration(ProtoInterfaceItemProtoConstDeclaration),
    ProtoFunctionDeclaration(ProtoInterfaceItemProtoFunctionDeclaration),
    ProtoTypeDefDeclaration(ProtoInterfaceItemProtoTypeDefDeclaration),
    ProtoAliasDeclaration(ProtoInterfaceItemProtoAliasDeclaration),
    ModportDeclaration(ProtoInterfaceItemModportDeclaration),
    ImportDeclaration(ProtoInterfaceItemImportDeclaration),
}

///
/// Type derived for non-terminal ProtoModuleDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoModuleDeclaration {
    pub module: Box<Module>,
    pub identifier: Box<Identifier>,
    pub proto_module_declaration_opt: Option<ProtoModuleDeclarationOpt>,
    pub proto_module_declaration_opt0: Option<ProtoModuleDeclarationOpt0>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal ProtoModuleDeclarationOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoModuleDeclarationOpt {
    pub with_parameter: Box<WithParameter>,
}

///
/// Type derived for non-terminal ProtoModuleDeclarationOpt0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoModuleDeclarationOpt0 {
    pub port_declaration: Box<PortDeclaration>,
}

///
/// Type derived for non-terminal ProtoPacakgeItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ProtoPacakgeItem {
    ProtoConstDeclaration(ProtoPacakgeItemProtoConstDeclaration),
    ProtoTypeDefDeclaration(ProtoPacakgeItemProtoTypeDefDeclaration),
    EnumDeclaration(ProtoPacakgeItemEnumDeclaration),
    StructUnionDeclaration(ProtoPacakgeItemStructUnionDeclaration),
    ProtoFunctionDeclaration(ProtoPacakgeItemProtoFunctionDeclaration),
    ProtoAliasDeclaration(ProtoPacakgeItemProtoAliasDeclaration),
    ImportDeclaration(ProtoPacakgeItemImportDeclaration),
}

///
/// Type derived for non-terminal ProtoPackageDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoPackageDeclaration {
    pub package: Box<Package>,
    pub identifier: Box<Identifier>,
    pub l_brace: Box<LBrace>,
    pub proto_package_declaration_list: Vec<ProtoPackageDeclarationList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal ProtoPackageDeclarationList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoPackageDeclarationList {
    pub proto_pacakge_item: Box<ProtoPacakgeItem>,
}

///
/// Type derived for non-terminal ProtoTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoTerm {
    pub proto_term: crate::veryl_token::Token, /* proto */
}

///
/// Type derived for non-terminal ProtoToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoToken {
    pub proto_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal ProtoTypeDefDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoTypeDefDeclaration {
    pub r#type: Box<Type>,
    pub identifier: Box<Identifier>,
    pub proto_type_def_declaration_opt: Option<ProtoTypeDefDeclarationOpt>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal ProtoTypeDefDeclarationOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ProtoTypeDefDeclarationOpt {
    pub equ: Box<Equ>,
    pub array_type: Box<ArrayType>,
}

///
/// Type derived for non-terminal Pub
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Pub {
    pub pub_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal PubTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PubTerm {
    pub pub_term: crate::veryl_token::Token, /* pub */
}

///
/// Type derived for non-terminal PubToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct PubToken {
    pub pub_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal PublicDescriptionItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum PublicDescriptionItem {
    ModuleDeclaration(PublicDescriptionItemModuleDeclaration),
    InterfaceDeclaration(PublicDescriptionItemInterfaceDeclaration),
    PackageDeclaration(PublicDescriptionItemPackageDeclaration),
    AliasDeclaration(PublicDescriptionItemAliasDeclaration),
    ProtoDeclaration(PublicDescriptionItemProtoDeclaration),
}

///
/// Type derived for non-terminal Question
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Question {
    pub question_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal QuestionTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct QuestionTerm {
    pub question_term: crate::veryl_token::Token, /* ? */
}

///
/// Type derived for non-terminal QuestionToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct QuestionToken {
    pub question_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Quote
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Quote {
    pub quote_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal QuoteLBrace
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct QuoteLBrace {
    pub quote_l_brace_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal QuoteLBraceTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct QuoteLBraceTerm {
    pub quote_l_brace_term: crate::veryl_token::Token, /* '\{ */
}

///
/// Type derived for non-terminal QuoteLBraceToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct QuoteLBraceToken {
    pub quote_l_brace_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal QuoteTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct QuoteTerm {
    pub quote_term: crate::veryl_token::Token, /* ' */
}

///
/// Type derived for non-terminal QuoteToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct QuoteToken {
    pub quote_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal RAngle
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RAngle {
    pub r_angle_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RAngleTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RAngleTerm {
    pub r_angle_term: crate::veryl_token::Token, /* > */
}

///
/// Type derived for non-terminal RAngleToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RAngleToken {
    pub r_angle_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal RBrace
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RBrace {
    pub r_brace_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RBraceTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RBraceTerm {
    pub r_brace_term: crate::veryl_token::Token, /* } */
}

///
/// Type derived for non-terminal RBraceToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RBraceToken {
    pub r_brace_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal RBracket
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RBracket {
    pub r_bracket_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RBracketTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RBracketTerm {
    pub r_bracket_term: crate::veryl_token::Token, /* ] */
}

///
/// Type derived for non-terminal RBracketToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RBracketToken {
    pub r_bracket_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal RParen
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RParen {
    pub r_paren_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RParenTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RParenTerm {
    pub r_paren_term: crate::veryl_token::Token, /* ) */
}

///
/// Type derived for non-terminal RParenToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RParenToken {
    pub r_paren_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Range
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Range {
    pub expression: Box<Expression>,
    pub range_opt: Option<RangeOpt>,
}

///
/// Type derived for non-terminal RangeItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RangeItem {
    pub range: Box<Range>,
}

///
/// Type derived for non-terminal RangeList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RangeList {
    pub range_item: Box<RangeItem>,
    pub range_list_list: Vec<RangeListList>,
    pub range_list_opt: Option<RangeListOpt>,
}

///
/// Type derived for non-terminal RangeListList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RangeListList {
    pub comma: Box<Comma>,
    pub range_item: Box<RangeItem>,
}

///
/// Type derived for non-terminal RangeListOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RangeListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal RangeOperator
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum RangeOperator {
    DotDot(RangeOperatorDotDot),
    DotDotEqu(RangeOperatorDotDotEqu),
}

///
/// Type derived for non-terminal RangeOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RangeOpt {
    pub range_operator: Box<RangeOperator>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal RealNumber
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum RealNumber {
    FixedPoint(RealNumberFixedPoint),
    Exponent(RealNumberExponent),
}

///
/// Type derived for non-terminal Repeat
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Repeat {
    pub repeat_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RepeatTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RepeatTerm {
    pub repeat_term: crate::veryl_token::Token, /* repeat */
}

///
/// Type derived for non-terminal RepeatToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RepeatToken {
    pub repeat_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Reset
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Reset {
    pub reset_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ResetAsyncHigh
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ResetAsyncHigh {
    pub reset_async_high_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ResetAsyncHighTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ResetAsyncHighTerm {
    pub reset_async_high_term: crate::veryl_token::Token, /* reset_async_high */
}

///
/// Type derived for non-terminal ResetAsyncHighToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ResetAsyncHighToken {
    pub reset_async_high_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal ResetAsyncLow
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ResetAsyncLow {
    pub reset_async_low_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ResetAsyncLowTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ResetAsyncLowTerm {
    pub reset_async_low_term: crate::veryl_token::Token, /* reset_async_low */
}

///
/// Type derived for non-terminal ResetAsyncLowToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ResetAsyncLowToken {
    pub reset_async_low_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal ResetSyncHigh
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ResetSyncHigh {
    pub reset_sync_high_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ResetSyncHighTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ResetSyncHighTerm {
    pub reset_sync_high_term: crate::veryl_token::Token, /* reset_sync_high */
}

///
/// Type derived for non-terminal ResetSyncHighToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ResetSyncHighToken {
    pub reset_sync_high_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal ResetSyncLow
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ResetSyncLow {
    pub reset_sync_low_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ResetSyncLowTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ResetSyncLowTerm {
    pub reset_sync_low_term: crate::veryl_token::Token, /* reset_sync_low */
}

///
/// Type derived for non-terminal ResetSyncLowToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ResetSyncLowToken {
    pub reset_sync_low_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal ResetTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ResetTerm {
    pub reset_term: crate::veryl_token::Token, /* reset */
}

///
/// Type derived for non-terminal ResetToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ResetToken {
    pub reset_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Return
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Return {
    pub return_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal ReturnStatement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ReturnStatement {
    pub r#return: Box<Return>,
    pub expression: Box<Expression>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal ReturnTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ReturnTerm {
    pub return_term: crate::veryl_token::Token, /* return */
}

///
/// Type derived for non-terminal ReturnToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ReturnToken {
    pub return_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Rev
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Rev {
    pub rev_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal RevTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RevTerm {
    pub rev_term: crate::veryl_token::Token, /* rev */
}

///
/// Type derived for non-terminal RevToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct RevToken {
    pub rev_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Same
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Same {
    pub same_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal SameTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SameTerm {
    pub same_term: crate::veryl_token::Token, /* same */
}

///
/// Type derived for non-terminal SameToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SameToken {
    pub same_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal ScalarType
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScalarType {
    pub scalar_type_list: Vec<ScalarTypeList>,
    pub scalar_type_group: Box<ScalarTypeGroup>,
}

///
/// Type derived for non-terminal ScalarTypeGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ScalarTypeGroup {
    UserDefinedTypeScalarTypeOpt(ScalarTypeGroupUserDefinedTypeScalarTypeOpt),
    FactorType(ScalarTypeGroupFactorType),
}

///
/// Type derived for non-terminal ScalarTypeList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScalarTypeList {
    pub type_modifier: Box<TypeModifier>,
}

///
/// Type derived for non-terminal ScalarTypeOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScalarTypeOpt {
    pub width: Box<Width>,
}

///
/// Type derived for non-terminal ScopedIdentifier
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScopedIdentifier {
    pub scoped_identifier_group: Box<ScopedIdentifierGroup>,
    pub scoped_identifier_list: Vec<ScopedIdentifierList>,
}

///
/// Type derived for non-terminal ScopedIdentifierGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ScopedIdentifierGroup {
    DollarIdentifier(ScopedIdentifierGroupDollarIdentifier),
    IdentifierScopedIdentifierOpt(ScopedIdentifierGroupIdentifierScopedIdentifierOpt),
}

///
/// Type derived for non-terminal ScopedIdentifierList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScopedIdentifierList {
    pub colon_colon: Box<ColonColon>,
    pub identifier: Box<Identifier>,
    pub scoped_identifier_opt0: Option<ScopedIdentifierOpt0>,
}

///
/// Type derived for non-terminal ScopedIdentifierOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScopedIdentifierOpt {
    pub with_generic_argument: Box<WithGenericArgument>,
}

///
/// Type derived for non-terminal ScopedIdentifierOpt0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct ScopedIdentifierOpt0 {
    pub with_generic_argument: Box<WithGenericArgument>,
}

///
/// Type derived for non-terminal Select
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Select {
    pub l_bracket: Box<LBracket>,
    pub expression: Box<Expression>,
    pub select_opt: Option<SelectOpt>,
    pub r_bracket: Box<RBracket>,
}

///
/// Type derived for non-terminal SelectOperator
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SelectOperator {
    Colon(SelectOperatorColon),
    PlusColon(SelectOperatorPlusColon),
    MinusColon(SelectOperatorMinusColon),
    Step(SelectOperatorStep),
}

///
/// Type derived for non-terminal SelectOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SelectOpt {
    pub select_operator: Box<SelectOperator>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal Semicolon
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Semicolon {
    pub semicolon_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal SemicolonTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SemicolonTerm {
    pub semicolon_term: crate::veryl_token::Token, /* ; */
}

///
/// Type derived for non-terminal SemicolonToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SemicolonToken {
    pub semicolon_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Signed
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Signed {
    pub signed_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal SignedTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SignedTerm {
    pub signed_term: crate::veryl_token::Token, /* signed */
}

///
/// Type derived for non-terminal SignedToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SignedToken {
    pub signed_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Star
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Star {
    pub star_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal StarTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StarTerm {
    pub star_term: crate::veryl_token::Token, /* * */
}

///
/// Type derived for non-terminal StarToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StarToken {
    pub star_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Start
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Start {
    pub start_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal StartToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StartToken {
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Statement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum Statement {
    IdentifierStatement(StatementIdentifierStatement),
    IfStatement(StatementIfStatement),
    IfResetStatement(StatementIfResetStatement),
    ReturnStatement(StatementReturnStatement),
    BreakStatement(StatementBreakStatement),
    ForStatement(StatementForStatement),
    CaseStatement(StatementCaseStatement),
    SwitchStatement(StatementSwitchStatement),
}

///
/// Type derived for non-terminal StatementBlock
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StatementBlock {
    pub l_brace: Box<LBrace>,
    pub statement_block_list: Vec<StatementBlockList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal StatementBlockGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StatementBlockGroup {
    pub statement_block_group_list: Vec<StatementBlockGroupList>,
    pub statement_block_group_group: Box<StatementBlockGroupGroup>,
}

///
/// Type derived for non-terminal StatementBlockGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StatementBlockGroupGroup {
    LBraceStatementBlockGroupGroupListRBrace(
        StatementBlockGroupGroupLBraceStatementBlockGroupGroupListRBrace,
    ),
    StatementBlockItem(StatementBlockGroupGroupStatementBlockItem),
}

///
/// Type derived for non-terminal StatementBlockGroupGroupList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StatementBlockGroupGroupList {
    pub statement_block_group: Box<StatementBlockGroup>,
}

///
/// Type derived for non-terminal StatementBlockGroupList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StatementBlockGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal StatementBlockItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StatementBlockItem {
    VarDeclaration(StatementBlockItemVarDeclaration),
    LetStatement(StatementBlockItemLetStatement),
    ConstDeclaration(StatementBlockItemConstDeclaration),
    Statement(StatementBlockItemStatement),
}

///
/// Type derived for non-terminal StatementBlockList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StatementBlockList {
    pub statement_block_group: Box<StatementBlockGroup>,
}

///
/// Type derived for non-terminal Step
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Step {
    pub step_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal StepTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StepTerm {
    pub step_term: crate::veryl_token::Token, /* step */
}

///
/// Type derived for non-terminal StepToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StepToken {
    pub step_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Strin
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Strin {
    pub string_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal StringLiteral
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StringLiteral {
    pub string_literal_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal StringLiteralTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StringLiteralTerm {
    pub string_literal_term: crate::veryl_token::Token, /* \u{0022}(?:\\[\u{0022}\\/bfnrt]|u[0-9a-fA-F]{4}|[^\u{0022}\\\u0000-\u001F])*\u{0022} */
}

///
/// Type derived for non-terminal StringLiteralToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StringLiteralToken {
    pub string_literal_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal StringTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StringTerm {
    pub string_term: crate::veryl_token::Token, /* string */
}

///
/// Type derived for non-terminal StringToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StringToken {
    pub string_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Struct
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Struct {
    pub struct_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal StructConstructor
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructConstructor {
    pub quote_l_brace: Box<QuoteLBrace>,
    pub struct_constructor_list: Box<StructConstructorList>,
    pub struct_constructor_opt: Option<StructConstructorOpt>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal StructConstructorItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructConstructorItem {
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal StructConstructorList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructConstructorList {
    pub struct_constructor_item: Box<StructConstructorItem>,
    pub struct_constructor_list_list: Vec<StructConstructorListList>,
    pub struct_constructor_list_opt: Option<StructConstructorListOpt>,
}

///
/// Type derived for non-terminal StructConstructorListList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructConstructorListList {
    pub comma: Box<Comma>,
    pub struct_constructor_item: Box<StructConstructorItem>,
}

///
/// Type derived for non-terminal StructConstructorListOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructConstructorListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal StructConstructorOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructConstructorOpt {
    pub dot_dot: Box<DotDot>,
    pub defaul: Box<Defaul>,
    pub l_paren: Box<LParen>,
    pub expression: Box<Expression>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal StructTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructTerm {
    pub struct_term: crate::veryl_token::Token, /* struct */
}

///
/// Type derived for non-terminal StructToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructToken {
    pub struct_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal StructUnion
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StructUnion {
    Struct(StructUnionStruct),
    Union(StructUnionUnion),
}

///
/// Type derived for non-terminal StructUnionDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructUnionDeclaration {
    pub struct_union: Box<StructUnion>,
    pub identifier: Box<Identifier>,
    pub struct_union_declaration_opt: Option<StructUnionDeclarationOpt>,
    pub l_brace: Box<LBrace>,
    pub struct_union_list: Box<StructUnionList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal StructUnionDeclarationOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructUnionDeclarationOpt {
    pub with_generic_parameter: Box<WithGenericParameter>,
}

///
/// Type derived for non-terminal StructUnionGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructUnionGroup {
    pub struct_union_group_list: Vec<StructUnionGroupList>,
    pub struct_union_group_group: Box<StructUnionGroupGroup>,
}

///
/// Type derived for non-terminal StructUnionGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum StructUnionGroupGroup {
    LBraceStructUnionListRBrace(StructUnionGroupGroupLBraceStructUnionListRBrace),
    StructUnionItem(StructUnionGroupGroupStructUnionItem),
}

///
/// Type derived for non-terminal StructUnionGroupList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructUnionGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal StructUnionItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructUnionItem {
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub scalar_type: Box<ScalarType>,
}

///
/// Type derived for non-terminal StructUnionList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructUnionList {
    pub struct_union_group: Box<StructUnionGroup>,
    pub struct_union_list_list: Vec<StructUnionListList>,
    pub struct_union_list_opt: Option<StructUnionListOpt>,
}

///
/// Type derived for non-terminal StructUnionListList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructUnionListList {
    pub comma: Box<Comma>,
    pub struct_union_group: Box<StructUnionGroup>,
}

///
/// Type derived for non-terminal StructUnionListOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct StructUnionListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal Switch
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Switch {
    pub switch_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal SwitchCondition
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SwitchCondition {
    pub expression: Box<Expression>,
    pub switch_condition_list: Vec<SwitchConditionList>,
}

///
/// Type derived for non-terminal SwitchConditionList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SwitchConditionList {
    pub comma: Box<Comma>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal SwitchExpression
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SwitchExpression {
    pub switch: Box<Switch>,
    pub l_brace: Box<LBrace>,
    pub switch_condition: Box<SwitchCondition>,
    pub colon: Box<Colon>,
    pub expression: Box<Expression>,
    pub comma: Box<Comma>,
    pub switch_expression_list: Vec<SwitchExpressionList>,
    pub defaul: Box<Defaul>,
    pub colon0: Box<Colon>,
    pub expression0: Box<Expression>,
    pub switch_expression_opt: Option<SwitchExpressionOpt>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal SwitchExpressionList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SwitchExpressionList {
    pub switch_condition: Box<SwitchCondition>,
    pub colon: Box<Colon>,
    pub expression: Box<Expression>,
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal SwitchExpressionOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SwitchExpressionOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal SwitchItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SwitchItem {
    pub switch_item_group: Box<SwitchItemGroup>,
    pub colon: Box<Colon>,
    pub switch_item_group0: Box<SwitchItemGroup0>,
}

///
/// Type derived for non-terminal SwitchItemGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SwitchItemGroup {
    SwitchCondition(SwitchItemGroupSwitchCondition),
    Defaul(SwitchItemGroupDefaul),
}

///
/// Type derived for non-terminal SwitchItemGroup0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum SwitchItemGroup0 {
    Statement(SwitchItemGroup0Statement),
    StatementBlock(SwitchItemGroup0StatementBlock),
}

///
/// Type derived for non-terminal SwitchStatement
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SwitchStatement {
    pub switch: Box<Switch>,
    pub l_brace: Box<LBrace>,
    pub switch_statement_list: Vec<SwitchStatementList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal SwitchStatementList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SwitchStatementList {
    pub switch_item: Box<SwitchItem>,
}

///
/// Type derived for non-terminal SwitchTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SwitchTerm {
    pub switch_term: crate::veryl_token::Token, /* switch */
}

///
/// Type derived for non-terminal SwitchToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct SwitchToken {
    pub switch_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Tri
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Tri {
    pub tri_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal TriTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TriTerm {
    pub tri_term: crate::veryl_token::Token, /* tri */
}

///
/// Type derived for non-terminal TriToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TriToken {
    pub tri_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal TripleLBrace
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TripleLBrace {
    pub triple_l_brace_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal TripleLBraceTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TripleLBraceTerm {
    pub triple_l_brace_term: crate::veryl_token::Token, /* {{{ */
}

///
/// Type derived for non-terminal TripleLBraceToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TripleLBraceToken {
    pub triple_l_brace_term: crate::veryl_token::Token,
}

///
/// Type derived for non-terminal TripleRBrace
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TripleRBrace {
    pub triple_r_brace_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal TripleRBraceTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TripleRBraceTerm {
    pub triple_r_brace_term: crate::veryl_token::Token, /* }}} */
}

///
/// Type derived for non-terminal TripleRBraceToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TripleRBraceToken {
    pub triple_r_brace_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal True
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct True {
    pub true_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal TrueTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TrueTerm {
    pub true_term: crate::veryl_token::Token, /* true */
}

///
/// Type derived for non-terminal TrueToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TrueToken {
    pub true_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Type
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Type {
    pub type_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal TypeDefDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TypeDefDeclaration {
    pub r#type: Box<Type>,
    pub identifier: Box<Identifier>,
    pub equ: Box<Equ>,
    pub array_type: Box<ArrayType>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal TypeExpression
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TypeExpression {
    pub r#type: Box<Type>,
    pub l_paren: Box<LParen>,
    pub expression: Box<Expression>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal TypeModifier
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum TypeModifier {
    Tri(TypeModifierTri),
    Signed(TypeModifierSigned),
    Defaul(TypeModifierDefaul),
}

///
/// Type derived for non-terminal TypeTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TypeTerm {
    pub type_term: crate::veryl_token::Token, /* type */
}

///
/// Type derived for non-terminal TypeToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct TypeToken {
    pub type_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal U16
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct U16 {
    pub u16_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal U16Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct U16Term {
    pub u16_term: crate::veryl_token::Token, /* u16 */
}

///
/// Type derived for non-terminal U16Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct U16Token {
    pub u16_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal U32
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct U32 {
    pub u32_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal U32Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct U32Term {
    pub u32_term: crate::veryl_token::Token, /* u32 */
}

///
/// Type derived for non-terminal U32Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct U32Token {
    pub u32_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal U64
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct U64 {
    pub u64_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal U64Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct U64Term {
    pub u64_term: crate::veryl_token::Token, /* u64 */
}

///
/// Type derived for non-terminal U64Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct U64Token {
    pub u64_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal U8
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct U8 {
    pub u8_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal U8Term
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct U8Term {
    pub u8_term: crate::veryl_token::Token, /* u8 */
}

///
/// Type derived for non-terminal U8Token
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct U8Token {
    pub u8_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal UnaryOperator
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct UnaryOperator {
    pub unary_operator_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal UnaryOperatorTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct UnaryOperatorTerm {
    pub unary_operator_term: crate::veryl_token::Token, /* ~&|~\||!|~ */
}

///
/// Type derived for non-terminal UnaryOperatorToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct UnaryOperatorToken {
    pub unary_operator_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Union
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Union {
    pub union_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal UnionTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct UnionTerm {
    pub union_term: crate::veryl_token::Token, /* union */
}

///
/// Type derived for non-terminal UnionToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct UnionToken {
    pub union_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal Unsafe
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Unsafe {
    pub unsafe_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal UnsafeBlock
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct UnsafeBlock {
    pub r#unsafe: Box<Unsafe>,
    pub l_paren: Box<LParen>,
    pub identifier: Box<Identifier>,
    pub r_paren: Box<RParen>,
    pub l_brace: Box<LBrace>,
    pub unsafe_block_list: Vec<UnsafeBlockList>,
    pub r_brace: Box<RBrace>,
}

///
/// Type derived for non-terminal UnsafeBlockList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct UnsafeBlockList {
    pub generate_group: Box<GenerateGroup>,
}

///
/// Type derived for non-terminal UnsafeTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct UnsafeTerm {
    pub unsafe_term: crate::veryl_token::Token, /* unsafe */
}

///
/// Type derived for non-terminal UnsafeToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct UnsafeToken {
    pub unsafe_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal UserDefinedType
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct UserDefinedType {
    pub scoped_identifier: Box<ScopedIdentifier>,
}

///
/// Type derived for non-terminal Var
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Var {
    pub var_token: crate::veryl_token::VerylToken,
}

///
/// Type derived for non-terminal VarDeclaration
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct VarDeclaration {
    pub var: Box<Var>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub var_declaration_opt: Option<VarDeclarationOpt>,
    pub array_type: Box<ArrayType>,
    pub semicolon: Box<Semicolon>,
}

///
/// Type derived for non-terminal VarDeclarationOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct VarDeclarationOpt {
    pub clock_domain: Box<ClockDomain>,
}

///
/// Type derived for non-terminal VarTerm
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct VarTerm {
    pub var_term: crate::veryl_token::Token, /* var */
}

///
/// Type derived for non-terminal VarToken
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct VarToken {
    pub var_term: crate::veryl_token::Token,
    pub comments: Box<Comments>,
}

///
/// Type derived for non-terminal VariableType
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum VariableType {
    Clock(VariableTypeClock),
    ClockPosedge(VariableTypeClockPosedge),
    ClockNegedge(VariableTypeClockNegedge),
    Reset(VariableTypeReset),
    ResetAsyncHigh(VariableTypeResetAsyncHigh),
    ResetAsyncLow(VariableTypeResetAsyncLow),
    ResetSyncHigh(VariableTypeResetSyncHigh),
    ResetSyncLow(VariableTypeResetSyncLow),
    Logic(VariableTypeLogic),
    Bit(VariableTypeBit),
}

///
/// Type derived for non-terminal Veryl
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Veryl {
    pub start: Box<Start>,
    pub veryl_list: Vec<VerylList>,
}

///
/// Type derived for non-terminal VerylList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct VerylList {
    pub description_group: Box<DescriptionGroup>,
}

///
/// Type derived for non-terminal Width
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct Width {
    pub l_angle: Box<LAngle>,
    pub expression: Box<Expression>,
    pub width_list: Vec<WidthList>,
    pub r_angle: Box<RAngle>,
}

///
/// Type derived for non-terminal WidthList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WidthList {
    pub comma: Box<Comma>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal WithGenericArgument
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithGenericArgument {
    pub colon_colon_l_angle: Box<ColonColonLAngle>,
    pub with_generic_argument_opt: Option<WithGenericArgumentOpt>,
    pub r_angle: Box<RAngle>,
}

///
/// Type derived for non-terminal WithGenericArgumentItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum WithGenericArgumentItem {
    GenericArgIdentifier(WithGenericArgumentItemGenericArgIdentifier),
    FixedType(WithGenericArgumentItemFixedType),
    Number(WithGenericArgumentItemNumber),
    BooleanLiteral(WithGenericArgumentItemBooleanLiteral),
}

///
/// Type derived for non-terminal WithGenericArgumentList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithGenericArgumentList {
    pub with_generic_argument_item: Box<WithGenericArgumentItem>,
    pub with_generic_argument_list_list: Vec<WithGenericArgumentListList>,
    pub with_generic_argument_list_opt: Option<WithGenericArgumentListOpt>,
}

///
/// Type derived for non-terminal WithGenericArgumentListList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithGenericArgumentListList {
    pub comma: Box<Comma>,
    pub with_generic_argument_item: Box<WithGenericArgumentItem>,
}

///
/// Type derived for non-terminal WithGenericArgumentListOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithGenericArgumentListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal WithGenericArgumentOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithGenericArgumentOpt {
    pub with_generic_argument_list: Box<WithGenericArgumentList>,
}

///
/// Type derived for non-terminal WithGenericParameter
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithGenericParameter {
    pub colon_colon_l_angle: Box<ColonColonLAngle>,
    pub with_generic_parameter_list: Box<WithGenericParameterList>,
    pub r_angle: Box<RAngle>,
}

///
/// Type derived for non-terminal WithGenericParameterItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithGenericParameterItem {
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub generic_bound: Box<GenericBound>,
    pub with_generic_parameter_item_opt: Option<WithGenericParameterItemOpt>,
}

///
/// Type derived for non-terminal WithGenericParameterItemOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithGenericParameterItemOpt {
    pub equ: Box<Equ>,
    pub with_generic_argument_item: Box<WithGenericArgumentItem>,
}

///
/// Type derived for non-terminal WithGenericParameterList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithGenericParameterList {
    pub with_generic_parameter_item: Box<WithGenericParameterItem>,
    pub with_generic_parameter_list_list: Vec<WithGenericParameterListList>,
    pub with_generic_parameter_list_opt: Option<WithGenericParameterListOpt>,
}

///
/// Type derived for non-terminal WithGenericParameterListList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithGenericParameterListList {
    pub comma: Box<Comma>,
    pub with_generic_parameter_item: Box<WithGenericParameterItem>,
}

///
/// Type derived for non-terminal WithGenericParameterListOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithGenericParameterListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal WithParameter
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithParameter {
    pub hash: Box<Hash>,
    pub l_paren: Box<LParen>,
    pub with_parameter_opt: Option<WithParameterOpt>,
    pub r_paren: Box<RParen>,
}

///
/// Type derived for non-terminal WithParameterGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithParameterGroup {
    pub with_parameter_group_list: Vec<WithParameterGroupList>,
    pub with_parameter_group_group: Box<WithParameterGroupGroup>,
}

///
/// Type derived for non-terminal WithParameterGroupGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum WithParameterGroupGroup {
    LBraceWithParameterListRBrace(WithParameterGroupGroupLBraceWithParameterListRBrace),
    WithParameterItem(WithParameterGroupGroupWithParameterItem),
}

///
/// Type derived for non-terminal WithParameterGroupList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithParameterGroupList {
    pub attribute: Box<Attribute>,
}

///
/// Type derived for non-terminal WithParameterItem
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithParameterItem {
    pub with_parameter_item_group: Box<WithParameterItemGroup>,
    pub identifier: Box<Identifier>,
    pub colon: Box<Colon>,
    pub with_parameter_item_group0: Box<WithParameterItemGroup0>,
    pub with_parameter_item_opt: Option<WithParameterItemOpt>,
}

///
/// Type derived for non-terminal WithParameterItemGroup
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum WithParameterItemGroup {
    Param(WithParameterItemGroupParam),
    Const(WithParameterItemGroupConst),
}

///
/// Type derived for non-terminal WithParameterItemGroup0
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum WithParameterItemGroup0 {
    ArrayType(WithParameterItemGroup0ArrayType),
    Type(WithParameterItemGroup0Type),
}

///
/// Type derived for non-terminal WithParameterItemOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithParameterItemOpt {
    pub equ: Box<Equ>,
    pub expression: Box<Expression>,
}

///
/// Type derived for non-terminal WithParameterList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithParameterList {
    pub with_parameter_group: Box<WithParameterGroup>,
    pub with_parameter_list_list: Vec<WithParameterListList>,
    pub with_parameter_list_opt: Option<WithParameterListOpt>,
}

///
/// Type derived for non-terminal WithParameterListList
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithParameterListList {
    pub comma: Box<Comma>,
    pub with_parameter_group: Box<WithParameterGroup>,
}

///
/// Type derived for non-terminal WithParameterListOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithParameterListOpt {
    pub comma: Box<Comma>,
}

///
/// Type derived for non-terminal WithParameterOpt
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub struct WithParameterOpt {
    pub with_parameter_list: Box<WithParameterList>,
}

// -------------------------------------------------------------------------------------------------

///
/// Deduced ASTType of expanded grammar
///
#[allow(dead_code)]
#[derive(Debug, Clone)]
pub enum ASTType {
    Alias(Alias),
    AliasDeclaration(AliasDeclaration),
    AliasDeclarationGroup(AliasDeclarationGroup),
    AliasTerm(AliasTerm),
    AliasToken(AliasToken),
    AllBit(AllBit),
    AllBitTerm(AllBitTerm),
    AllBitToken(AllBitToken),
    AlwaysComb(AlwaysComb),
    AlwaysCombDeclaration(AlwaysCombDeclaration),
    AlwaysCombTerm(AlwaysCombTerm),
    AlwaysCombToken(AlwaysCombToken),
    AlwaysFf(AlwaysFf),
    AlwaysFfClock(AlwaysFfClock),
    AlwaysFfDeclaration(AlwaysFfDeclaration),
    AlwaysFfDeclarationOpt(Option<AlwaysFfDeclarationOpt>),
    AlwaysFfEventList(AlwaysFfEventList),
    AlwaysFfEventListOpt(Option<AlwaysFfEventListOpt>),
    AlwaysFfReset(AlwaysFfReset),
    AlwaysFfTerm(AlwaysFfTerm),
    AlwaysFfToken(AlwaysFfToken),
    Any(Any),
    AnyTerm(AnyTerm),
    AnyToken(AnyToken),
    ArgumentExpression(ArgumentExpression),
    ArgumentItem(ArgumentItem),
    ArgumentItemOpt(Option<ArgumentItemOpt>),
    ArgumentList(ArgumentList),
    ArgumentListList(Vec<ArgumentListList>),
    ArgumentListOpt(Option<ArgumentListOpt>),
    Array(Array),
    ArrayList(Vec<ArrayList>),
    ArrayLiteralItem(ArrayLiteralItem),
    ArrayLiteralItemGroup(ArrayLiteralItemGroup),
    ArrayLiteralItemOpt(Option<ArrayLiteralItemOpt>),
    ArrayLiteralList(ArrayLiteralList),
    ArrayLiteralListList(Vec<ArrayLiteralListList>),
    ArrayLiteralListOpt(Option<ArrayLiteralListOpt>),
    ArrayType(ArrayType),
    ArrayTypeOpt(Option<ArrayTypeOpt>),
    As(As),
    AsTerm(AsTerm),
    AsToken(AsToken),
    Assign(Assign),
    AssignConcatenationItem(AssignConcatenationItem),
    AssignConcatenationList(AssignConcatenationList),
    AssignConcatenationListList(Vec<AssignConcatenationListList>),
    AssignConcatenationListOpt(Option<AssignConcatenationListOpt>),
    AssignDeclaration(AssignDeclaration),
    AssignDestination(AssignDestination),
    AssignTerm(AssignTerm),
    AssignToken(AssignToken),
    Assignment(Assignment),
    AssignmentGroup(AssignmentGroup),
    AssignmentOperator(AssignmentOperator),
    AssignmentOperatorTerm(AssignmentOperatorTerm),
    AssignmentOperatorToken(AssignmentOperatorToken),
    Attribute(Attribute),
    AttributeItem(AttributeItem),
    AttributeList(AttributeList),
    AttributeListList(Vec<AttributeListList>),
    AttributeListOpt(Option<AttributeListOpt>),
    AttributeOpt(Option<AttributeOpt>),
    BaseLess(BaseLess),
    BaseLessTerm(BaseLessTerm),
    BaseLessToken(BaseLessToken),
    Based(Based),
    BasedTerm(BasedTerm),
    BasedToken(BasedToken),
    Bind(Bind),
    BindDeclaration(BindDeclaration),
    BindTerm(BindTerm),
    BindToken(BindToken),
    Bit(Bit),
    BitTerm(BitTerm),
    BitToken(BitToken),
    Bool(Bool),
    BoolTerm(BoolTerm),
    BoolToken(BoolToken),
    BooleanLiteral(BooleanLiteral),
    Break(Break),
    BreakStatement(BreakStatement),
    BreakTerm(BreakTerm),
    BreakToken(BreakToken),
    Case(Case),
    CaseCondition(CaseCondition),
    CaseConditionList(Vec<CaseConditionList>),
    CaseExpression(CaseExpression),
    CaseExpressionList(Vec<CaseExpressionList>),
    CaseExpressionOpt(Option<CaseExpressionOpt>),
    CaseItem(CaseItem),
    CaseItemGroup(CaseItemGroup),
    CaseItemGroup0(CaseItemGroup0),
    CaseStatement(CaseStatement),
    CaseStatementList(Vec<CaseStatementList>),
    CaseTerm(CaseTerm),
    CaseToken(CaseToken),
    CastingType(CastingType),
    Clock(Clock),
    ClockDomain(ClockDomain),
    ClockNegedge(ClockNegedge),
    ClockNegedgeTerm(ClockNegedgeTerm),
    ClockNegedgeToken(ClockNegedgeToken),
    ClockPosedge(ClockPosedge),
    ClockPosedgeTerm(ClockPosedgeTerm),
    ClockPosedgeToken(ClockPosedgeToken),
    ClockTerm(ClockTerm),
    ClockToken(ClockToken),
    Colon(Colon),
    ColonColon(ColonColon),
    ColonColonLAngle(ColonColonLAngle),
    ColonColonLAngleTerm(ColonColonLAngleTerm),
    ColonColonLAngleToken(ColonColonLAngleToken),
    ColonColonTerm(ColonColonTerm),
    ColonColonToken(ColonColonToken),
    ColonTerm(ColonTerm),
    ColonToken(ColonToken),
    Comma(Comma),
    CommaTerm(CommaTerm),
    CommaToken(CommaToken),
    Comments(Comments),
    CommentsOpt(Option<CommentsOpt>),
    CommentsTerm(CommentsTerm),
    ComponentInstantiation(ComponentInstantiation),
    ComponentInstantiationOpt(Option<ComponentInstantiationOpt>),
    ComponentInstantiationOpt0(Option<ComponentInstantiationOpt0>),
    ComponentInstantiationOpt1(Option<ComponentInstantiationOpt1>),
    ComponentInstantiationOpt2(Option<ComponentInstantiationOpt2>),
    ConcatenationItem(ConcatenationItem),
    ConcatenationItemOpt(Option<ConcatenationItemOpt>),
    ConcatenationList(ConcatenationList),
    ConcatenationListList(Vec<ConcatenationListList>),
    ConcatenationListOpt(Option<ConcatenationListOpt>),
    Connect(Connect),
    ConnectDeclaration(ConnectDeclaration),
    ConnectTerm(ConnectTerm),
    ConnectToken(ConnectToken),
    Const(Const),
    ConstDeclaration(ConstDeclaration),
    ConstDeclarationGroup(ConstDeclarationGroup),
    ConstTerm(ConstTerm),
    ConstToken(ConstToken),
    Converse(Converse),
    ConverseTerm(ConverseTerm),
    ConverseToken(ConverseToken),
    Defaul(Defaul),
    DefaultTerm(DefaultTerm),
    DefaultToken(DefaultToken),
    DescriptionGroup(DescriptionGroup),
    DescriptionGroupGroup(DescriptionGroupGroup),
    DescriptionGroupGroupList(Vec<DescriptionGroupGroupList>),
    DescriptionGroupList(Vec<DescriptionGroupList>),
    DescriptionItem(DescriptionItem),
    DescriptionItemOpt(Option<DescriptionItemOpt>),
    DiamondOperator(DiamondOperator),
    DiamondOperatorTerm(DiamondOperatorTerm),
    DiamondOperatorToken(DiamondOperatorToken),
    Direction(Direction),
    DollarIdentifier(DollarIdentifier),
    DollarIdentifierTerm(DollarIdentifierTerm),
    DollarIdentifierToken(DollarIdentifierToken),
    Dot(Dot),
    DotDot(DotDot),
    DotDotEqu(DotDotEqu),
    DotDotEquTerm(DotDotEquTerm),
    DotDotEquToken(DotDotEquToken),
    DotDotTerm(DotDotTerm),
    DotDotToken(DotDotToken),
    DotTerm(DotTerm),
    DotToken(DotToken),
    Else(Else),
    ElseTerm(ElseTerm),
    ElseToken(ElseToken),
    Embed(Embed),
    EmbedContent(EmbedContent),
    EmbedContentList(Vec<EmbedContentList>),
    EmbedDeclaration(EmbedDeclaration),
    EmbedItem(EmbedItem),
    EmbedItemList(Vec<EmbedItemList>),
    EmbedLBrace(EmbedLBrace),
    EmbedLBraceToken(EmbedLBraceToken),
    EmbedRBrace(EmbedRBrace),
    EmbedRBraceToken(EmbedRBraceToken),
    EmbedScopedIdentifier(EmbedScopedIdentifier),
    EmbedTerm(EmbedTerm),
    EmbedToken(EmbedToken),
    Enum(Enum),
    EnumDeclaration(EnumDeclaration),
    EnumDeclarationOpt(Option<EnumDeclarationOpt>),
    EnumGroup(EnumGroup),
    EnumGroupGroup(EnumGroupGroup),
    EnumGroupList(Vec<EnumGroupList>),
    EnumItem(EnumItem),
    EnumItemOpt(Option<EnumItemOpt>),
    EnumList(EnumList),
    EnumListList(Vec<EnumListList>),
    EnumListOpt(Option<EnumListOpt>),
    EnumTerm(EnumTerm),
    EnumToken(EnumToken),
    Equ(Equ),
    EquTerm(EquTerm),
    EquToken(EquToken),
    EscapedLBrace(EscapedLBrace),
    EscapedLBraceTerm(EscapedLBraceTerm),
    EscapedLBraceToken(EscapedLBraceToken),
    EscapedRBrace(EscapedRBrace),
    EscapedRBraceTerm(EscapedRBraceTerm),
    EscapedRBraceToken(EscapedRBraceToken),
    Exponent(Exponent),
    ExponentTerm(ExponentTerm),
    ExponentToken(ExponentToken),
    Expression(Expression),
    Expression01(Expression01),
    Expression01List(Vec<Expression01List>),
    Expression02(Expression02),
    Expression02List(Vec<Expression02List>),
    Expression03(Expression03),
    Expression03List(Vec<Expression03List>),
    Expression04(Expression04),
    Expression04List(Vec<Expression04List>),
    Expression05(Expression05),
    Expression05List(Vec<Expression05List>),
    Expression06(Expression06),
    Expression06List(Vec<Expression06List>),
    Expression07(Expression07),
    Expression07List(Vec<Expression07List>),
    Expression08(Expression08),
    Expression08List(Vec<Expression08List>),
    Expression09(Expression09),
    Expression09List(Vec<Expression09List>),
    Expression10(Expression10),
    Expression10List(Vec<Expression10List>),
    Expression10ListGroup(Expression10ListGroup),
    Expression11(Expression11),
    Expression11List(Vec<Expression11List>),
    Expression12(Expression12),
    Expression12Opt(Option<Expression12Opt>),
    Expression13(Expression13),
    Expression13List(Vec<Expression13List>),
    Expression13ListGroup(Expression13ListGroup),
    ExpressionIdentifier(ExpressionIdentifier),
    ExpressionIdentifierList(Vec<ExpressionIdentifierList>),
    ExpressionIdentifierList0(Vec<ExpressionIdentifierList0>),
    ExpressionIdentifierList0List(Vec<ExpressionIdentifierList0List>),
    ExpressionIdentifierOpt(Option<ExpressionIdentifierOpt>),
    F32(F32),
    F32Term(F32Term),
    F32Token(F32Token),
    F64(F64),
    F64Term(F64Term),
    F64Token(F64Token),
    Factor(Factor),
    FactorGroup(FactorGroup),
    FactorType(FactorType),
    FactorTypeFactor(FactorTypeFactor),
    FactorTypeFactorList(Vec<FactorTypeFactorList>),
    FactorTypeGroup(FactorTypeGroup),
    FactorTypeOpt(Option<FactorTypeOpt>),
    False(False),
    FalseTerm(FalseTerm),
    FalseToken(FalseToken),
    Final(Final),
    FinalDeclaration(FinalDeclaration),
    FinalTerm(FinalTerm),
    FinalToken(FinalToken),
    FixedPoint(FixedPoint),
    FixedPointTerm(FixedPointTerm),
    FixedPointToken(FixedPointToken),
    FixedType(FixedType),
    For(For),
    ForStatement(ForStatement),
    ForStatementOpt(Option<ForStatementOpt>),
    ForStatementOpt0(Option<ForStatementOpt0>),
    ForTerm(ForTerm),
    ForToken(ForToken),
    Function(Function),
    FunctionCall(FunctionCall),
    FunctionCallOpt(Option<FunctionCallOpt>),
    FunctionDeclaration(FunctionDeclaration),
    FunctionDeclarationOpt(Option<FunctionDeclarationOpt>),
    FunctionDeclarationOpt0(Option<FunctionDeclarationOpt0>),
    FunctionDeclarationOpt1(Option<FunctionDeclarationOpt1>),
    FunctionTerm(FunctionTerm),
    FunctionToken(FunctionToken),
    GenerateBlockDeclaration(GenerateBlockDeclaration),
    GenerateForDeclaration(GenerateForDeclaration),
    GenerateForDeclarationOpt(Option<GenerateForDeclarationOpt>),
    GenerateForDeclarationOpt0(Option<GenerateForDeclarationOpt0>),
    GenerateGroup(GenerateGroup),
    GenerateGroupGroup(GenerateGroupGroup),
    GenerateGroupGroupList(Vec<GenerateGroupGroupList>),
    GenerateGroupList(Vec<GenerateGroupList>),
    GenerateIfDeclaration(GenerateIfDeclaration),
    GenerateIfDeclarationList(Vec<GenerateIfDeclarationList>),
    GenerateIfDeclarationOpt(Option<GenerateIfDeclarationOpt>),
    GenerateItem(GenerateItem),
    GenerateNamedBlock(GenerateNamedBlock),
    GenerateNamedBlockList(Vec<GenerateNamedBlockList>),
    GenerateOptionalNamedBlock(GenerateOptionalNamedBlock),
    GenerateOptionalNamedBlockList(Vec<GenerateOptionalNamedBlockList>),
    GenerateOptionalNamedBlockOpt(Option<GenerateOptionalNamedBlockOpt>),
    GenericArgIdentifier(GenericArgIdentifier),
    GenericArgIdentifierList(Vec<GenericArgIdentifierList>),
    GenericBound(GenericBound),
    GenericProtoBound(GenericProtoBound),
    Hash(Hash),
    HashLBracket(HashLBracket),
    HashLBracketTerm(HashLBracketTerm),
    HashLBracketToken(HashLBracketToken),
    HashTerm(HashTerm),
    HashToken(HashToken),
    HierarchicalIdentifier(HierarchicalIdentifier),
    HierarchicalIdentifierList(Vec<HierarchicalIdentifierList>),
    HierarchicalIdentifierList0(Vec<HierarchicalIdentifierList0>),
    HierarchicalIdentifierList0List(Vec<HierarchicalIdentifierList0List>),
    I16(I16),
    I16Term(I16Term),
    I16Token(I16Token),
    I32(I32),
    I32Term(I32Term),
    I32Token(I32Token),
    I64(I64),
    I64Term(I64Term),
    I64Token(I64Token),
    I8(I8),
    I8Term(I8Term),
    I8Token(I8Token),
    Identifier(Identifier),
    IdentifierFactor(IdentifierFactor),
    IdentifierFactorOpt(Option<IdentifierFactorOpt>),
    IdentifierFactorOptGroup(IdentifierFactorOptGroup),
    IdentifierStatement(IdentifierStatement),
    IdentifierStatementGroup(IdentifierStatementGroup),
    IdentifierTerm(IdentifierTerm),
    IdentifierToken(IdentifierToken),
    If(If),
    IfExpression(IfExpression),
    IfExpressionList(Vec<IfExpressionList>),
    IfReset(IfReset),
    IfResetStatement(IfResetStatement),
    IfResetStatementList(Vec<IfResetStatementList>),
    IfResetStatementOpt(Option<IfResetStatementOpt>),
    IfResetTerm(IfResetTerm),
    IfResetToken(IfResetToken),
    IfStatement(IfStatement),
    IfStatementList(Vec<IfStatementList>),
    IfStatementOpt(Option<IfStatementOpt>),
    IfTerm(IfTerm),
    IfToken(IfToken),
    Import(Import),
    ImportDeclaration(ImportDeclaration),
    ImportDeclarationOpt(Option<ImportDeclarationOpt>),
    ImportTerm(ImportTerm),
    ImportToken(ImportToken),
    In(In),
    InTerm(InTerm),
    InToken(InToken),
    Include(Include),
    IncludeDeclaration(IncludeDeclaration),
    IncludeTerm(IncludeTerm),
    IncludeToken(IncludeToken),
    Initial(Initial),
    InitialDeclaration(InitialDeclaration),
    InitialTerm(InitialTerm),
    InitialToken(InitialToken),
    Inout(Inout),
    InoutTerm(InoutTerm),
    InoutToken(InoutToken),
    Input(Input),
    InputTerm(InputTerm),
    InputToken(InputToken),
    Inside(Inside),
    InsideExpression(InsideExpression),
    InsideTerm(InsideTerm),
    InsideToken(InsideToken),
    Inst(Inst),
    InstDeclaration(InstDeclaration),
    InstParameter(InstParameter),
    InstParameterGroup(InstParameterGroup),
    InstParameterGroupGroup(InstParameterGroupGroup),
    InstParameterGroupList(Vec<InstParameterGroupList>),
    InstParameterItem(InstParameterItem),
    InstParameterItemOpt(Option<InstParameterItemOpt>),
    InstParameterList(InstParameterList),
    InstParameterListList(Vec<InstParameterListList>),
    InstParameterListOpt(Option<InstParameterListOpt>),
    InstParameterOpt(Option<InstParameterOpt>),
    InstPort(InstPort),
    InstPortGroup(InstPortGroup),
    InstPortGroupGroup(InstPortGroupGroup),
    InstPortGroupList(Vec<InstPortGroupList>),
    InstPortItem(InstPortItem),
    InstPortItemOpt(Option<InstPortItemOpt>),
    InstPortList(InstPortList),
    InstPortListList(Vec<InstPortListList>),
    InstPortListOpt(Option<InstPortListOpt>),
    InstPortOpt(Option<InstPortOpt>),
    InstTerm(InstTerm),
    InstToken(InstToken),
    IntegralNumber(IntegralNumber),
    Interface(Interface),
    InterfaceDeclaration(InterfaceDeclaration),
    InterfaceDeclarationList(Vec<InterfaceDeclarationList>),
    InterfaceDeclarationOpt(Option<InterfaceDeclarationOpt>),
    InterfaceDeclarationOpt0(Option<InterfaceDeclarationOpt0>),
    InterfaceDeclarationOpt1(Option<InterfaceDeclarationOpt1>),
    InterfaceGroup(InterfaceGroup),
    InterfaceGroupGroup(InterfaceGroupGroup),
    InterfaceGroupGroupList(Vec<InterfaceGroupGroupList>),
    InterfaceGroupList(Vec<InterfaceGroupList>),
    InterfaceItem(InterfaceItem),
    InterfaceTerm(InterfaceTerm),
    InterfaceToken(InterfaceToken),
    LAngle(LAngle),
    LAngleTerm(LAngleTerm),
    LAngleToken(LAngleToken),
    LBrace(LBrace),
    LBraceTerm(LBraceTerm),
    LBraceToken(LBraceToken),
    LBracket(LBracket),
    LBracketTerm(LBracketTerm),
    LBracketToken(LBracketToken),
    LParen(LParen),
    LParenTerm(LParenTerm),
    LParenToken(LParenToken),
    LTMinus(LTMinus),
    LTMinusTerm(LTMinusTerm),
    LTMinusToken(LTMinusToken),
    Let(Let),
    LetDeclaration(LetDeclaration),
    LetDeclarationOpt(Option<LetDeclarationOpt>),
    LetStatement(LetStatement),
    LetStatementOpt(Option<LetStatementOpt>),
    LetTerm(LetTerm),
    LetToken(LetToken),
    Logic(Logic),
    LogicTerm(LogicTerm),
    LogicToken(LogicToken),
    Lsb(Lsb),
    LsbTerm(LsbTerm),
    LsbToken(LsbToken),
    MinusColon(MinusColon),
    MinusColonTerm(MinusColonTerm),
    MinusColonToken(MinusColonToken),
    MinusGT(MinusGT),
    MinusGTTerm(MinusGTTerm),
    MinusGTToken(MinusGTToken),
    Modport(Modport),
    ModportDeclaration(ModportDeclaration),
    ModportDeclarationOpt(Option<ModportDeclarationOpt>),
    ModportDeclarationOpt0(Option<ModportDeclarationOpt0>),
    ModportDefault(ModportDefault),
    ModportGroup(ModportGroup),
    ModportGroupGroup(ModportGroupGroup),
    ModportGroupList(Vec<ModportGroupList>),
    ModportItem(ModportItem),
    ModportList(ModportList),
    ModportListList(Vec<ModportListList>),
    ModportListOpt(Option<ModportListOpt>),
    ModportTerm(ModportTerm),
    ModportToken(ModportToken),
    Module(Module),
    ModuleDeclaration(ModuleDeclaration),
    ModuleDeclarationList(Vec<ModuleDeclarationList>),
    ModuleDeclarationOpt(Option<ModuleDeclarationOpt>),
    ModuleDeclarationOpt0(Option<ModuleDeclarationOpt0>),
    ModuleDeclarationOpt1(Option<ModuleDeclarationOpt1>),
    ModuleDeclarationOpt2(Option<ModuleDeclarationOpt2>),
    ModuleGroup(ModuleGroup),
    ModuleGroupGroup(ModuleGroupGroup),
    ModuleGroupGroupList(Vec<ModuleGroupGroupList>),
    ModuleGroupList(Vec<ModuleGroupList>),
    ModuleItem(ModuleItem),
    ModuleTerm(ModuleTerm),
    ModuleToken(ModuleToken),
    Msb(Msb),
    MsbTerm(MsbTerm),
    MsbToken(MsbToken),
    Number(Number),
    Operator02(Operator02),
    Operator02Term(Operator02Term),
    Operator02Token(Operator02Token),
    Operator03(Operator03),
    Operator03Term(Operator03Term),
    Operator03Token(Operator03Token),
    Operator04(Operator04),
    Operator04Term(Operator04Term),
    Operator04Token(Operator04Token),
    Operator05(Operator05),
    Operator05Term(Operator05Term),
    Operator05Token(Operator05Token),
    Operator06(Operator06),
    Operator06Term(Operator06Term),
    Operator06Token(Operator06Token),
    Operator07(Operator07),
    Operator07Term(Operator07Term),
    Operator07Token(Operator07Token),
    Operator08(Operator08),
    Operator08Term(Operator08Term),
    Operator08Token(Operator08Token),
    Operator09(Operator09),
    Operator09Term(Operator09Term),
    Operator09Token(Operator09Token),
    Operator10(Operator10),
    Operator10Term(Operator10Term),
    Operator10Token(Operator10Token),
    Operator11(Operator11),
    Operator11Term(Operator11Term),
    Operator11Token(Operator11Token),
    Operator12(Operator12),
    Operator12Term(Operator12Term),
    Operator12Token(Operator12Token),
    Output(Output),
    OutputTerm(OutputTerm),
    OutputToken(OutputToken),
    Outside(Outside),
    OutsideExpression(OutsideExpression),
    OutsideTerm(OutsideTerm),
    OutsideToken(OutsideToken),
    Package(Package),
    PackageDeclaration(PackageDeclaration),
    PackageDeclarationList(Vec<PackageDeclarationList>),
    PackageDeclarationOpt(Option<PackageDeclarationOpt>),
    PackageDeclarationOpt0(Option<PackageDeclarationOpt0>),
    PackageGroup(PackageGroup),
    PackageGroupGroup(PackageGroupGroup),
    PackageGroupGroupList(Vec<PackageGroupGroupList>),
    PackageGroupList(Vec<PackageGroupList>),
    PackageItem(PackageItem),
    PackageTerm(PackageTerm),
    PackageToken(PackageToken),
    Param(Param),
    ParamTerm(ParamTerm),
    ParamToken(ParamToken),
    PlusColon(PlusColon),
    PlusColonTerm(PlusColonTerm),
    PlusColonToken(PlusColonToken),
    PortDeclaration(PortDeclaration),
    PortDeclarationGroup(PortDeclarationGroup),
    PortDeclarationGroupGroup(PortDeclarationGroupGroup),
    PortDeclarationGroupList(Vec<PortDeclarationGroupList>),
    PortDeclarationItem(PortDeclarationItem),
    PortDeclarationItemGroup(PortDeclarationItemGroup),
    PortDeclarationList(PortDeclarationList),
    PortDeclarationListList(Vec<PortDeclarationListList>),
    PortDeclarationListOpt(Option<PortDeclarationListOpt>),
    PortDeclarationOpt(Option<PortDeclarationOpt>),
    PortDefaultValue(PortDefaultValue),
    PortTypeAbstract(PortTypeAbstract),
    PortTypeAbstractOpt(Option<PortTypeAbstractOpt>),
    PortTypeAbstractOpt0(Option<PortTypeAbstractOpt0>),
    PortTypeAbstractOpt1(Option<PortTypeAbstractOpt1>),
    PortTypeConcrete(PortTypeConcrete),
    PortTypeConcreteOpt(Option<PortTypeConcreteOpt>),
    PortTypeConcreteOpt0(Option<PortTypeConcreteOpt0>),
    Proto(Proto),
    ProtoAliasDeclaration(ProtoAliasDeclaration),
    ProtoAliasDeclarationGroup(ProtoAliasDeclarationGroup),
    ProtoConstDeclaration(ProtoConstDeclaration),
    ProtoConstDeclarationGroup(ProtoConstDeclarationGroup),
    ProtoDeclaration(ProtoDeclaration),
    ProtoDeclarationGroup(ProtoDeclarationGroup),
    ProtoFunctionDeclaration(ProtoFunctionDeclaration),
    ProtoFunctionDeclarationOpt(Option<ProtoFunctionDeclarationOpt>),
    ProtoFunctionDeclarationOpt0(Option<ProtoFunctionDeclarationOpt0>),
    ProtoFunctionDeclarationOpt1(Option<ProtoFunctionDeclarationOpt1>),
    ProtoInterfaceDeclaration(ProtoInterfaceDeclaration),
    ProtoInterfaceDeclarationList(Vec<ProtoInterfaceDeclarationList>),
    ProtoInterfaceDeclarationOpt(Option<ProtoInterfaceDeclarationOpt>),
    ProtoInterfaceItem(ProtoInterfaceItem),
    ProtoModuleDeclaration(ProtoModuleDeclaration),
    ProtoModuleDeclarationOpt(Option<ProtoModuleDeclarationOpt>),
    ProtoModuleDeclarationOpt0(Option<ProtoModuleDeclarationOpt0>),
    ProtoPacakgeItem(ProtoPacakgeItem),
    ProtoPackageDeclaration(ProtoPackageDeclaration),
    ProtoPackageDeclarationList(Vec<ProtoPackageDeclarationList>),
    ProtoTerm(ProtoTerm),
    ProtoToken(ProtoToken),
    ProtoTypeDefDeclaration(ProtoTypeDefDeclaration),
    ProtoTypeDefDeclarationOpt(Option<ProtoTypeDefDeclarationOpt>),
    Pub(Pub),
    PubTerm(PubTerm),
    PubToken(PubToken),
    PublicDescriptionItem(PublicDescriptionItem),
    Question(Question),
    QuestionTerm(QuestionTerm),
    QuestionToken(QuestionToken),
    Quote(Quote),
    QuoteLBrace(QuoteLBrace),
    QuoteLBraceTerm(QuoteLBraceTerm),
    QuoteLBraceToken(QuoteLBraceToken),
    QuoteTerm(QuoteTerm),
    QuoteToken(QuoteToken),
    RAngle(RAngle),
    RAngleTerm(RAngleTerm),
    RAngleToken(RAngleToken),
    RBrace(RBrace),
    RBraceTerm(RBraceTerm),
    RBraceToken(RBraceToken),
    RBracket(RBracket),
    RBracketTerm(RBracketTerm),
    RBracketToken(RBracketToken),
    RParen(RParen),
    RParenTerm(RParenTerm),
    RParenToken(RParenToken),
    Range(Range),
    RangeItem(RangeItem),
    RangeList(RangeList),
    RangeListList(Vec<RangeListList>),
    RangeListOpt(Option<RangeListOpt>),
    RangeOperator(RangeOperator),
    RangeOpt(Option<RangeOpt>),
    RealNumber(RealNumber),
    Repeat(Repeat),
    RepeatTerm(RepeatTerm),
    RepeatToken(RepeatToken),
    Reset(Reset),
    ResetAsyncHigh(ResetAsyncHigh),
    ResetAsyncHighTerm(ResetAsyncHighTerm),
    ResetAsyncHighToken(ResetAsyncHighToken),
    ResetAsyncLow(ResetAsyncLow),
    ResetAsyncLowTerm(ResetAsyncLowTerm),
    ResetAsyncLowToken(ResetAsyncLowToken),
    ResetSyncHigh(ResetSyncHigh),
    ResetSyncHighTerm(ResetSyncHighTerm),
    ResetSyncHighToken(ResetSyncHighToken),
    ResetSyncLow(ResetSyncLow),
    ResetSyncLowTerm(ResetSyncLowTerm),
    ResetSyncLowToken(ResetSyncLowToken),
    ResetTerm(ResetTerm),
    ResetToken(ResetToken),
    Return(Return),
    ReturnStatement(ReturnStatement),
    ReturnTerm(ReturnTerm),
    ReturnToken(ReturnToken),
    Rev(Rev),
    RevTerm(RevTerm),
    RevToken(RevToken),
    Same(Same),
    SameTerm(SameTerm),
    SameToken(SameToken),
    ScalarType(ScalarType),
    ScalarTypeGroup(ScalarTypeGroup),
    ScalarTypeList(Vec<ScalarTypeList>),
    ScalarTypeOpt(Option<ScalarTypeOpt>),
    ScopedIdentifier(ScopedIdentifier),
    ScopedIdentifierGroup(ScopedIdentifierGroup),
    ScopedIdentifierList(Vec<ScopedIdentifierList>),
    ScopedIdentifierOpt(Option<ScopedIdentifierOpt>),
    ScopedIdentifierOpt0(Option<ScopedIdentifierOpt0>),
    Select(Select),
    SelectOperator(SelectOperator),
    SelectOpt(Option<SelectOpt>),
    Semicolon(Semicolon),
    SemicolonTerm(SemicolonTerm),
    SemicolonToken(SemicolonToken),
    Signed(Signed),
    SignedTerm(SignedTerm),
    SignedToken(SignedToken),
    Star(Star),
    StarTerm(StarTerm),
    StarToken(StarToken),
    Start(Start),
    StartToken(StartToken),
    Statement(Statement),
    StatementBlock(StatementBlock),
    StatementBlockGroup(StatementBlockGroup),
    StatementBlockGroupGroup(StatementBlockGroupGroup),
    StatementBlockGroupGroupList(Vec<StatementBlockGroupGroupList>),
    StatementBlockGroupList(Vec<StatementBlockGroupList>),
    StatementBlockItem(StatementBlockItem),
    StatementBlockList(Vec<StatementBlockList>),
    Step(Step),
    StepTerm(StepTerm),
    StepToken(StepToken),
    Strin(Strin),
    StringLiteral(StringLiteral),
    StringLiteralTerm(StringLiteralTerm),
    StringLiteralToken(StringLiteralToken),
    StringTerm(StringTerm),
    StringToken(StringToken),
    Struct(Struct),
    StructConstructor(StructConstructor),
    StructConstructorItem(StructConstructorItem),
    StructConstructorList(StructConstructorList),
    StructConstructorListList(Vec<StructConstructorListList>),
    StructConstructorListOpt(Option<StructConstructorListOpt>),
    StructConstructorOpt(Option<StructConstructorOpt>),
    StructTerm(StructTerm),
    StructToken(StructToken),
    StructUnion(StructUnion),
    StructUnionDeclaration(StructUnionDeclaration),
    StructUnionDeclarationOpt(Option<StructUnionDeclarationOpt>),
    StructUnionGroup(StructUnionGroup),
    StructUnionGroupGroup(StructUnionGroupGroup),
    StructUnionGroupList(Vec<StructUnionGroupList>),
    StructUnionItem(StructUnionItem),
    StructUnionList(StructUnionList),
    StructUnionListList(Vec<StructUnionListList>),
    StructUnionListOpt(Option<StructUnionListOpt>),
    Switch(Switch),
    SwitchCondition(SwitchCondition),
    SwitchConditionList(Vec<SwitchConditionList>),
    SwitchExpression(SwitchExpression),
    SwitchExpressionList(Vec<SwitchExpressionList>),
    SwitchExpressionOpt(Option<SwitchExpressionOpt>),
    SwitchItem(SwitchItem),
    SwitchItemGroup(SwitchItemGroup),
    SwitchItemGroup0(SwitchItemGroup0),
    SwitchStatement(SwitchStatement),
    SwitchStatementList(Vec<SwitchStatementList>),
    SwitchTerm(SwitchTerm),
    SwitchToken(SwitchToken),
    Tri(Tri),
    TriTerm(TriTerm),
    TriToken(TriToken),
    TripleLBrace(TripleLBrace),
    TripleLBraceTerm(TripleLBraceTerm),
    TripleLBraceToken(TripleLBraceToken),
    TripleRBrace(TripleRBrace),
    TripleRBraceTerm(TripleRBraceTerm),
    TripleRBraceToken(TripleRBraceToken),
    True(True),
    TrueTerm(TrueTerm),
    TrueToken(TrueToken),
    Type(Type),
    TypeDefDeclaration(TypeDefDeclaration),
    TypeExpression(TypeExpression),
    TypeModifier(TypeModifier),
    TypeTerm(TypeTerm),
    TypeToken(TypeToken),
    U16(U16),
    U16Term(U16Term),
    U16Token(U16Token),
    U32(U32),
    U32Term(U32Term),
    U32Token(U32Token),
    U64(U64),
    U64Term(U64Term),
    U64Token(U64Token),
    U8(U8),
    U8Term(U8Term),
    U8Token(U8Token),
    UnaryOperator(UnaryOperator),
    UnaryOperatorTerm(UnaryOperatorTerm),
    UnaryOperatorToken(UnaryOperatorToken),
    Union(Union),
    UnionTerm(UnionTerm),
    UnionToken(UnionToken),
    Unsafe(Unsafe),
    UnsafeBlock(UnsafeBlock),
    UnsafeBlockList(Vec<UnsafeBlockList>),
    UnsafeTerm(UnsafeTerm),
    UnsafeToken(UnsafeToken),
    UserDefinedType(UserDefinedType),
    Var(Var),
    VarDeclaration(VarDeclaration),
    VarDeclarationOpt(Option<VarDeclarationOpt>),
    VarTerm(VarTerm),
    VarToken(VarToken),
    VariableType(VariableType),
    Veryl(Veryl),
    VerylList(Vec<VerylList>),
    Width(Width),
    WidthList(Vec<WidthList>),
    WithGenericArgument(WithGenericArgument),
    WithGenericArgumentItem(WithGenericArgumentItem),
    WithGenericArgumentList(WithGenericArgumentList),
    WithGenericArgumentListList(Vec<WithGenericArgumentListList>),
    WithGenericArgumentListOpt(Option<WithGenericArgumentListOpt>),
    WithGenericArgumentOpt(Option<WithGenericArgumentOpt>),
    WithGenericParameter(WithGenericParameter),
    WithGenericParameterItem(WithGenericParameterItem),
    WithGenericParameterItemOpt(Option<WithGenericParameterItemOpt>),
    WithGenericParameterList(WithGenericParameterList),
    WithGenericParameterListList(Vec<WithGenericParameterListList>),
    WithGenericParameterListOpt(Option<WithGenericParameterListOpt>),
    WithParameter(WithParameter),
    WithParameterGroup(WithParameterGroup),
    WithParameterGroupGroup(WithParameterGroupGroup),
    WithParameterGroupList(Vec<WithParameterGroupList>),
    WithParameterItem(WithParameterItem),
    WithParameterItemGroup(WithParameterItemGroup),
    WithParameterItemGroup0(WithParameterItemGroup0),
    WithParameterItemOpt(Option<WithParameterItemOpt>),
    WithParameterList(WithParameterList),
    WithParameterListList(Vec<WithParameterListList>),
    WithParameterListOpt(Option<WithParameterListOpt>),
    WithParameterOpt(Option<WithParameterOpt>),
}

// -------------------------------------------------------------------------------------------------

/// Auto-implemented adapter grammar
///
/// The lifetime parameter `'t` refers to the lifetime of the scanned text.
/// The lifetime parameter `'u` refers to the lifetime of user grammar object.
///
#[allow(dead_code)]
pub struct VerylGrammarAuto<'t, 'u>
where
    't: 'u,
{
    // Mutable reference of the actual user grammar to be able to call the semantic actions on it
    user_grammar: &'u mut dyn VerylGrammarTrait,
    // Stack to construct the AST on it
    item_stack: Vec<ASTType>,
    // Just to hold the lifetime generated by parol
    phantom: PhantomData<&'t str>,
}

///
/// The `VerylGrammarAuto` impl is automatically generated for the
/// given grammar.
///
impl<'t, 'u> VerylGrammarAuto<'t, 'u> {
    pub fn new(user_grammar: &'u mut dyn VerylGrammarTrait) -> Self {
        Self {
            user_grammar,
            item_stack: Vec::new(),
            phantom: PhantomData,
        }
    }

    #[allow(dead_code)]
    fn push(&mut self, item: ASTType, context: &str) {
        trace!("push    {context}: {item:?}");
        self.item_stack.push(item)
    }

    #[allow(dead_code)]
    fn pop(&mut self, context: &str) -> Option<ASTType> {
        let item = self.item_stack.pop();
        if let Some(ref item) = item {
            trace!("pop     {context}: {item:?}");
        }
        item
    }

    #[allow(dead_code)]
    // Use this function for debugging purposes:
    // trace!("{}", self.trace_item_stack(context));
    fn trace_item_stack(&self, context: &str) -> std::string::String {
        format!(
            "Item stack at {}:\n{}",
            context,
            self.item_stack
                .iter()
                .rev()
                .map(|s| format!("  {s:?}"))
                .collect::<Vec<std::string::String>>()
                .join("\n")
        )
    }

    /// Semantic action for production 0:
    ///
    /// `CommentsTerm: <INITIAL, EmbedHeader, Generic, Attr>"(?:(?:(?://.*(?:\r\n|\r|\n)?)|(?:(?ms)/\*/?([^/]|[^*]/)*\*/))\s*)+" : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn comments_term(&mut self, comments_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments_term = comments_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let comments_term_built = CommentsTerm { comments_term };
        // Calling user action here
        self.user_grammar.comments_term(&comments_term_built)?;
        self.push(ASTType::CommentsTerm(comments_term_built), context);
        Ok(())
    }

    /// Semantic action for production 1:
    ///
    /// `StringLiteralTerm: <INITIAL, Attr>"\u{0022}(?:\\[\u{0022}\\/bfnrt]|u[0-9a-fA-F]{4}|[^\u{0022}\\\u0000-\u001F])*\u{0022}" : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn string_literal_term(&mut self, string_literal_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string_literal_term = string_literal_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let string_literal_term_built = StringLiteralTerm {
            string_literal_term,
        };
        // Calling user action here
        self.user_grammar
            .string_literal_term(&string_literal_term_built)?;
        self.push(
            ASTType::StringLiteralTerm(string_literal_term_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 2:
    ///
    /// `ExponentTerm: <INITIAL, Generic>/[0-9]+(?:_[0-9]+)*\.[0-9]+(?:_[0-9]+)*[eE][+-]?[0-9]+(?:_[0-9]+)*/ : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn exponent_term(&mut self, exponent_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let exponent_term = exponent_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let exponent_term_built = ExponentTerm { exponent_term };
        // Calling user action here
        self.user_grammar.exponent_term(&exponent_term_built)?;
        self.push(ASTType::ExponentTerm(exponent_term_built), context);
        Ok(())
    }

    /// Semantic action for production 3:
    ///
    /// `FixedPointTerm: <INITIAL, Generic>/[0-9]+(?:_[0-9]+)*\.[0-9]+(?:_[0-9]+)*/ : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn fixed_point_term(&mut self, fixed_point_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fixed_point_term = fixed_point_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let fixed_point_term_built = FixedPointTerm { fixed_point_term };
        // Calling user action here
        self.user_grammar
            .fixed_point_term(&fixed_point_term_built)?;
        self.push(ASTType::FixedPointTerm(fixed_point_term_built), context);
        Ok(())
    }

    /// Semantic action for production 4:
    ///
    /// `BasedTerm: <INITIAL, Generic>/(?:[0-9]+(?:_[0-9]+)*)?'s?[bodh][0-9a-fA-FxzXZ]+(?:_[0-9a-fA-FxzXZ]+)*/ : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn based_term(&mut self, based_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_term = based_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let based_term_built = BasedTerm { based_term };
        // Calling user action here
        self.user_grammar.based_term(&based_term_built)?;
        self.push(ASTType::BasedTerm(based_term_built), context);
        Ok(())
    }

    /// Semantic action for production 5:
    ///
    /// `AllBitTerm: <INITIAL, Generic>/(?:[0-9]+(?:_[0-9]+)*)?'[01xzXZ]/ : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn all_bit_term(&mut self, all_bit_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let all_bit_term = all_bit_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let all_bit_term_built = AllBitTerm { all_bit_term };
        // Calling user action here
        self.user_grammar.all_bit_term(&all_bit_term_built)?;
        self.push(ASTType::AllBitTerm(all_bit_term_built), context);
        Ok(())
    }

    /// Semantic action for production 6:
    ///
    /// `BaseLessTerm: <INITIAL, Generic>/[0-9]+(?:_[0-9]+)*/ : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn base_less_term(&mut self, base_less_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let base_less_term = base_less_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let base_less_term_built = BaseLessTerm { base_less_term };
        // Calling user action here
        self.user_grammar.base_less_term(&base_less_term_built)?;
        self.push(ASTType::BaseLessTerm(base_less_term_built), context);
        Ok(())
    }

    /// Semantic action for production 7:
    ///
    /// `MinusColonTerm: '-:' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn minus_colon_term(&mut self, minus_colon_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_colon_term = minus_colon_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let minus_colon_term_built = MinusColonTerm { minus_colon_term };
        // Calling user action here
        self.user_grammar
            .minus_colon_term(&minus_colon_term_built)?;
        self.push(ASTType::MinusColonTerm(minus_colon_term_built), context);
        Ok(())
    }

    /// Semantic action for production 8:
    ///
    /// `MinusGTTerm: '->' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn minus_g_t_term(&mut self, minus_g_t_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_g_t_term = minus_g_t_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let minus_g_t_term_built = MinusGTTerm { minus_g_t_term };
        // Calling user action here
        self.user_grammar.minus_g_t_term(&minus_g_t_term_built)?;
        self.push(ASTType::MinusGTTerm(minus_g_t_term_built), context);
        Ok(())
    }

    /// Semantic action for production 9:
    ///
    /// `LTMinusTerm: '<-' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn l_t_minus_term(&mut self, l_t_minus_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t_minus_term = l_t_minus_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let l_t_minus_term_built = LTMinusTerm { l_t_minus_term };
        // Calling user action here
        self.user_grammar.l_t_minus_term(&l_t_minus_term_built)?;
        self.push(ASTType::LTMinusTerm(l_t_minus_term_built), context);
        Ok(())
    }

    /// Semantic action for production 10:
    ///
    /// `PlusColonTerm: '+:' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn plus_colon_term(&mut self, plus_colon_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus_colon_term = plus_colon_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let plus_colon_term_built = PlusColonTerm { plus_colon_term };
        // Calling user action here
        self.user_grammar.plus_colon_term(&plus_colon_term_built)?;
        self.push(ASTType::PlusColonTerm(plus_colon_term_built), context);
        Ok(())
    }

    /// Semantic action for production 11:
    ///
    /// `AssignmentOperatorTerm: "\+=|-=|\*=|/=|%=|&=|\|=|\^=|<<=|>>=|<<<=|>>>=" : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn assignment_operator_term(
        &mut self,
        assignment_operator_term: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment_operator_term = assignment_operator_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let assignment_operator_term_built = AssignmentOperatorTerm {
            assignment_operator_term,
        };
        // Calling user action here
        self.user_grammar
            .assignment_operator_term(&assignment_operator_term_built)?;
        self.push(
            ASTType::AssignmentOperatorTerm(assignment_operator_term_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 12:
    ///
    /// `DiamondOperatorTerm: '<>' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn diamond_operator_term(&mut self, diamond_operator_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let diamond_operator_term = diamond_operator_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let diamond_operator_term_built = DiamondOperatorTerm {
            diamond_operator_term,
        };
        // Calling user action here
        self.user_grammar
            .diamond_operator_term(&diamond_operator_term_built)?;
        self.push(
            ASTType::DiamondOperatorTerm(diamond_operator_term_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 13:
    ///
    /// `Operator12Term: "\*\*" : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn operator12_term(&mut self, operator12_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator12_term = operator12_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator12_term_built = Operator12Term { operator12_term };
        // Calling user action here
        self.user_grammar.operator12_term(&operator12_term_built)?;
        self.push(ASTType::Operator12Term(operator12_term_built), context);
        Ok(())
    }

    /// Semantic action for production 14:
    ///
    /// `Operator11Term: "/|%" : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn operator11_term(&mut self, operator11_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator11_term = operator11_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator11_term_built = Operator11Term { operator11_term };
        // Calling user action here
        self.user_grammar.operator11_term(&operator11_term_built)?;
        self.push(ASTType::Operator11Term(operator11_term_built), context);
        Ok(())
    }

    /// Semantic action for production 15:
    ///
    /// `Operator10Term: "\+|-" : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn operator10_term(&mut self, operator10_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator10_term = operator10_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator10_term_built = Operator10Term { operator10_term };
        // Calling user action here
        self.user_grammar.operator10_term(&operator10_term_built)?;
        self.push(ASTType::Operator10Term(operator10_term_built), context);
        Ok(())
    }

    /// Semantic action for production 16:
    ///
    /// `Operator09Term: "<<<|>>>|<<|>>" : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn operator09_term(&mut self, operator09_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator09_term = operator09_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator09_term_built = Operator09Term { operator09_term };
        // Calling user action here
        self.user_grammar.operator09_term(&operator09_term_built)?;
        self.push(ASTType::Operator09Term(operator09_term_built), context);
        Ok(())
    }

    /// Semantic action for production 17:
    ///
    /// `Operator08Term: "<=|>=|<:|>:" : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn operator08_term(&mut self, operator08_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator08_term = operator08_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator08_term_built = Operator08Term { operator08_term };
        // Calling user action here
        self.user_grammar.operator08_term(&operator08_term_built)?;
        self.push(ASTType::Operator08Term(operator08_term_built), context);
        Ok(())
    }

    /// Semantic action for production 18:
    ///
    /// `Operator07Term: "==\?|!=\?|==|!=" : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn operator07_term(&mut self, operator07_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator07_term = operator07_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator07_term_built = Operator07Term { operator07_term };
        // Calling user action here
        self.user_grammar.operator07_term(&operator07_term_built)?;
        self.push(ASTType::Operator07Term(operator07_term_built), context);
        Ok(())
    }

    /// Semantic action for production 19:
    ///
    /// `Operator03Term: "&&" : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn operator03_term(&mut self, operator03_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator03_term = operator03_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator03_term_built = Operator03Term { operator03_term };
        // Calling user action here
        self.user_grammar.operator03_term(&operator03_term_built)?;
        self.push(ASTType::Operator03Term(operator03_term_built), context);
        Ok(())
    }

    /// Semantic action for production 20:
    ///
    /// `Operator02Term: "\|\|" : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn operator02_term(&mut self, operator02_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator02_term = operator02_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator02_term_built = Operator02Term { operator02_term };
        // Calling user action here
        self.user_grammar.operator02_term(&operator02_term_built)?;
        self.push(ASTType::Operator02Term(operator02_term_built), context);
        Ok(())
    }

    /// Semantic action for production 21:
    ///
    /// `Operator06Term: "&" : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn operator06_term(&mut self, operator06_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator06_term = operator06_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator06_term_built = Operator06Term { operator06_term };
        // Calling user action here
        self.user_grammar.operator06_term(&operator06_term_built)?;
        self.push(ASTType::Operator06Term(operator06_term_built), context);
        Ok(())
    }

    /// Semantic action for production 22:
    ///
    /// `Operator05Term: "\^|~\^" : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn operator05_term(&mut self, operator05_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator05_term = operator05_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator05_term_built = Operator05Term { operator05_term };
        // Calling user action here
        self.user_grammar.operator05_term(&operator05_term_built)?;
        self.push(ASTType::Operator05Term(operator05_term_built), context);
        Ok(())
    }

    /// Semantic action for production 23:
    ///
    /// `Operator04Term: "\|" : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn operator04_term(&mut self, operator04_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator04_term = operator04_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let operator04_term_built = Operator04Term { operator04_term };
        // Calling user action here
        self.user_grammar.operator04_term(&operator04_term_built)?;
        self.push(ASTType::Operator04Term(operator04_term_built), context);
        Ok(())
    }

    /// Semantic action for production 24:
    ///
    /// `UnaryOperatorTerm: "~&|~\||!|~" : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn unary_operator_term(&mut self, unary_operator_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unary_operator_term = unary_operator_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let unary_operator_term_built = UnaryOperatorTerm {
            unary_operator_term,
        };
        // Calling user action here
        self.user_grammar
            .unary_operator_term(&unary_operator_term_built)?;
        self.push(
            ASTType::UnaryOperatorTerm(unary_operator_term_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 25:
    ///
    /// `ColonColonLAngleTerm: <INITIAL, Generic>'::<' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn colon_colon_l_angle_term(
        &mut self,
        colon_colon_l_angle_term: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon_colon_l_angle_term = colon_colon_l_angle_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let colon_colon_l_angle_term_built = ColonColonLAngleTerm {
            colon_colon_l_angle_term,
        };
        // Calling user action here
        self.user_grammar
            .colon_colon_l_angle_term(&colon_colon_l_angle_term_built)?;
        self.push(
            ASTType::ColonColonLAngleTerm(colon_colon_l_angle_term_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 26:
    ///
    /// `ColonColonTerm: <INITIAL, Generic>'::' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn colon_colon_term(&mut self, colon_colon_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon_colon_term = colon_colon_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let colon_colon_term_built = ColonColonTerm { colon_colon_term };
        // Calling user action here
        self.user_grammar
            .colon_colon_term(&colon_colon_term_built)?;
        self.push(ASTType::ColonColonTerm(colon_colon_term_built), context);
        Ok(())
    }

    /// Semantic action for production 27:
    ///
    /// `ColonTerm: <INITIAL, Generic>':' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn colon_term(&mut self, colon_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon_term = colon_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let colon_term_built = ColonTerm { colon_term };
        // Calling user action here
        self.user_grammar.colon_term(&colon_term_built)?;
        self.push(ASTType::ColonTerm(colon_term_built), context);
        Ok(())
    }

    /// Semantic action for production 28:
    ///
    /// `CommaTerm: <INITIAL, Generic, Attr>',' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn comma_term(&mut self, comma_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma_term = comma_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let comma_term_built = CommaTerm { comma_term };
        // Calling user action here
        self.user_grammar.comma_term(&comma_term_built)?;
        self.push(ASTType::CommaTerm(comma_term_built), context);
        Ok(())
    }

    /// Semantic action for production 29:
    ///
    /// `DotDotEquTerm: '..=' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn dot_dot_equ_term(&mut self, dot_dot_equ_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_dot_equ_term = dot_dot_equ_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let dot_dot_equ_term_built = DotDotEquTerm { dot_dot_equ_term };
        // Calling user action here
        self.user_grammar
            .dot_dot_equ_term(&dot_dot_equ_term_built)?;
        self.push(ASTType::DotDotEquTerm(dot_dot_equ_term_built), context);
        Ok(())
    }

    /// Semantic action for production 30:
    ///
    /// `DotDotTerm: '..' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn dot_dot_term(&mut self, dot_dot_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_dot_term = dot_dot_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let dot_dot_term_built = DotDotTerm { dot_dot_term };
        // Calling user action here
        self.user_grammar.dot_dot_term(&dot_dot_term_built)?;
        self.push(ASTType::DotDotTerm(dot_dot_term_built), context);
        Ok(())
    }

    /// Semantic action for production 31:
    ///
    /// `DotTerm: <INITIAL, Generic>'.' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn dot_term(&mut self, dot_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_term = dot_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let dot_term_built = DotTerm { dot_term };
        // Calling user action here
        self.user_grammar.dot_term(&dot_term_built)?;
        self.push(ASTType::DotTerm(dot_term_built), context);
        Ok(())
    }

    /// Semantic action for production 32:
    ///
    /// `EquTerm: <INITIAL, Generic>'=' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn equ_term(&mut self, equ_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_term = equ_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let equ_term_built = EquTerm { equ_term };
        // Calling user action here
        self.user_grammar.equ_term(&equ_term_built)?;
        self.push(ASTType::EquTerm(equ_term_built), context);
        Ok(())
    }

    /// Semantic action for production 33:
    ///
    /// `HashLBracketTerm: '#[' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn hash_l_bracket_term(&mut self, hash_l_bracket_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hash_l_bracket_term = hash_l_bracket_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let hash_l_bracket_term_built = HashLBracketTerm {
            hash_l_bracket_term,
        };
        // Calling user action here
        self.user_grammar
            .hash_l_bracket_term(&hash_l_bracket_term_built)?;
        self.push(
            ASTType::HashLBracketTerm(hash_l_bracket_term_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 34:
    ///
    /// `HashTerm: '#' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn hash_term(&mut self, hash_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hash_term = hash_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let hash_term_built = HashTerm { hash_term };
        // Calling user action here
        self.user_grammar.hash_term(&hash_term_built)?;
        self.push(ASTType::HashTerm(hash_term_built), context);
        Ok(())
    }

    /// Semantic action for production 35:
    ///
    /// `LAngleTerm: '<' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn l_angle_term(&mut self, l_angle_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_angle_term = l_angle_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let l_angle_term_built = LAngleTerm { l_angle_term };
        // Calling user action here
        self.user_grammar.l_angle_term(&l_angle_term_built)?;
        self.push(ASTType::LAngleTerm(l_angle_term_built), context);
        Ok(())
    }

    /// Semantic action for production 36:
    ///
    /// `QuestionTerm: '?' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn question_term(&mut self, question_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let question_term = question_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let question_term_built = QuestionTerm { question_term };
        // Calling user action here
        self.user_grammar.question_term(&question_term_built)?;
        self.push(ASTType::QuestionTerm(question_term_built), context);
        Ok(())
    }

    /// Semantic action for production 37:
    ///
    /// `QuoteLBraceTerm: "'\{" : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn quote_l_brace_term(&mut self, quote_l_brace_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quote_l_brace_term = quote_l_brace_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let quote_l_brace_term_built = QuoteLBraceTerm { quote_l_brace_term };
        // Calling user action here
        self.user_grammar
            .quote_l_brace_term(&quote_l_brace_term_built)?;
        self.push(ASTType::QuoteLBraceTerm(quote_l_brace_term_built), context);
        Ok(())
    }

    /// Semantic action for production 38:
    ///
    /// `QuoteTerm: "'" : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn quote_term(&mut self, quote_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quote_term = quote_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let quote_term_built = QuoteTerm { quote_term };
        // Calling user action here
        self.user_grammar.quote_term(&quote_term_built)?;
        self.push(ASTType::QuoteTerm(quote_term_built), context);
        Ok(())
    }

    /// Semantic action for production 39:
    ///
    /// `EscapedLBraceTerm: <EmbedBody, EmbedBodyInner>'\{' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn escaped_l_brace_term(&mut self, escaped_l_brace_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let escaped_l_brace_term = escaped_l_brace_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let escaped_l_brace_term_built = EscapedLBraceTerm {
            escaped_l_brace_term,
        };
        // Calling user action here
        self.user_grammar
            .escaped_l_brace_term(&escaped_l_brace_term_built)?;
        self.push(
            ASTType::EscapedLBraceTerm(escaped_l_brace_term_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 40:
    ///
    /// `TripleLBraceTerm: <EmbedHeader>'{{{' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn triple_l_brace_term(&mut self, triple_l_brace_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let triple_l_brace_term = triple_l_brace_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let triple_l_brace_term_built = TripleLBraceTerm {
            triple_l_brace_term,
        };
        // Calling user action here
        self.user_grammar
            .triple_l_brace_term(&triple_l_brace_term_built)?;
        self.push(
            ASTType::TripleLBraceTerm(triple_l_brace_term_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 41:
    ///
    /// `LBraceTerm: <INITIAL, EmbedBody, EmbedBodyInner, Attr>'{' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn l_brace_term(&mut self, l_brace_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_brace_term = l_brace_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let l_brace_term_built = LBraceTerm { l_brace_term };
        // Calling user action here
        self.user_grammar.l_brace_term(&l_brace_term_built)?;
        self.push(ASTType::LBraceTerm(l_brace_term_built), context);
        Ok(())
    }

    /// Semantic action for production 42:
    ///
    /// `LBracketTerm: <INITIAL, Attr>'[' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn l_bracket_term(&mut self, l_bracket_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket_term = l_bracket_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let l_bracket_term_built = LBracketTerm { l_bracket_term };
        // Calling user action here
        self.user_grammar.l_bracket_term(&l_bracket_term_built)?;
        self.push(ASTType::LBracketTerm(l_bracket_term_built), context);
        Ok(())
    }

    /// Semantic action for production 43:
    ///
    /// `LParenTerm: <INITIAL, EmbedHeader, Attr>'(' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn l_paren_term(&mut self, l_paren_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren_term = l_paren_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let l_paren_term_built = LParenTerm { l_paren_term };
        // Calling user action here
        self.user_grammar.l_paren_term(&l_paren_term_built)?;
        self.push(ASTType::LParenTerm(l_paren_term_built), context);
        Ok(())
    }

    /// Semantic action for production 44:
    ///
    /// `RAngleTerm: <INITIAL, Generic>'>' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn r_angle_term(&mut self, r_angle_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_angle_term = r_angle_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r_angle_term_built = RAngleTerm { r_angle_term };
        // Calling user action here
        self.user_grammar.r_angle_term(&r_angle_term_built)?;
        self.push(ASTType::RAngleTerm(r_angle_term_built), context);
        Ok(())
    }

    /// Semantic action for production 45:
    ///
    /// `EscapedRBraceTerm: '\}' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn escaped_r_brace_term(&mut self, escaped_r_brace_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let escaped_r_brace_term = escaped_r_brace_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let escaped_r_brace_term_built = EscapedRBraceTerm {
            escaped_r_brace_term,
        };
        // Calling user action here
        self.user_grammar
            .escaped_r_brace_term(&escaped_r_brace_term_built)?;
        self.push(
            ASTType::EscapedRBraceTerm(escaped_r_brace_term_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 46:
    ///
    /// `TripleRBraceTerm: <EmbedBody>'}}}' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn triple_r_brace_term(&mut self, triple_r_brace_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let triple_r_brace_term = triple_r_brace_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let triple_r_brace_term_built = TripleRBraceTerm {
            triple_r_brace_term,
        };
        // Calling user action here
        self.user_grammar
            .triple_r_brace_term(&triple_r_brace_term_built)?;
        self.push(
            ASTType::TripleRBraceTerm(triple_r_brace_term_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 47:
    ///
    /// `RBraceTerm: <INITIAL, EmbedBodyInner, Attr>'}' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn r_brace_term(&mut self, r_brace_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace_term = r_brace_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r_brace_term_built = RBraceTerm { r_brace_term };
        // Calling user action here
        self.user_grammar.r_brace_term(&r_brace_term_built)?;
        self.push(ASTType::RBraceTerm(r_brace_term_built), context);
        Ok(())
    }

    /// Semantic action for production 48:
    ///
    /// `RBracketTerm: <INITIAL, Attr>']' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn r_bracket_term(&mut self, r_bracket_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket_term = r_bracket_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r_bracket_term_built = RBracketTerm { r_bracket_term };
        // Calling user action here
        self.user_grammar.r_bracket_term(&r_bracket_term_built)?;
        self.push(ASTType::RBracketTerm(r_bracket_term_built), context);
        Ok(())
    }

    /// Semantic action for production 49:
    ///
    /// `RParenTerm: <INITIAL, EmbedHeader, Attr>')' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn r_paren_term(&mut self, r_paren_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren_term = r_paren_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let r_paren_term_built = RParenTerm { r_paren_term };
        // Calling user action here
        self.user_grammar.r_paren_term(&r_paren_term_built)?;
        self.push(ASTType::RParenTerm(r_paren_term_built), context);
        Ok(())
    }

    /// Semantic action for production 50:
    ///
    /// `SemicolonTerm: ';' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn semicolon_term(&mut self, semicolon_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon_term = semicolon_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let semicolon_term_built = SemicolonTerm { semicolon_term };
        // Calling user action here
        self.user_grammar.semicolon_term(&semicolon_term_built)?;
        self.push(ASTType::SemicolonTerm(semicolon_term_built), context);
        Ok(())
    }

    /// Semantic action for production 51:
    ///
    /// `StarTerm: '*' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn star_term(&mut self, star_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star_term = star_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let star_term_built = StarTerm { star_term };
        // Calling user action here
        self.user_grammar.star_term(&star_term_built)?;
        self.push(ASTType::StarTerm(star_term_built), context);
        Ok(())
    }

    /// Semantic action for production 52:
    ///
    /// `AliasTerm: <INITIAL, Generic>'alias' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn alias_term(&mut self, alias_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alias_term = alias_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let alias_term_built = AliasTerm { alias_term };
        // Calling user action here
        self.user_grammar.alias_term(&alias_term_built)?;
        self.push(ASTType::AliasTerm(alias_term_built), context);
        Ok(())
    }

    /// Semantic action for production 53:
    ///
    /// `AlwaysCombTerm: <INITIAL, Generic>'always_comb' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_term(&mut self, always_comb_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_comb_term = always_comb_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let always_comb_term_built = AlwaysCombTerm { always_comb_term };
        // Calling user action here
        self.user_grammar
            .always_comb_term(&always_comb_term_built)?;
        self.push(ASTType::AlwaysCombTerm(always_comb_term_built), context);
        Ok(())
    }

    /// Semantic action for production 54:
    ///
    /// `AlwaysFfTerm: <INITIAL, Generic>'always_ff' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_term(&mut self, always_ff_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_term = always_ff_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let always_ff_term_built = AlwaysFfTerm { always_ff_term };
        // Calling user action here
        self.user_grammar.always_ff_term(&always_ff_term_built)?;
        self.push(ASTType::AlwaysFfTerm(always_ff_term_built), context);
        Ok(())
    }

    /// Semantic action for production 55:
    ///
    /// `AssignTerm: <INITIAL, Generic>'assign' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn assign_term(&mut self, assign_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign_term = assign_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let assign_term_built = AssignTerm { assign_term };
        // Calling user action here
        self.user_grammar.assign_term(&assign_term_built)?;
        self.push(ASTType::AssignTerm(assign_term_built), context);
        Ok(())
    }

    /// Semantic action for production 56:
    ///
    /// `AsTerm: <INITIAL, Generic>'as' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn as_term(&mut self, as_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let as_term = as_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let as_term_built = AsTerm { as_term };
        // Calling user action here
        self.user_grammar.as_term(&as_term_built)?;
        self.push(ASTType::AsTerm(as_term_built), context);
        Ok(())
    }

    /// Semantic action for production 57:
    ///
    /// `BindTerm: <INITIAL, Generic>'bind' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn bind_term(&mut self, bind_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bind_term = bind_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let bind_term_built = BindTerm { bind_term };
        // Calling user action here
        self.user_grammar.bind_term(&bind_term_built)?;
        self.push(ASTType::BindTerm(bind_term_built), context);
        Ok(())
    }

    /// Semantic action for production 58:
    ///
    /// `BitTerm: <INITIAL, Generic>'bit' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn bit_term(&mut self, bit_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bit_term = bit_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let bit_term_built = BitTerm { bit_term };
        // Calling user action here
        self.user_grammar.bit_term(&bit_term_built)?;
        self.push(ASTType::BitTerm(bit_term_built), context);
        Ok(())
    }

    /// Semantic action for production 59:
    ///
    /// `BoolTerm: <INITIAL, Generic>'bool' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn bool_term(&mut self, bool_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bool_term = bool_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let bool_term_built = BoolTerm { bool_term };
        // Calling user action here
        self.user_grammar.bool_term(&bool_term_built)?;
        self.push(ASTType::BoolTerm(bool_term_built), context);
        Ok(())
    }

    /// Semantic action for production 60:
    ///
    /// `CaseTerm: <INITIAL, Generic>'case' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn case_term(&mut self, case_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_term = case_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let case_term_built = CaseTerm { case_term };
        // Calling user action here
        self.user_grammar.case_term(&case_term_built)?;
        self.push(ASTType::CaseTerm(case_term_built), context);
        Ok(())
    }

    /// Semantic action for production 61:
    ///
    /// `ClockTerm: <INITIAL, Generic>'clock' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn clock_term(&mut self, clock_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let clock_term = clock_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let clock_term_built = ClockTerm { clock_term };
        // Calling user action here
        self.user_grammar.clock_term(&clock_term_built)?;
        self.push(ASTType::ClockTerm(clock_term_built), context);
        Ok(())
    }

    /// Semantic action for production 62:
    ///
    /// `ClockPosedgeTerm: <INITIAL, Generic>'clock_posedge' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn clock_posedge_term(&mut self, clock_posedge_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let clock_posedge_term = clock_posedge_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let clock_posedge_term_built = ClockPosedgeTerm { clock_posedge_term };
        // Calling user action here
        self.user_grammar
            .clock_posedge_term(&clock_posedge_term_built)?;
        self.push(ASTType::ClockPosedgeTerm(clock_posedge_term_built), context);
        Ok(())
    }

    /// Semantic action for production 63:
    ///
    /// `ClockNegedgeTerm: <INITIAL, Generic>'clock_negedge' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn clock_negedge_term(&mut self, clock_negedge_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let clock_negedge_term = clock_negedge_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let clock_negedge_term_built = ClockNegedgeTerm { clock_negedge_term };
        // Calling user action here
        self.user_grammar
            .clock_negedge_term(&clock_negedge_term_built)?;
        self.push(ASTType::ClockNegedgeTerm(clock_negedge_term_built), context);
        Ok(())
    }

    /// Semantic action for production 64:
    ///
    /// `ConnectTerm: <INITIAL, Generic>'connect' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn connect_term(&mut self, connect_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let connect_term = connect_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let connect_term_built = ConnectTerm { connect_term };
        // Calling user action here
        self.user_grammar.connect_term(&connect_term_built)?;
        self.push(ASTType::ConnectTerm(connect_term_built), context);
        Ok(())
    }

    /// Semantic action for production 65:
    ///
    /// `ConstTerm: <INITIAL, Generic>'const' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn const_term(&mut self, const_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_term = const_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let const_term_built = ConstTerm { const_term };
        // Calling user action here
        self.user_grammar.const_term(&const_term_built)?;
        self.push(ASTType::ConstTerm(const_term_built), context);
        Ok(())
    }

    /// Semantic action for production 66:
    ///
    /// `ConverseTerm: <INITIAL, Generic>'converse' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn converse_term(&mut self, converse_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let converse_term = converse_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let converse_term_built = ConverseTerm { converse_term };
        // Calling user action here
        self.user_grammar.converse_term(&converse_term_built)?;
        self.push(ASTType::ConverseTerm(converse_term_built), context);
        Ok(())
    }

    /// Semantic action for production 67:
    ///
    /// `DefaultTerm: <INITIAL, Generic>'default' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn default_term(&mut self, default_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let default_term = default_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let default_term_built = DefaultTerm { default_term };
        // Calling user action here
        self.user_grammar.default_term(&default_term_built)?;
        self.push(ASTType::DefaultTerm(default_term_built), context);
        Ok(())
    }

    /// Semantic action for production 68:
    ///
    /// `ElseTerm: <INITIAL, Generic>'else' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn else_term(&mut self, else_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let else_term = else_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let else_term_built = ElseTerm { else_term };
        // Calling user action here
        self.user_grammar.else_term(&else_term_built)?;
        self.push(ASTType::ElseTerm(else_term_built), context);
        Ok(())
    }

    /// Semantic action for production 69:
    ///
    /// `EmbedTerm: <INITIAL, Generic>'embed' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn embed_term(&mut self, embed_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let embed_term = embed_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let embed_term_built = EmbedTerm { embed_term };
        // Calling user action here
        self.user_grammar.embed_term(&embed_term_built)?;
        self.push(ASTType::EmbedTerm(embed_term_built), context);
        Ok(())
    }

    /// Semantic action for production 70:
    ///
    /// `EnumTerm: <INITIAL, Generic>'enum' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_term(&mut self, enum_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_term = enum_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let enum_term_built = EnumTerm { enum_term };
        // Calling user action here
        self.user_grammar.enum_term(&enum_term_built)?;
        self.push(ASTType::EnumTerm(enum_term_built), context);
        Ok(())
    }

    /// Semantic action for production 71:
    ///
    /// `F32Term: <INITIAL, Generic>'f32' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn f32_term(&mut self, f32_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f32_term = f32_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let f32_term_built = F32Term { f32_term };
        // Calling user action here
        self.user_grammar.f32_term(&f32_term_built)?;
        self.push(ASTType::F32Term(f32_term_built), context);
        Ok(())
    }

    /// Semantic action for production 72:
    ///
    /// `F64Term: <INITIAL, Generic>'f64' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn f64_term(&mut self, f64_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f64_term = f64_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let f64_term_built = F64Term { f64_term };
        // Calling user action here
        self.user_grammar.f64_term(&f64_term_built)?;
        self.push(ASTType::F64Term(f64_term_built), context);
        Ok(())
    }

    /// Semantic action for production 73:
    ///
    /// `FalseTerm: <INITIAL, Generic>'false' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn false_term(&mut self, false_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let false_term = false_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let false_term_built = FalseTerm { false_term };
        // Calling user action here
        self.user_grammar.false_term(&false_term_built)?;
        self.push(ASTType::FalseTerm(false_term_built), context);
        Ok(())
    }

    /// Semantic action for production 74:
    ///
    /// `FinalTerm: <INITIAL, Generic>'final' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn final_term(&mut self, final_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let final_term = final_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let final_term_built = FinalTerm { final_term };
        // Calling user action here
        self.user_grammar.final_term(&final_term_built)?;
        self.push(ASTType::FinalTerm(final_term_built), context);
        Ok(())
    }

    /// Semantic action for production 75:
    ///
    /// `ForTerm: <INITIAL, Generic>'for' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn for_term(&mut self, for_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_term = for_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let for_term_built = ForTerm { for_term };
        // Calling user action here
        self.user_grammar.for_term(&for_term_built)?;
        self.push(ASTType::ForTerm(for_term_built), context);
        Ok(())
    }

    /// Semantic action for production 76:
    ///
    /// `FunctionTerm: <INITIAL, Generic>'function' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn function_term(&mut self, function_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_term = function_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let function_term_built = FunctionTerm { function_term };
        // Calling user action here
        self.user_grammar.function_term(&function_term_built)?;
        self.push(ASTType::FunctionTerm(function_term_built), context);
        Ok(())
    }

    /// Semantic action for production 77:
    ///
    /// `I8Term: <INITIAL, Generic>'i8' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn i8_term(&mut self, i8_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i8_term = i8_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let i8_term_built = I8Term { i8_term };
        // Calling user action here
        self.user_grammar.i8_term(&i8_term_built)?;
        self.push(ASTType::I8Term(i8_term_built), context);
        Ok(())
    }

    /// Semantic action for production 78:
    ///
    /// `I16Term: <INITIAL, Generic>'i16' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn i16_term(&mut self, i16_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i16_term = i16_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let i16_term_built = I16Term { i16_term };
        // Calling user action here
        self.user_grammar.i16_term(&i16_term_built)?;
        self.push(ASTType::I16Term(i16_term_built), context);
        Ok(())
    }

    /// Semantic action for production 79:
    ///
    /// `I32Term: <INITIAL, Generic>'i32' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn i32_term(&mut self, i32_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i32_term = i32_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let i32_term_built = I32Term { i32_term };
        // Calling user action here
        self.user_grammar.i32_term(&i32_term_built)?;
        self.push(ASTType::I32Term(i32_term_built), context);
        Ok(())
    }

    /// Semantic action for production 80:
    ///
    /// `I64Term: <INITIAL, Generic>'i64' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn i64_term(&mut self, i64_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i64_term = i64_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let i64_term_built = I64Term { i64_term };
        // Calling user action here
        self.user_grammar.i64_term(&i64_term_built)?;
        self.push(ASTType::I64Term(i64_term_built), context);
        Ok(())
    }

    /// Semantic action for production 81:
    ///
    /// `IfResetTerm: <INITIAL, Generic>'if_reset' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_term(&mut self, if_reset_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_term = if_reset_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let if_reset_term_built = IfResetTerm { if_reset_term };
        // Calling user action here
        self.user_grammar.if_reset_term(&if_reset_term_built)?;
        self.push(ASTType::IfResetTerm(if_reset_term_built), context);
        Ok(())
    }

    /// Semantic action for production 82:
    ///
    /// `IfTerm: <INITIAL, Generic>'if' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn if_term(&mut self, if_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_term = if_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let if_term_built = IfTerm { if_term };
        // Calling user action here
        self.user_grammar.if_term(&if_term_built)?;
        self.push(ASTType::IfTerm(if_term_built), context);
        Ok(())
    }

    /// Semantic action for production 83:
    ///
    /// `ImportTerm: <INITIAL, Generic>'import' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn import_term(&mut self, import_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_term = import_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let import_term_built = ImportTerm { import_term };
        // Calling user action here
        self.user_grammar.import_term(&import_term_built)?;
        self.push(ASTType::ImportTerm(import_term_built), context);
        Ok(())
    }

    /// Semantic action for production 84:
    ///
    /// `IncludeTerm: <INITIAL, Generic>'include' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn include_term(&mut self, include_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let include_term = include_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let include_term_built = IncludeTerm { include_term };
        // Calling user action here
        self.user_grammar.include_term(&include_term_built)?;
        self.push(ASTType::IncludeTerm(include_term_built), context);
        Ok(())
    }

    /// Semantic action for production 85:
    ///
    /// `InitialTerm: <INITIAL, Generic>'initial' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn initial_term(&mut self, initial_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let initial_term = initial_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let initial_term_built = InitialTerm { initial_term };
        // Calling user action here
        self.user_grammar.initial_term(&initial_term_built)?;
        self.push(ASTType::InitialTerm(initial_term_built), context);
        Ok(())
    }

    /// Semantic action for production 86:
    ///
    /// `InoutTerm: <INITIAL, Generic>'inout' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn inout_term(&mut self, inout_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inout_term = inout_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let inout_term_built = InoutTerm { inout_term };
        // Calling user action here
        self.user_grammar.inout_term(&inout_term_built)?;
        self.push(ASTType::InoutTerm(inout_term_built), context);
        Ok(())
    }

    /// Semantic action for production 87:
    ///
    /// `InputTerm: <INITIAL, Generic>'input' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn input_term(&mut self, input_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input_term = input_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let input_term_built = InputTerm { input_term };
        // Calling user action here
        self.user_grammar.input_term(&input_term_built)?;
        self.push(ASTType::InputTerm(input_term_built), context);
        Ok(())
    }

    /// Semantic action for production 88:
    ///
    /// `InsideTerm: <INITIAL, Generic>'inside' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn inside_term(&mut self, inside_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inside_term = inside_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let inside_term_built = InsideTerm { inside_term };
        // Calling user action here
        self.user_grammar.inside_term(&inside_term_built)?;
        self.push(ASTType::InsideTerm(inside_term_built), context);
        Ok(())
    }

    /// Semantic action for production 89:
    ///
    /// `InstTerm: <INITIAL, Generic>'inst' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_term(&mut self, inst_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_term = inst_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let inst_term_built = InstTerm { inst_term };
        // Calling user action here
        self.user_grammar.inst_term(&inst_term_built)?;
        self.push(ASTType::InstTerm(inst_term_built), context);
        Ok(())
    }

    /// Semantic action for production 90:
    ///
    /// `InterfaceTerm: <INITIAL, Generic>'interface' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn interface_term(&mut self, interface_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_term = interface_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let interface_term_built = InterfaceTerm { interface_term };
        // Calling user action here
        self.user_grammar.interface_term(&interface_term_built)?;
        self.push(ASTType::InterfaceTerm(interface_term_built), context);
        Ok(())
    }

    /// Semantic action for production 91:
    ///
    /// `InTerm: <INITIAL, Generic>'in' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn in_term(&mut self, in_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let in_term = in_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let in_term_built = InTerm { in_term };
        // Calling user action here
        self.user_grammar.in_term(&in_term_built)?;
        self.push(ASTType::InTerm(in_term_built), context);
        Ok(())
    }

    /// Semantic action for production 92:
    ///
    /// `LetTerm: <INITIAL, Generic>'let' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn let_term(&mut self, let_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let let_term = let_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let let_term_built = LetTerm { let_term };
        // Calling user action here
        self.user_grammar.let_term(&let_term_built)?;
        self.push(ASTType::LetTerm(let_term_built), context);
        Ok(())
    }

    /// Semantic action for production 93:
    ///
    /// `LogicTerm: <INITIAL, Generic>'logic' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn logic_term(&mut self, logic_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logic_term = logic_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let logic_term_built = LogicTerm { logic_term };
        // Calling user action here
        self.user_grammar.logic_term(&logic_term_built)?;
        self.push(ASTType::LogicTerm(logic_term_built), context);
        Ok(())
    }

    /// Semantic action for production 94:
    ///
    /// `LsbTerm: <INITIAL, Generic>'lsb' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn lsb_term(&mut self, lsb_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let lsb_term = lsb_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let lsb_term_built = LsbTerm { lsb_term };
        // Calling user action here
        self.user_grammar.lsb_term(&lsb_term_built)?;
        self.push(ASTType::LsbTerm(lsb_term_built), context);
        Ok(())
    }

    /// Semantic action for production 95:
    ///
    /// `ModportTerm: <INITIAL, Generic>'modport' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_term(&mut self, modport_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_term = modport_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let modport_term_built = ModportTerm { modport_term };
        // Calling user action here
        self.user_grammar.modport_term(&modport_term_built)?;
        self.push(ASTType::ModportTerm(modport_term_built), context);
        Ok(())
    }

    /// Semantic action for production 96:
    ///
    /// `ModuleTerm: <INITIAL, Generic>'module' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn module_term(&mut self, module_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_term = module_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let module_term_built = ModuleTerm { module_term };
        // Calling user action here
        self.user_grammar.module_term(&module_term_built)?;
        self.push(ASTType::ModuleTerm(module_term_built), context);
        Ok(())
    }

    /// Semantic action for production 97:
    ///
    /// `MsbTerm: <INITIAL, Generic>'msb' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn msb_term(&mut self, msb_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let msb_term = msb_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let msb_term_built = MsbTerm { msb_term };
        // Calling user action here
        self.user_grammar.msb_term(&msb_term_built)?;
        self.push(ASTType::MsbTerm(msb_term_built), context);
        Ok(())
    }

    /// Semantic action for production 98:
    ///
    /// `OutputTerm: <INITIAL, Generic>'output' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn output_term(&mut self, output_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output_term = output_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let output_term_built = OutputTerm { output_term };
        // Calling user action here
        self.user_grammar.output_term(&output_term_built)?;
        self.push(ASTType::OutputTerm(output_term_built), context);
        Ok(())
    }

    /// Semantic action for production 99:
    ///
    /// `OutsideTerm: <INITIAL, Generic>'outside' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn outside_term(&mut self, outside_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let outside_term = outside_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let outside_term_built = OutsideTerm { outside_term };
        // Calling user action here
        self.user_grammar.outside_term(&outside_term_built)?;
        self.push(ASTType::OutsideTerm(outside_term_built), context);
        Ok(())
    }

    /// Semantic action for production 100:
    ///
    /// `PackageTerm: <INITIAL, Generic>'package' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn package_term(&mut self, package_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package_term = package_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let package_term_built = PackageTerm { package_term };
        // Calling user action here
        self.user_grammar.package_term(&package_term_built)?;
        self.push(ASTType::PackageTerm(package_term_built), context);
        Ok(())
    }

    /// Semantic action for production 101:
    ///
    /// `ParamTerm: <INITIAL, Generic>'param' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn param_term(&mut self, param_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let param_term = param_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let param_term_built = ParamTerm { param_term };
        // Calling user action here
        self.user_grammar.param_term(&param_term_built)?;
        self.push(ASTType::ParamTerm(param_term_built), context);
        Ok(())
    }

    /// Semantic action for production 102:
    ///
    /// `ProtoTerm: <INITIAL, Generic>'proto' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_term(&mut self, proto_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let proto_term = proto_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let proto_term_built = ProtoTerm { proto_term };
        // Calling user action here
        self.user_grammar.proto_term(&proto_term_built)?;
        self.push(ASTType::ProtoTerm(proto_term_built), context);
        Ok(())
    }

    /// Semantic action for production 103:
    ///
    /// `PubTerm: <INITIAL, Generic>'pub' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn pub_term(&mut self, pub_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let pub_term = pub_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let pub_term_built = PubTerm { pub_term };
        // Calling user action here
        self.user_grammar.pub_term(&pub_term_built)?;
        self.push(ASTType::PubTerm(pub_term_built), context);
        Ok(())
    }

    /// Semantic action for production 104:
    ///
    /// `RepeatTerm: <INITIAL, Generic>'repeat' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn repeat_term(&mut self, repeat_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let repeat_term = repeat_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let repeat_term_built = RepeatTerm { repeat_term };
        // Calling user action here
        self.user_grammar.repeat_term(&repeat_term_built)?;
        self.push(ASTType::RepeatTerm(repeat_term_built), context);
        Ok(())
    }

    /// Semantic action for production 105:
    ///
    /// `ResetTerm: <INITIAL, Generic>'reset' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn reset_term(&mut self, reset_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let reset_term = reset_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let reset_term_built = ResetTerm { reset_term };
        // Calling user action here
        self.user_grammar.reset_term(&reset_term_built)?;
        self.push(ASTType::ResetTerm(reset_term_built), context);
        Ok(())
    }

    /// Semantic action for production 106:
    ///
    /// `ResetAsyncHighTerm: <INITIAL, Generic>'reset_async_high' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn reset_async_high_term(&mut self, reset_async_high_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let reset_async_high_term = reset_async_high_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let reset_async_high_term_built = ResetAsyncHighTerm {
            reset_async_high_term,
        };
        // Calling user action here
        self.user_grammar
            .reset_async_high_term(&reset_async_high_term_built)?;
        self.push(
            ASTType::ResetAsyncHighTerm(reset_async_high_term_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 107:
    ///
    /// `ResetAsyncLowTerm: <INITIAL, Generic>'reset_async_low' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn reset_async_low_term(&mut self, reset_async_low_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let reset_async_low_term = reset_async_low_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let reset_async_low_term_built = ResetAsyncLowTerm {
            reset_async_low_term,
        };
        // Calling user action here
        self.user_grammar
            .reset_async_low_term(&reset_async_low_term_built)?;
        self.push(
            ASTType::ResetAsyncLowTerm(reset_async_low_term_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 108:
    ///
    /// `ResetSyncHighTerm: <INITIAL, Generic>'reset_sync_high' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn reset_sync_high_term(&mut self, reset_sync_high_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let reset_sync_high_term = reset_sync_high_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let reset_sync_high_term_built = ResetSyncHighTerm {
            reset_sync_high_term,
        };
        // Calling user action here
        self.user_grammar
            .reset_sync_high_term(&reset_sync_high_term_built)?;
        self.push(
            ASTType::ResetSyncHighTerm(reset_sync_high_term_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 109:
    ///
    /// `ResetSyncLowTerm: <INITIAL, Generic>'reset_sync_low' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn reset_sync_low_term(&mut self, reset_sync_low_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let reset_sync_low_term = reset_sync_low_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let reset_sync_low_term_built = ResetSyncLowTerm {
            reset_sync_low_term,
        };
        // Calling user action here
        self.user_grammar
            .reset_sync_low_term(&reset_sync_low_term_built)?;
        self.push(
            ASTType::ResetSyncLowTerm(reset_sync_low_term_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 110:
    ///
    /// `ReturnTerm: <INITIAL, Generic>'return' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn return_term(&mut self, return_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let return_term = return_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let return_term_built = ReturnTerm { return_term };
        // Calling user action here
        self.user_grammar.return_term(&return_term_built)?;
        self.push(ASTType::ReturnTerm(return_term_built), context);
        Ok(())
    }

    /// Semantic action for production 111:
    ///
    /// `RevTerm: <INITIAL, Generic>'rev' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn rev_term(&mut self, rev_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let rev_term = rev_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let rev_term_built = RevTerm { rev_term };
        // Calling user action here
        self.user_grammar.rev_term(&rev_term_built)?;
        self.push(ASTType::RevTerm(rev_term_built), context);
        Ok(())
    }

    /// Semantic action for production 112:
    ///
    /// `BreakTerm: <INITIAL, Generic>'break' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn break_term(&mut self, break_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let break_term = break_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let break_term_built = BreakTerm { break_term };
        // Calling user action here
        self.user_grammar.break_term(&break_term_built)?;
        self.push(ASTType::BreakTerm(break_term_built), context);
        Ok(())
    }

    /// Semantic action for production 113:
    ///
    /// `SameTerm: <INITIAL, Generic>'same' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn same_term(&mut self, same_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let same_term = same_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let same_term_built = SameTerm { same_term };
        // Calling user action here
        self.user_grammar.same_term(&same_term_built)?;
        self.push(ASTType::SameTerm(same_term_built), context);
        Ok(())
    }

    /// Semantic action for production 114:
    ///
    /// `SignedTerm: <INITIAL, Generic>'signed' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn signed_term(&mut self, signed_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let signed_term = signed_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let signed_term_built = SignedTerm { signed_term };
        // Calling user action here
        self.user_grammar.signed_term(&signed_term_built)?;
        self.push(ASTType::SignedTerm(signed_term_built), context);
        Ok(())
    }

    /// Semantic action for production 115:
    ///
    /// `StepTerm: <INITIAL, Generic>'step' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn step_term(&mut self, step_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let step_term = step_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let step_term_built = StepTerm { step_term };
        // Calling user action here
        self.user_grammar.step_term(&step_term_built)?;
        self.push(ASTType::StepTerm(step_term_built), context);
        Ok(())
    }

    /// Semantic action for production 116:
    ///
    /// `StringTerm: <INITIAL, Generic>'string' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn string_term(&mut self, string_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string_term = string_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let string_term_built = StringTerm { string_term };
        // Calling user action here
        self.user_grammar.string_term(&string_term_built)?;
        self.push(ASTType::StringTerm(string_term_built), context);
        Ok(())
    }

    /// Semantic action for production 117:
    ///
    /// `StructTerm: <INITIAL, Generic>'struct' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_term(&mut self, struct_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_term = struct_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let struct_term_built = StructTerm { struct_term };
        // Calling user action here
        self.user_grammar.struct_term(&struct_term_built)?;
        self.push(ASTType::StructTerm(struct_term_built), context);
        Ok(())
    }

    /// Semantic action for production 118:
    ///
    /// `SwitchTerm: <INITIAL, Generic>'switch' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn switch_term(&mut self, switch_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let switch_term = switch_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let switch_term_built = SwitchTerm { switch_term };
        // Calling user action here
        self.user_grammar.switch_term(&switch_term_built)?;
        self.push(ASTType::SwitchTerm(switch_term_built), context);
        Ok(())
    }

    /// Semantic action for production 119:
    ///
    /// `TriTerm: <INITIAL, Generic>'tri' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn tri_term(&mut self, tri_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tri_term = tri_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let tri_term_built = TriTerm { tri_term };
        // Calling user action here
        self.user_grammar.tri_term(&tri_term_built)?;
        self.push(ASTType::TriTerm(tri_term_built), context);
        Ok(())
    }

    /// Semantic action for production 120:
    ///
    /// `TrueTerm: <INITIAL, Generic>'true' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn true_term(&mut self, true_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let true_term = true_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let true_term_built = TrueTerm { true_term };
        // Calling user action here
        self.user_grammar.true_term(&true_term_built)?;
        self.push(ASTType::TrueTerm(true_term_built), context);
        Ok(())
    }

    /// Semantic action for production 121:
    ///
    /// `TypeTerm: <INITIAL, Generic>'type' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn type_term(&mut self, type_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_term = type_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let type_term_built = TypeTerm { type_term };
        // Calling user action here
        self.user_grammar.type_term(&type_term_built)?;
        self.push(ASTType::TypeTerm(type_term_built), context);
        Ok(())
    }

    /// Semantic action for production 122:
    ///
    /// `U8Term: <INITIAL, Generic>'u8' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn u8_term(&mut self, u8_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u8_term = u8_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let u8_term_built = U8Term { u8_term };
        // Calling user action here
        self.user_grammar.u8_term(&u8_term_built)?;
        self.push(ASTType::U8Term(u8_term_built), context);
        Ok(())
    }

    /// Semantic action for production 123:
    ///
    /// `U16Term: <INITIAL, Generic>'u16' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn u16_term(&mut self, u16_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u16_term = u16_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let u16_term_built = U16Term { u16_term };
        // Calling user action here
        self.user_grammar.u16_term(&u16_term_built)?;
        self.push(ASTType::U16Term(u16_term_built), context);
        Ok(())
    }

    /// Semantic action for production 124:
    ///
    /// `U32Term: <INITIAL, Generic>'u32' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn u32_term(&mut self, u32_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u32_term = u32_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let u32_term_built = U32Term { u32_term };
        // Calling user action here
        self.user_grammar.u32_term(&u32_term_built)?;
        self.push(ASTType::U32Term(u32_term_built), context);
        Ok(())
    }

    /// Semantic action for production 125:
    ///
    /// `U64Term: <INITIAL, Generic>'u64' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn u64_term(&mut self, u64_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u64_term = u64_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let u64_term_built = U64Term { u64_term };
        // Calling user action here
        self.user_grammar.u64_term(&u64_term_built)?;
        self.push(ASTType::U64Term(u64_term_built), context);
        Ok(())
    }

    /// Semantic action for production 126:
    ///
    /// `UnionTerm: <INITIAL, Generic>'union' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn union_term(&mut self, union_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let union_term = union_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let union_term_built = UnionTerm { union_term };
        // Calling user action here
        self.user_grammar.union_term(&union_term_built)?;
        self.push(ASTType::UnionTerm(union_term_built), context);
        Ok(())
    }

    /// Semantic action for production 127:
    ///
    /// `UnsafeTerm: <INITIAL, Generic>'unsafe' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn unsafe_term(&mut self, unsafe_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unsafe_term = unsafe_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let unsafe_term_built = UnsafeTerm { unsafe_term };
        // Calling user action here
        self.user_grammar.unsafe_term(&unsafe_term_built)?;
        self.push(ASTType::UnsafeTerm(unsafe_term_built), context);
        Ok(())
    }

    /// Semantic action for production 128:
    ///
    /// `VarTerm: <INITIAL, Generic>'var' : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn var_term(&mut self, var_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_term = var_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let var_term_built = VarTerm { var_term };
        // Calling user action here
        self.user_grammar.var_term(&var_term_built)?;
        self.push(ASTType::VarTerm(var_term_built), context);
        Ok(())
    }

    /// Semantic action for production 129:
    ///
    /// `DollarIdentifierTerm: <INITIAL, Generic>/\$[a-zA-Z_][0-9a-zA-Z_$]*/ : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn dollar_identifier_term(&mut self, dollar_identifier_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dollar_identifier_term = dollar_identifier_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let dollar_identifier_term_built = DollarIdentifierTerm {
            dollar_identifier_term,
        };
        // Calling user action here
        self.user_grammar
            .dollar_identifier_term(&dollar_identifier_term_built)?;
        self.push(
            ASTType::DollarIdentifierTerm(dollar_identifier_term_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 130:
    ///
    /// `IdentifierTerm: <INITIAL, EmbedHeader, Generic, Attr>/(?:r#)?[a-zA-Z_][0-9a-zA-Z_$]*/ : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn identifier_term(&mut self, identifier_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier_term = identifier_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let identifier_term_built = IdentifierTerm { identifier_term };
        // Calling user action here
        self.user_grammar.identifier_term(&identifier_term_built)?;
        self.push(ASTType::IdentifierTerm(identifier_term_built), context);
        Ok(())
    }

    /// Semantic action for production 131:
    ///
    /// `AnyTerm: <EmbedBody, EmbedBodyInner>/(?:[^{}\\]|\\[^{])+/ : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn any_term(&mut self, any_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let any_term = any_term
            .token()?
            .try_into()
            .map_err(parol_runtime::ParolError::UserError)?;
        let any_term_built = AnyTerm { any_term };
        // Calling user action here
        self.user_grammar.any_term(&any_term_built)?;
        self.push(ASTType::AnyTerm(any_term_built), context);
        Ok(())
    }

    /// Semantic action for production 132:
    ///
    /// `Comments: CommentsOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn comments(&mut self, _comments_opt: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments_opt = pop_item!(self, comments_opt, CommentsOpt, context);
        let comments_built = Comments { comments_opt };
        // Calling user action here
        self.user_grammar.comments(&comments_built)?;
        self.push(ASTType::Comments(comments_built), context);
        Ok(())
    }

    /// Semantic action for production 133:
    ///
    /// `CommentsOpt /* Option<T>::Some */: CommentsTerm;`
    ///
    #[parol_runtime::function_name::named]
    fn comments_opt_0(&mut self, _comments_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments_term = pop_item!(self, comments_term, CommentsTerm, context);
        let comments_opt_0_built = CommentsOpt {
            comments_term: Box::new(comments_term),
        };
        self.push(ASTType::CommentsOpt(Some(comments_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 134:
    ///
    /// `CommentsOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn comments_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CommentsOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 135:
    ///
    /// `StartToken: Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn start_token(&mut self, _comments: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let start_token_built = StartToken {
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.start_token(&start_token_built)?;
        self.push(ASTType::StartToken(start_token_built), context);
        Ok(())
    }

    /// Semantic action for production 136:
    ///
    /// `StringLiteralToken: StringLiteralTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn string_literal_token(
        &mut self,
        _string_literal_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let string_literal_term = pop_item!(self, string_literal_term, StringLiteralTerm, context);
        let string_literal_token_built = StringLiteralToken {
            string_literal_term: (&string_literal_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .string_literal_token(&string_literal_token_built)?;
        self.push(
            ASTType::StringLiteralToken(string_literal_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 137:
    ///
    /// `ExponentToken: ExponentTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn exponent_token(
        &mut self,
        _exponent_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let exponent_term = pop_item!(self, exponent_term, ExponentTerm, context);
        let exponent_token_built = ExponentToken {
            exponent_term: (&exponent_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.exponent_token(&exponent_token_built)?;
        self.push(ASTType::ExponentToken(exponent_token_built), context);
        Ok(())
    }

    /// Semantic action for production 138:
    ///
    /// `FixedPointToken: FixedPointTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn fixed_point_token(
        &mut self,
        _fixed_point_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let fixed_point_term = pop_item!(self, fixed_point_term, FixedPointTerm, context);
        let fixed_point_token_built = FixedPointToken {
            fixed_point_term: (&fixed_point_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .fixed_point_token(&fixed_point_token_built)?;
        self.push(ASTType::FixedPointToken(fixed_point_token_built), context);
        Ok(())
    }

    /// Semantic action for production 139:
    ///
    /// `BasedToken: BasedTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn based_token(
        &mut self,
        _based_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let based_term = pop_item!(self, based_term, BasedTerm, context);
        let based_token_built = BasedToken {
            based_term: (&based_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.based_token(&based_token_built)?;
        self.push(ASTType::BasedToken(based_token_built), context);
        Ok(())
    }

    /// Semantic action for production 140:
    ///
    /// `BaseLessToken: BaseLessTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn base_less_token(
        &mut self,
        _base_less_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let base_less_term = pop_item!(self, base_less_term, BaseLessTerm, context);
        let base_less_token_built = BaseLessToken {
            base_less_term: (&base_less_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.base_less_token(&base_less_token_built)?;
        self.push(ASTType::BaseLessToken(base_less_token_built), context);
        Ok(())
    }

    /// Semantic action for production 141:
    ///
    /// `AllBitToken: AllBitTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn all_bit_token(
        &mut self,
        _all_bit_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let all_bit_term = pop_item!(self, all_bit_term, AllBitTerm, context);
        let all_bit_token_built = AllBitToken {
            all_bit_term: (&all_bit_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.all_bit_token(&all_bit_token_built)?;
        self.push(ASTType::AllBitToken(all_bit_token_built), context);
        Ok(())
    }

    /// Semantic action for production 142:
    ///
    /// `AssignmentOperatorToken: AssignmentOperatorTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn assignment_operator_token(
        &mut self,
        _assignment_operator_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let assignment_operator_term = pop_item!(
            self,
            assignment_operator_term,
            AssignmentOperatorTerm,
            context
        );
        let assignment_operator_token_built = AssignmentOperatorToken {
            assignment_operator_term: (&assignment_operator_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .assignment_operator_token(&assignment_operator_token_built)?;
        self.push(
            ASTType::AssignmentOperatorToken(assignment_operator_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 143:
    ///
    /// `DiamondOperatorToken: DiamondOperatorTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn diamond_operator_token(
        &mut self,
        _diamond_operator_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let diamond_operator_term =
            pop_item!(self, diamond_operator_term, DiamondOperatorTerm, context);
        let diamond_operator_token_built = DiamondOperatorToken {
            diamond_operator_term: (&diamond_operator_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .diamond_operator_token(&diamond_operator_token_built)?;
        self.push(
            ASTType::DiamondOperatorToken(diamond_operator_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 144:
    ///
    /// `Operator02Token: Operator02Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn operator02_token(
        &mut self,
        _operator02_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator02_term = pop_item!(self, operator02_term, Operator02Term, context);
        let operator02_token_built = Operator02Token {
            operator02_term: (&operator02_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator02_token(&operator02_token_built)?;
        self.push(ASTType::Operator02Token(operator02_token_built), context);
        Ok(())
    }

    /// Semantic action for production 145:
    ///
    /// `Operator03Token: Operator03Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn operator03_token(
        &mut self,
        _operator03_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator03_term = pop_item!(self, operator03_term, Operator03Term, context);
        let operator03_token_built = Operator03Token {
            operator03_term: (&operator03_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator03_token(&operator03_token_built)?;
        self.push(ASTType::Operator03Token(operator03_token_built), context);
        Ok(())
    }

    /// Semantic action for production 146:
    ///
    /// `Operator04Token: Operator04Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn operator04_token(
        &mut self,
        _operator04_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator04_term = pop_item!(self, operator04_term, Operator04Term, context);
        let operator04_token_built = Operator04Token {
            operator04_term: (&operator04_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator04_token(&operator04_token_built)?;
        self.push(ASTType::Operator04Token(operator04_token_built), context);
        Ok(())
    }

    /// Semantic action for production 147:
    ///
    /// `Operator05Token: Operator05Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn operator05_token(
        &mut self,
        _operator05_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator05_term = pop_item!(self, operator05_term, Operator05Term, context);
        let operator05_token_built = Operator05Token {
            operator05_term: (&operator05_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator05_token(&operator05_token_built)?;
        self.push(ASTType::Operator05Token(operator05_token_built), context);
        Ok(())
    }

    /// Semantic action for production 148:
    ///
    /// `Operator06Token: Operator06Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn operator06_token(
        &mut self,
        _operator06_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator06_term = pop_item!(self, operator06_term, Operator06Term, context);
        let operator06_token_built = Operator06Token {
            operator06_term: (&operator06_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator06_token(&operator06_token_built)?;
        self.push(ASTType::Operator06Token(operator06_token_built), context);
        Ok(())
    }

    /// Semantic action for production 149:
    ///
    /// `Operator07Token: Operator07Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn operator07_token(
        &mut self,
        _operator07_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator07_term = pop_item!(self, operator07_term, Operator07Term, context);
        let operator07_token_built = Operator07Token {
            operator07_term: (&operator07_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator07_token(&operator07_token_built)?;
        self.push(ASTType::Operator07Token(operator07_token_built), context);
        Ok(())
    }

    /// Semantic action for production 150:
    ///
    /// `Operator08Token: Operator08Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn operator08_token(
        &mut self,
        _operator08_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator08_term = pop_item!(self, operator08_term, Operator08Term, context);
        let operator08_token_built = Operator08Token {
            operator08_term: (&operator08_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator08_token(&operator08_token_built)?;
        self.push(ASTType::Operator08Token(operator08_token_built), context);
        Ok(())
    }

    /// Semantic action for production 151:
    ///
    /// `Operator09Token: Operator09Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn operator09_token(
        &mut self,
        _operator09_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator09_term = pop_item!(self, operator09_term, Operator09Term, context);
        let operator09_token_built = Operator09Token {
            operator09_term: (&operator09_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator09_token(&operator09_token_built)?;
        self.push(ASTType::Operator09Token(operator09_token_built), context);
        Ok(())
    }

    /// Semantic action for production 152:
    ///
    /// `Operator10Token: Operator10Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn operator10_token(
        &mut self,
        _operator10_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator10_term = pop_item!(self, operator10_term, Operator10Term, context);
        let operator10_token_built = Operator10Token {
            operator10_term: (&operator10_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator10_token(&operator10_token_built)?;
        self.push(ASTType::Operator10Token(operator10_token_built), context);
        Ok(())
    }

    /// Semantic action for production 153:
    ///
    /// `Operator11Token: Operator11Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn operator11_token(
        &mut self,
        _operator11_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator11_term = pop_item!(self, operator11_term, Operator11Term, context);
        let operator11_token_built = Operator11Token {
            operator11_term: (&operator11_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator11_token(&operator11_token_built)?;
        self.push(ASTType::Operator11Token(operator11_token_built), context);
        Ok(())
    }

    /// Semantic action for production 154:
    ///
    /// `Operator12Token: Operator12Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn operator12_token(
        &mut self,
        _operator12_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let operator12_term = pop_item!(self, operator12_term, Operator12Term, context);
        let operator12_token_built = Operator12Token {
            operator12_term: (&operator12_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .operator12_token(&operator12_token_built)?;
        self.push(ASTType::Operator12Token(operator12_token_built), context);
        Ok(())
    }

    /// Semantic action for production 155:
    ///
    /// `UnaryOperatorToken: UnaryOperatorTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn unary_operator_token(
        &mut self,
        _unary_operator_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let unary_operator_term = pop_item!(self, unary_operator_term, UnaryOperatorTerm, context);
        let unary_operator_token_built = UnaryOperatorToken {
            unary_operator_term: (&unary_operator_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .unary_operator_token(&unary_operator_token_built)?;
        self.push(
            ASTType::UnaryOperatorToken(unary_operator_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 156:
    ///
    /// `ColonToken: ColonTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn colon_token(
        &mut self,
        _colon_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let colon_term = pop_item!(self, colon_term, ColonTerm, context);
        let colon_token_built = ColonToken {
            colon_term: (&colon_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.colon_token(&colon_token_built)?;
        self.push(ASTType::ColonToken(colon_token_built), context);
        Ok(())
    }

    /// Semantic action for production 157:
    ///
    /// `ColonColonLAngleToken: ColonColonLAngleTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn colon_colon_l_angle_token(
        &mut self,
        _colon_colon_l_angle_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let colon_colon_l_angle_term = pop_item!(
            self,
            colon_colon_l_angle_term,
            ColonColonLAngleTerm,
            context
        );
        let colon_colon_l_angle_token_built = ColonColonLAngleToken {
            colon_colon_l_angle_term: (&colon_colon_l_angle_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .colon_colon_l_angle_token(&colon_colon_l_angle_token_built)?;
        self.push(
            ASTType::ColonColonLAngleToken(colon_colon_l_angle_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 158:
    ///
    /// `ColonColonToken: ColonColonTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn colon_colon_token(
        &mut self,
        _colon_colon_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let colon_colon_term = pop_item!(self, colon_colon_term, ColonColonTerm, context);
        let colon_colon_token_built = ColonColonToken {
            colon_colon_term: (&colon_colon_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .colon_colon_token(&colon_colon_token_built)?;
        self.push(ASTType::ColonColonToken(colon_colon_token_built), context);
        Ok(())
    }

    /// Semantic action for production 159:
    ///
    /// `CommaToken: CommaTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn comma_token(
        &mut self,
        _comma_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let comma_term = pop_item!(self, comma_term, CommaTerm, context);
        let comma_token_built = CommaToken {
            comma_term: (&comma_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.comma_token(&comma_token_built)?;
        self.push(ASTType::CommaToken(comma_token_built), context);
        Ok(())
    }

    /// Semantic action for production 160:
    ///
    /// `DotDotToken: DotDotTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn dot_dot_token(
        &mut self,
        _dot_dot_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let dot_dot_term = pop_item!(self, dot_dot_term, DotDotTerm, context);
        let dot_dot_token_built = DotDotToken {
            dot_dot_term: (&dot_dot_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.dot_dot_token(&dot_dot_token_built)?;
        self.push(ASTType::DotDotToken(dot_dot_token_built), context);
        Ok(())
    }

    /// Semantic action for production 161:
    ///
    /// `DotDotEquToken: DotDotEquTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn dot_dot_equ_token(
        &mut self,
        _dot_dot_equ_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let dot_dot_equ_term = pop_item!(self, dot_dot_equ_term, DotDotEquTerm, context);
        let dot_dot_equ_token_built = DotDotEquToken {
            dot_dot_equ_term: (&dot_dot_equ_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .dot_dot_equ_token(&dot_dot_equ_token_built)?;
        self.push(ASTType::DotDotEquToken(dot_dot_equ_token_built), context);
        Ok(())
    }

    /// Semantic action for production 162:
    ///
    /// `DotToken: DotTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn dot_token(
        &mut self,
        _dot_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let dot_term = pop_item!(self, dot_term, DotTerm, context);
        let dot_token_built = DotToken {
            dot_term: (&dot_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.dot_token(&dot_token_built)?;
        self.push(ASTType::DotToken(dot_token_built), context);
        Ok(())
    }

    /// Semantic action for production 163:
    ///
    /// `EquToken: EquTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn equ_token(
        &mut self,
        _equ_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let equ_term = pop_item!(self, equ_term, EquTerm, context);
        let equ_token_built = EquToken {
            equ_term: (&equ_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.equ_token(&equ_token_built)?;
        self.push(ASTType::EquToken(equ_token_built), context);
        Ok(())
    }

    /// Semantic action for production 164:
    ///
    /// `HashLBracketToken: HashLBracketTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn hash_l_bracket_token(
        &mut self,
        _hash_l_bracket_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let hash_l_bracket_term = pop_item!(self, hash_l_bracket_term, HashLBracketTerm, context);
        let hash_l_bracket_token_built = HashLBracketToken {
            hash_l_bracket_term: (&hash_l_bracket_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .hash_l_bracket_token(&hash_l_bracket_token_built)?;
        self.push(
            ASTType::HashLBracketToken(hash_l_bracket_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 165:
    ///
    /// `HashToken: HashTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn hash_token(
        &mut self,
        _hash_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let hash_term = pop_item!(self, hash_term, HashTerm, context);
        let hash_token_built = HashToken {
            hash_term: (&hash_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.hash_token(&hash_token_built)?;
        self.push(ASTType::HashToken(hash_token_built), context);
        Ok(())
    }

    /// Semantic action for production 166:
    ///
    /// `QuestionToken: QuestionTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn question_token(
        &mut self,
        _question_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let question_term = pop_item!(self, question_term, QuestionTerm, context);
        let question_token_built = QuestionToken {
            question_term: (&question_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.question_token(&question_token_built)?;
        self.push(ASTType::QuestionToken(question_token_built), context);
        Ok(())
    }

    /// Semantic action for production 167:
    ///
    /// `QuoteLBraceToken: QuoteLBraceTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn quote_l_brace_token(
        &mut self,
        _quote_l_brace_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let quote_l_brace_term = pop_item!(self, quote_l_brace_term, QuoteLBraceTerm, context);
        let quote_l_brace_token_built = QuoteLBraceToken {
            quote_l_brace_term: (&quote_l_brace_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .quote_l_brace_token(&quote_l_brace_token_built)?;
        self.push(
            ASTType::QuoteLBraceToken(quote_l_brace_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 168:
    ///
    /// `QuoteToken: QuoteTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn quote_token(
        &mut self,
        _quote_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let quote_term = pop_item!(self, quote_term, QuoteTerm, context);
        let quote_token_built = QuoteToken {
            quote_term: (&quote_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.quote_token(&quote_token_built)?;
        self.push(ASTType::QuoteToken(quote_token_built), context);
        Ok(())
    }

    /// Semantic action for production 169:
    ///
    /// `LAngleToken: LAngleTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn l_angle_token(
        &mut self,
        _l_angle_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let l_angle_term = pop_item!(self, l_angle_term, LAngleTerm, context);
        let l_angle_token_built = LAngleToken {
            l_angle_term: (&l_angle_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.l_angle_token(&l_angle_token_built)?;
        self.push(ASTType::LAngleToken(l_angle_token_built), context);
        Ok(())
    }

    /// Semantic action for production 170:
    ///
    /// `EmbedLBraceToken: LBraceTerm : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn embed_l_brace_token(&mut self, _l_brace_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_brace_term = pop_item!(self, l_brace_term, LBraceTerm, context);
        let embed_l_brace_token_built = EmbedLBraceToken {
            l_brace_term: (&l_brace_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .embed_l_brace_token(&embed_l_brace_token_built)?;
        self.push(
            ASTType::EmbedLBraceToken(embed_l_brace_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 171:
    ///
    /// `EscapedLBraceToken: EscapedLBraceTerm : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn escaped_l_brace_token(&mut self, _escaped_l_brace_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let escaped_l_brace_term =
            pop_item!(self, escaped_l_brace_term, EscapedLBraceTerm, context);
        let escaped_l_brace_token_built = EscapedLBraceToken {
            escaped_l_brace_term: (&escaped_l_brace_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .escaped_l_brace_token(&escaped_l_brace_token_built)?;
        self.push(
            ASTType::EscapedLBraceToken(escaped_l_brace_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 172:
    ///
    /// `TripleLBraceToken: TripleLBraceTerm : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn triple_l_brace_token(&mut self, _triple_l_brace_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let triple_l_brace_term = pop_item!(self, triple_l_brace_term, TripleLBraceTerm, context);
        let triple_l_brace_token_built = TripleLBraceToken {
            triple_l_brace_term: (&triple_l_brace_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .triple_l_brace_token(&triple_l_brace_token_built)?;
        self.push(
            ASTType::TripleLBraceToken(triple_l_brace_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 173:
    ///
    /// `LBraceToken: LBraceTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn l_brace_token(
        &mut self,
        _l_brace_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let l_brace_term = pop_item!(self, l_brace_term, LBraceTerm, context);
        let l_brace_token_built = LBraceToken {
            l_brace_term: (&l_brace_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.l_brace_token(&l_brace_token_built)?;
        self.push(ASTType::LBraceToken(l_brace_token_built), context);
        Ok(())
    }

    /// Semantic action for production 174:
    ///
    /// `LBracketToken: LBracketTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn l_bracket_token(
        &mut self,
        _l_bracket_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let l_bracket_term = pop_item!(self, l_bracket_term, LBracketTerm, context);
        let l_bracket_token_built = LBracketToken {
            l_bracket_term: (&l_bracket_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.l_bracket_token(&l_bracket_token_built)?;
        self.push(ASTType::LBracketToken(l_bracket_token_built), context);
        Ok(())
    }

    /// Semantic action for production 175:
    ///
    /// `LParenToken: LParenTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn l_paren_token(
        &mut self,
        _l_paren_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let l_paren_term = pop_item!(self, l_paren_term, LParenTerm, context);
        let l_paren_token_built = LParenToken {
            l_paren_term: (&l_paren_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.l_paren_token(&l_paren_token_built)?;
        self.push(ASTType::LParenToken(l_paren_token_built), context);
        Ok(())
    }

    /// Semantic action for production 176:
    ///
    /// `LTMinusToken: LTMinusTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn l_t_minus_token(
        &mut self,
        _l_t_minus_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let l_t_minus_term = pop_item!(self, l_t_minus_term, LTMinusTerm, context);
        let l_t_minus_token_built = LTMinusToken {
            l_t_minus_term: (&l_t_minus_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.l_t_minus_token(&l_t_minus_token_built)?;
        self.push(ASTType::LTMinusToken(l_t_minus_token_built), context);
        Ok(())
    }

    /// Semantic action for production 177:
    ///
    /// `MinusColonToken: MinusColonTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn minus_colon_token(
        &mut self,
        _minus_colon_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let minus_colon_term = pop_item!(self, minus_colon_term, MinusColonTerm, context);
        let minus_colon_token_built = MinusColonToken {
            minus_colon_term: (&minus_colon_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .minus_colon_token(&minus_colon_token_built)?;
        self.push(ASTType::MinusColonToken(minus_colon_token_built), context);
        Ok(())
    }

    /// Semantic action for production 178:
    ///
    /// `MinusGTToken: MinusGTTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn minus_g_t_token(
        &mut self,
        _minus_g_t_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let minus_g_t_term = pop_item!(self, minus_g_t_term, MinusGTTerm, context);
        let minus_g_t_token_built = MinusGTToken {
            minus_g_t_term: (&minus_g_t_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.minus_g_t_token(&minus_g_t_token_built)?;
        self.push(ASTType::MinusGTToken(minus_g_t_token_built), context);
        Ok(())
    }

    /// Semantic action for production 179:
    ///
    /// `PlusColonToken: PlusColonTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn plus_colon_token(
        &mut self,
        _plus_colon_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let plus_colon_term = pop_item!(self, plus_colon_term, PlusColonTerm, context);
        let plus_colon_token_built = PlusColonToken {
            plus_colon_term: (&plus_colon_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .plus_colon_token(&plus_colon_token_built)?;
        self.push(ASTType::PlusColonToken(plus_colon_token_built), context);
        Ok(())
    }

    /// Semantic action for production 180:
    ///
    /// `RAngleToken: RAngleTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn r_angle_token(
        &mut self,
        _r_angle_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let r_angle_term = pop_item!(self, r_angle_term, RAngleTerm, context);
        let r_angle_token_built = RAngleToken {
            r_angle_term: (&r_angle_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.r_angle_token(&r_angle_token_built)?;
        self.push(ASTType::RAngleToken(r_angle_token_built), context);
        Ok(())
    }

    /// Semantic action for production 181:
    ///
    /// `EmbedRBraceToken: RBraceTerm : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn embed_r_brace_token(&mut self, _r_brace_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace_term = pop_item!(self, r_brace_term, RBraceTerm, context);
        let embed_r_brace_token_built = EmbedRBraceToken {
            r_brace_term: (&r_brace_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .embed_r_brace_token(&embed_r_brace_token_built)?;
        self.push(
            ASTType::EmbedRBraceToken(embed_r_brace_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 182:
    ///
    /// `EscapedRBraceToken: EscapedRBraceTerm : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn escaped_r_brace_token(&mut self, _escaped_r_brace_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let escaped_r_brace_term =
            pop_item!(self, escaped_r_brace_term, EscapedRBraceTerm, context);
        let escaped_r_brace_token_built = EscapedRBraceToken {
            escaped_r_brace_term: (&escaped_r_brace_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .escaped_r_brace_token(&escaped_r_brace_token_built)?;
        self.push(
            ASTType::EscapedRBraceToken(escaped_r_brace_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 183:
    ///
    /// `TripleRBraceToken: TripleRBraceTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn triple_r_brace_token(
        &mut self,
        _triple_r_brace_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let triple_r_brace_term = pop_item!(self, triple_r_brace_term, TripleRBraceTerm, context);
        let triple_r_brace_token_built = TripleRBraceToken {
            triple_r_brace_term: (&triple_r_brace_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .triple_r_brace_token(&triple_r_brace_token_built)?;
        self.push(
            ASTType::TripleRBraceToken(triple_r_brace_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 184:
    ///
    /// `RBraceToken: RBraceTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn r_brace_token(
        &mut self,
        _r_brace_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let r_brace_term = pop_item!(self, r_brace_term, RBraceTerm, context);
        let r_brace_token_built = RBraceToken {
            r_brace_term: (&r_brace_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.r_brace_token(&r_brace_token_built)?;
        self.push(ASTType::RBraceToken(r_brace_token_built), context);
        Ok(())
    }

    /// Semantic action for production 185:
    ///
    /// `RBracketToken: RBracketTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn r_bracket_token(
        &mut self,
        _r_bracket_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let r_bracket_term = pop_item!(self, r_bracket_term, RBracketTerm, context);
        let r_bracket_token_built = RBracketToken {
            r_bracket_term: (&r_bracket_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.r_bracket_token(&r_bracket_token_built)?;
        self.push(ASTType::RBracketToken(r_bracket_token_built), context);
        Ok(())
    }

    /// Semantic action for production 186:
    ///
    /// `RParenToken: RParenTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn r_paren_token(
        &mut self,
        _r_paren_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let r_paren_term = pop_item!(self, r_paren_term, RParenTerm, context);
        let r_paren_token_built = RParenToken {
            r_paren_term: (&r_paren_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.r_paren_token(&r_paren_token_built)?;
        self.push(ASTType::RParenToken(r_paren_token_built), context);
        Ok(())
    }

    /// Semantic action for production 187:
    ///
    /// `SemicolonToken: SemicolonTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn semicolon_token(
        &mut self,
        _semicolon_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let semicolon_term = pop_item!(self, semicolon_term, SemicolonTerm, context);
        let semicolon_token_built = SemicolonToken {
            semicolon_term: (&semicolon_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.semicolon_token(&semicolon_token_built)?;
        self.push(ASTType::SemicolonToken(semicolon_token_built), context);
        Ok(())
    }

    /// Semantic action for production 188:
    ///
    /// `StarToken: StarTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn star_token(
        &mut self,
        _star_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let star_term = pop_item!(self, star_term, StarTerm, context);
        let star_token_built = StarToken {
            star_term: (&star_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.star_token(&star_token_built)?;
        self.push(ASTType::StarToken(star_token_built), context);
        Ok(())
    }

    /// Semantic action for production 189:
    ///
    /// `AliasToken: AliasTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn alias_token(
        &mut self,
        _alias_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let alias_term = pop_item!(self, alias_term, AliasTerm, context);
        let alias_token_built = AliasToken {
            alias_term: (&alias_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.alias_token(&alias_token_built)?;
        self.push(ASTType::AliasToken(alias_token_built), context);
        Ok(())
    }

    /// Semantic action for production 190:
    ///
    /// `AlwaysCombToken: AlwaysCombTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_token(
        &mut self,
        _always_comb_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let always_comb_term = pop_item!(self, always_comb_term, AlwaysCombTerm, context);
        let always_comb_token_built = AlwaysCombToken {
            always_comb_term: (&always_comb_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .always_comb_token(&always_comb_token_built)?;
        self.push(ASTType::AlwaysCombToken(always_comb_token_built), context);
        Ok(())
    }

    /// Semantic action for production 191:
    ///
    /// `AlwaysFfToken: AlwaysFfTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_token(
        &mut self,
        _always_ff_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let always_ff_term = pop_item!(self, always_ff_term, AlwaysFfTerm, context);
        let always_ff_token_built = AlwaysFfToken {
            always_ff_term: (&always_ff_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.always_ff_token(&always_ff_token_built)?;
        self.push(ASTType::AlwaysFfToken(always_ff_token_built), context);
        Ok(())
    }

    /// Semantic action for production 192:
    ///
    /// `AsToken: AsTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn as_token(
        &mut self,
        _as_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let as_term = pop_item!(self, as_term, AsTerm, context);
        let as_token_built = AsToken {
            as_term: (&as_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.as_token(&as_token_built)?;
        self.push(ASTType::AsToken(as_token_built), context);
        Ok(())
    }

    /// Semantic action for production 193:
    ///
    /// `AssignToken: AssignTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn assign_token(
        &mut self,
        _assign_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let assign_term = pop_item!(self, assign_term, AssignTerm, context);
        let assign_token_built = AssignToken {
            assign_term: (&assign_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.assign_token(&assign_token_built)?;
        self.push(ASTType::AssignToken(assign_token_built), context);
        Ok(())
    }

    /// Semantic action for production 194:
    ///
    /// `BindToken: BindTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn bind_token(
        &mut self,
        _bind_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let bind_term = pop_item!(self, bind_term, BindTerm, context);
        let bind_token_built = BindToken {
            bind_term: (&bind_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.bind_token(&bind_token_built)?;
        self.push(ASTType::BindToken(bind_token_built), context);
        Ok(())
    }

    /// Semantic action for production 195:
    ///
    /// `BitToken: BitTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn bit_token(
        &mut self,
        _bit_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let bit_term = pop_item!(self, bit_term, BitTerm, context);
        let bit_token_built = BitToken {
            bit_term: (&bit_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.bit_token(&bit_token_built)?;
        self.push(ASTType::BitToken(bit_token_built), context);
        Ok(())
    }

    /// Semantic action for production 196:
    ///
    /// `BoolToken: BoolTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn bool_token(
        &mut self,
        _bool_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let bool_term = pop_item!(self, bool_term, BoolTerm, context);
        let bool_token_built = BoolToken {
            bool_term: (&bool_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.bool_token(&bool_token_built)?;
        self.push(ASTType::BoolToken(bool_token_built), context);
        Ok(())
    }

    /// Semantic action for production 197:
    ///
    /// `CaseToken: CaseTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn case_token(
        &mut self,
        _case_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let case_term = pop_item!(self, case_term, CaseTerm, context);
        let case_token_built = CaseToken {
            case_term: (&case_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.case_token(&case_token_built)?;
        self.push(ASTType::CaseToken(case_token_built), context);
        Ok(())
    }

    /// Semantic action for production 198:
    ///
    /// `ClockToken: ClockTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn clock_token(
        &mut self,
        _clock_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let clock_term = pop_item!(self, clock_term, ClockTerm, context);
        let clock_token_built = ClockToken {
            clock_term: (&clock_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.clock_token(&clock_token_built)?;
        self.push(ASTType::ClockToken(clock_token_built), context);
        Ok(())
    }

    /// Semantic action for production 199:
    ///
    /// `ClockPosedgeToken: ClockPosedgeTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn clock_posedge_token(
        &mut self,
        _clock_posedge_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let clock_posedge_term = pop_item!(self, clock_posedge_term, ClockPosedgeTerm, context);
        let clock_posedge_token_built = ClockPosedgeToken {
            clock_posedge_term: (&clock_posedge_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .clock_posedge_token(&clock_posedge_token_built)?;
        self.push(
            ASTType::ClockPosedgeToken(clock_posedge_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 200:
    ///
    /// `ClockNegedgeToken: ClockNegedgeTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn clock_negedge_token(
        &mut self,
        _clock_negedge_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let clock_negedge_term = pop_item!(self, clock_negedge_term, ClockNegedgeTerm, context);
        let clock_negedge_token_built = ClockNegedgeToken {
            clock_negedge_term: (&clock_negedge_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .clock_negedge_token(&clock_negedge_token_built)?;
        self.push(
            ASTType::ClockNegedgeToken(clock_negedge_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 201:
    ///
    /// `ConnectToken: ConnectTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn connect_token(
        &mut self,
        _connect_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let connect_term = pop_item!(self, connect_term, ConnectTerm, context);
        let connect_token_built = ConnectToken {
            connect_term: (&connect_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.connect_token(&connect_token_built)?;
        self.push(ASTType::ConnectToken(connect_token_built), context);
        Ok(())
    }

    /// Semantic action for production 202:
    ///
    /// `ConstToken: ConstTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn const_token(
        &mut self,
        _const_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let const_term = pop_item!(self, const_term, ConstTerm, context);
        let const_token_built = ConstToken {
            const_term: (&const_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.const_token(&const_token_built)?;
        self.push(ASTType::ConstToken(const_token_built), context);
        Ok(())
    }

    /// Semantic action for production 203:
    ///
    /// `ConverseToken: ConverseTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn converse_token(
        &mut self,
        _converse_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let converse_term = pop_item!(self, converse_term, ConverseTerm, context);
        let converse_token_built = ConverseToken {
            converse_term: (&converse_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.converse_token(&converse_token_built)?;
        self.push(ASTType::ConverseToken(converse_token_built), context);
        Ok(())
    }

    /// Semantic action for production 204:
    ///
    /// `DefaultToken: DefaultTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn default_token(
        &mut self,
        _default_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let default_term = pop_item!(self, default_term, DefaultTerm, context);
        let default_token_built = DefaultToken {
            default_term: (&default_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.default_token(&default_token_built)?;
        self.push(ASTType::DefaultToken(default_token_built), context);
        Ok(())
    }

    /// Semantic action for production 205:
    ///
    /// `ElseToken: ElseTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn else_token(
        &mut self,
        _else_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let else_term = pop_item!(self, else_term, ElseTerm, context);
        let else_token_built = ElseToken {
            else_term: (&else_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.else_token(&else_token_built)?;
        self.push(ASTType::ElseToken(else_token_built), context);
        Ok(())
    }

    /// Semantic action for production 206:
    ///
    /// `EmbedToken: EmbedTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn embed_token(
        &mut self,
        _embed_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let embed_term = pop_item!(self, embed_term, EmbedTerm, context);
        let embed_token_built = EmbedToken {
            embed_term: (&embed_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.embed_token(&embed_token_built)?;
        self.push(ASTType::EmbedToken(embed_token_built), context);
        Ok(())
    }

    /// Semantic action for production 207:
    ///
    /// `EnumToken: EnumTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_token(
        &mut self,
        _enum_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let enum_term = pop_item!(self, enum_term, EnumTerm, context);
        let enum_token_built = EnumToken {
            enum_term: (&enum_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.enum_token(&enum_token_built)?;
        self.push(ASTType::EnumToken(enum_token_built), context);
        Ok(())
    }

    /// Semantic action for production 208:
    ///
    /// `F32Token: F32Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn f32_token(
        &mut self,
        _f32_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let f32_term = pop_item!(self, f32_term, F32Term, context);
        let f32_token_built = F32Token {
            f32_term: (&f32_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.f32_token(&f32_token_built)?;
        self.push(ASTType::F32Token(f32_token_built), context);
        Ok(())
    }

    /// Semantic action for production 209:
    ///
    /// `F64Token: F64Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn f64_token(
        &mut self,
        _f64_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let f64_term = pop_item!(self, f64_term, F64Term, context);
        let f64_token_built = F64Token {
            f64_term: (&f64_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.f64_token(&f64_token_built)?;
        self.push(ASTType::F64Token(f64_token_built), context);
        Ok(())
    }

    /// Semantic action for production 210:
    ///
    /// `FalseToken: FalseTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn false_token(
        &mut self,
        _false_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let false_term = pop_item!(self, false_term, FalseTerm, context);
        let false_token_built = FalseToken {
            false_term: (&false_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.false_token(&false_token_built)?;
        self.push(ASTType::FalseToken(false_token_built), context);
        Ok(())
    }

    /// Semantic action for production 211:
    ///
    /// `FinalToken: FinalTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn final_token(
        &mut self,
        _final_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let final_term = pop_item!(self, final_term, FinalTerm, context);
        let final_token_built = FinalToken {
            final_term: (&final_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.final_token(&final_token_built)?;
        self.push(ASTType::FinalToken(final_token_built), context);
        Ok(())
    }

    /// Semantic action for production 212:
    ///
    /// `ForToken: ForTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn for_token(
        &mut self,
        _for_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let for_term = pop_item!(self, for_term, ForTerm, context);
        let for_token_built = ForToken {
            for_term: (&for_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.for_token(&for_token_built)?;
        self.push(ASTType::ForToken(for_token_built), context);
        Ok(())
    }

    /// Semantic action for production 213:
    ///
    /// `FunctionToken: FunctionTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn function_token(
        &mut self,
        _function_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let function_term = pop_item!(self, function_term, FunctionTerm, context);
        let function_token_built = FunctionToken {
            function_term: (&function_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.function_token(&function_token_built)?;
        self.push(ASTType::FunctionToken(function_token_built), context);
        Ok(())
    }

    /// Semantic action for production 214:
    ///
    /// `I8Token: I8Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn i8_token(
        &mut self,
        _i8_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let i8_term = pop_item!(self, i8_term, I8Term, context);
        let i8_token_built = I8Token {
            i8_term: (&i8_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.i8_token(&i8_token_built)?;
        self.push(ASTType::I8Token(i8_token_built), context);
        Ok(())
    }

    /// Semantic action for production 215:
    ///
    /// `I16Token: I16Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn i16_token(
        &mut self,
        _i16_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let i16_term = pop_item!(self, i16_term, I16Term, context);
        let i16_token_built = I16Token {
            i16_term: (&i16_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.i16_token(&i16_token_built)?;
        self.push(ASTType::I16Token(i16_token_built), context);
        Ok(())
    }

    /// Semantic action for production 216:
    ///
    /// `I32Token: I32Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn i32_token(
        &mut self,
        _i32_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let i32_term = pop_item!(self, i32_term, I32Term, context);
        let i32_token_built = I32Token {
            i32_term: (&i32_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.i32_token(&i32_token_built)?;
        self.push(ASTType::I32Token(i32_token_built), context);
        Ok(())
    }

    /// Semantic action for production 217:
    ///
    /// `I64Token: I64Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn i64_token(
        &mut self,
        _i64_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let i64_term = pop_item!(self, i64_term, I64Term, context);
        let i64_token_built = I64Token {
            i64_term: (&i64_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.i64_token(&i64_token_built)?;
        self.push(ASTType::I64Token(i64_token_built), context);
        Ok(())
    }

    /// Semantic action for production 218:
    ///
    /// `IfResetToken: IfResetTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_token(
        &mut self,
        _if_reset_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let if_reset_term = pop_item!(self, if_reset_term, IfResetTerm, context);
        let if_reset_token_built = IfResetToken {
            if_reset_term: (&if_reset_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.if_reset_token(&if_reset_token_built)?;
        self.push(ASTType::IfResetToken(if_reset_token_built), context);
        Ok(())
    }

    /// Semantic action for production 219:
    ///
    /// `IfToken: IfTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn if_token(
        &mut self,
        _if_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let if_term = pop_item!(self, if_term, IfTerm, context);
        let if_token_built = IfToken {
            if_term: (&if_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.if_token(&if_token_built)?;
        self.push(ASTType::IfToken(if_token_built), context);
        Ok(())
    }

    /// Semantic action for production 220:
    ///
    /// `ImportToken: ImportTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn import_token(
        &mut self,
        _import_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let import_term = pop_item!(self, import_term, ImportTerm, context);
        let import_token_built = ImportToken {
            import_term: (&import_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.import_token(&import_token_built)?;
        self.push(ASTType::ImportToken(import_token_built), context);
        Ok(())
    }

    /// Semantic action for production 221:
    ///
    /// `IncludeToken: IncludeTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn include_token(
        &mut self,
        _include_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let include_term = pop_item!(self, include_term, IncludeTerm, context);
        let include_token_built = IncludeToken {
            include_term: (&include_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.include_token(&include_token_built)?;
        self.push(ASTType::IncludeToken(include_token_built), context);
        Ok(())
    }

    /// Semantic action for production 222:
    ///
    /// `InitialToken: InitialTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn initial_token(
        &mut self,
        _initial_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let initial_term = pop_item!(self, initial_term, InitialTerm, context);
        let initial_token_built = InitialToken {
            initial_term: (&initial_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.initial_token(&initial_token_built)?;
        self.push(ASTType::InitialToken(initial_token_built), context);
        Ok(())
    }

    /// Semantic action for production 223:
    ///
    /// `InoutToken: InoutTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn inout_token(
        &mut self,
        _inout_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let inout_term = pop_item!(self, inout_term, InoutTerm, context);
        let inout_token_built = InoutToken {
            inout_term: (&inout_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.inout_token(&inout_token_built)?;
        self.push(ASTType::InoutToken(inout_token_built), context);
        Ok(())
    }

    /// Semantic action for production 224:
    ///
    /// `InputToken: InputTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn input_token(
        &mut self,
        _input_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let input_term = pop_item!(self, input_term, InputTerm, context);
        let input_token_built = InputToken {
            input_term: (&input_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.input_token(&input_token_built)?;
        self.push(ASTType::InputToken(input_token_built), context);
        Ok(())
    }

    /// Semantic action for production 225:
    ///
    /// `InsideToken: InsideTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn inside_token(
        &mut self,
        _inside_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let inside_term = pop_item!(self, inside_term, InsideTerm, context);
        let inside_token_built = InsideToken {
            inside_term: (&inside_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.inside_token(&inside_token_built)?;
        self.push(ASTType::InsideToken(inside_token_built), context);
        Ok(())
    }

    /// Semantic action for production 226:
    ///
    /// `InstToken: InstTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_token(
        &mut self,
        _inst_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let inst_term = pop_item!(self, inst_term, InstTerm, context);
        let inst_token_built = InstToken {
            inst_term: (&inst_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.inst_token(&inst_token_built)?;
        self.push(ASTType::InstToken(inst_token_built), context);
        Ok(())
    }

    /// Semantic action for production 227:
    ///
    /// `InterfaceToken: InterfaceTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn interface_token(
        &mut self,
        _interface_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let interface_term = pop_item!(self, interface_term, InterfaceTerm, context);
        let interface_token_built = InterfaceToken {
            interface_term: (&interface_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.interface_token(&interface_token_built)?;
        self.push(ASTType::InterfaceToken(interface_token_built), context);
        Ok(())
    }

    /// Semantic action for production 228:
    ///
    /// `InToken: InTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn in_token(
        &mut self,
        _in_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let in_term = pop_item!(self, in_term, InTerm, context);
        let in_token_built = InToken {
            in_term: (&in_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.in_token(&in_token_built)?;
        self.push(ASTType::InToken(in_token_built), context);
        Ok(())
    }

    /// Semantic action for production 229:
    ///
    /// `LetToken: LetTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn let_token(
        &mut self,
        _let_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let let_term = pop_item!(self, let_term, LetTerm, context);
        let let_token_built = LetToken {
            let_term: (&let_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.let_token(&let_token_built)?;
        self.push(ASTType::LetToken(let_token_built), context);
        Ok(())
    }

    /// Semantic action for production 230:
    ///
    /// `LogicToken: LogicTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn logic_token(
        &mut self,
        _logic_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let logic_term = pop_item!(self, logic_term, LogicTerm, context);
        let logic_token_built = LogicToken {
            logic_term: (&logic_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.logic_token(&logic_token_built)?;
        self.push(ASTType::LogicToken(logic_token_built), context);
        Ok(())
    }

    /// Semantic action for production 231:
    ///
    /// `LsbToken: LsbTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn lsb_token(
        &mut self,
        _lsb_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let lsb_term = pop_item!(self, lsb_term, LsbTerm, context);
        let lsb_token_built = LsbToken {
            lsb_term: (&lsb_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.lsb_token(&lsb_token_built)?;
        self.push(ASTType::LsbToken(lsb_token_built), context);
        Ok(())
    }

    /// Semantic action for production 232:
    ///
    /// `ModportToken: ModportTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_token(
        &mut self,
        _modport_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let modport_term = pop_item!(self, modport_term, ModportTerm, context);
        let modport_token_built = ModportToken {
            modport_term: (&modport_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.modport_token(&modport_token_built)?;
        self.push(ASTType::ModportToken(modport_token_built), context);
        Ok(())
    }

    /// Semantic action for production 233:
    ///
    /// `ModuleToken: ModuleTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn module_token(
        &mut self,
        _module_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let module_term = pop_item!(self, module_term, ModuleTerm, context);
        let module_token_built = ModuleToken {
            module_term: (&module_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.module_token(&module_token_built)?;
        self.push(ASTType::ModuleToken(module_token_built), context);
        Ok(())
    }

    /// Semantic action for production 234:
    ///
    /// `MsbToken: MsbTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn msb_token(
        &mut self,
        _msb_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let msb_term = pop_item!(self, msb_term, MsbTerm, context);
        let msb_token_built = MsbToken {
            msb_term: (&msb_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.msb_token(&msb_token_built)?;
        self.push(ASTType::MsbToken(msb_token_built), context);
        Ok(())
    }

    /// Semantic action for production 235:
    ///
    /// `OutputToken: OutputTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn output_token(
        &mut self,
        _output_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let output_term = pop_item!(self, output_term, OutputTerm, context);
        let output_token_built = OutputToken {
            output_term: (&output_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.output_token(&output_token_built)?;
        self.push(ASTType::OutputToken(output_token_built), context);
        Ok(())
    }

    /// Semantic action for production 236:
    ///
    /// `OutsideToken: OutsideTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn outside_token(
        &mut self,
        _outside_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let outside_term = pop_item!(self, outside_term, OutsideTerm, context);
        let outside_token_built = OutsideToken {
            outside_term: (&outside_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.outside_token(&outside_token_built)?;
        self.push(ASTType::OutsideToken(outside_token_built), context);
        Ok(())
    }

    /// Semantic action for production 237:
    ///
    /// `PackageToken: PackageTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn package_token(
        &mut self,
        _package_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let package_term = pop_item!(self, package_term, PackageTerm, context);
        let package_token_built = PackageToken {
            package_term: (&package_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.package_token(&package_token_built)?;
        self.push(ASTType::PackageToken(package_token_built), context);
        Ok(())
    }

    /// Semantic action for production 238:
    ///
    /// `ParamToken: ParamTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn param_token(
        &mut self,
        _param_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let param_term = pop_item!(self, param_term, ParamTerm, context);
        let param_token_built = ParamToken {
            param_term: (&param_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.param_token(&param_token_built)?;
        self.push(ASTType::ParamToken(param_token_built), context);
        Ok(())
    }

    /// Semantic action for production 239:
    ///
    /// `ProtoToken: ProtoTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_token(
        &mut self,
        _proto_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let proto_term = pop_item!(self, proto_term, ProtoTerm, context);
        let proto_token_built = ProtoToken {
            proto_term: (&proto_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.proto_token(&proto_token_built)?;
        self.push(ASTType::ProtoToken(proto_token_built), context);
        Ok(())
    }

    /// Semantic action for production 240:
    ///
    /// `PubToken: PubTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn pub_token(
        &mut self,
        _pub_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let pub_term = pop_item!(self, pub_term, PubTerm, context);
        let pub_token_built = PubToken {
            pub_term: (&pub_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.pub_token(&pub_token_built)?;
        self.push(ASTType::PubToken(pub_token_built), context);
        Ok(())
    }

    /// Semantic action for production 241:
    ///
    /// `RepeatToken: RepeatTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn repeat_token(
        &mut self,
        _repeat_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let repeat_term = pop_item!(self, repeat_term, RepeatTerm, context);
        let repeat_token_built = RepeatToken {
            repeat_term: (&repeat_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.repeat_token(&repeat_token_built)?;
        self.push(ASTType::RepeatToken(repeat_token_built), context);
        Ok(())
    }

    /// Semantic action for production 242:
    ///
    /// `ResetToken: ResetTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn reset_token(
        &mut self,
        _reset_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let reset_term = pop_item!(self, reset_term, ResetTerm, context);
        let reset_token_built = ResetToken {
            reset_term: (&reset_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.reset_token(&reset_token_built)?;
        self.push(ASTType::ResetToken(reset_token_built), context);
        Ok(())
    }

    /// Semantic action for production 243:
    ///
    /// `ResetAsyncHighToken: ResetAsyncHighTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn reset_async_high_token(
        &mut self,
        _reset_async_high_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let reset_async_high_term =
            pop_item!(self, reset_async_high_term, ResetAsyncHighTerm, context);
        let reset_async_high_token_built = ResetAsyncHighToken {
            reset_async_high_term: (&reset_async_high_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .reset_async_high_token(&reset_async_high_token_built)?;
        self.push(
            ASTType::ResetAsyncHighToken(reset_async_high_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 244:
    ///
    /// `ResetAsyncLowToken: ResetAsyncLowTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn reset_async_low_token(
        &mut self,
        _reset_async_low_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let reset_async_low_term =
            pop_item!(self, reset_async_low_term, ResetAsyncLowTerm, context);
        let reset_async_low_token_built = ResetAsyncLowToken {
            reset_async_low_term: (&reset_async_low_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .reset_async_low_token(&reset_async_low_token_built)?;
        self.push(
            ASTType::ResetAsyncLowToken(reset_async_low_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 245:
    ///
    /// `ResetSyncHighToken: ResetSyncHighTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn reset_sync_high_token(
        &mut self,
        _reset_sync_high_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let reset_sync_high_term =
            pop_item!(self, reset_sync_high_term, ResetSyncHighTerm, context);
        let reset_sync_high_token_built = ResetSyncHighToken {
            reset_sync_high_term: (&reset_sync_high_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .reset_sync_high_token(&reset_sync_high_token_built)?;
        self.push(
            ASTType::ResetSyncHighToken(reset_sync_high_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 246:
    ///
    /// `ResetSyncLowToken: ResetSyncLowTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn reset_sync_low_token(
        &mut self,
        _reset_sync_low_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let reset_sync_low_term = pop_item!(self, reset_sync_low_term, ResetSyncLowTerm, context);
        let reset_sync_low_token_built = ResetSyncLowToken {
            reset_sync_low_term: (&reset_sync_low_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .reset_sync_low_token(&reset_sync_low_token_built)?;
        self.push(
            ASTType::ResetSyncLowToken(reset_sync_low_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 247:
    ///
    /// `ReturnToken: ReturnTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn return_token(
        &mut self,
        _return_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let return_term = pop_item!(self, return_term, ReturnTerm, context);
        let return_token_built = ReturnToken {
            return_term: (&return_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.return_token(&return_token_built)?;
        self.push(ASTType::ReturnToken(return_token_built), context);
        Ok(())
    }

    /// Semantic action for production 248:
    ///
    /// `RevToken: RevTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn rev_token(
        &mut self,
        _rev_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let rev_term = pop_item!(self, rev_term, RevTerm, context);
        let rev_token_built = RevToken {
            rev_term: (&rev_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.rev_token(&rev_token_built)?;
        self.push(ASTType::RevToken(rev_token_built), context);
        Ok(())
    }

    /// Semantic action for production 249:
    ///
    /// `BreakToken: BreakTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn break_token(
        &mut self,
        _break_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let break_term = pop_item!(self, break_term, BreakTerm, context);
        let break_token_built = BreakToken {
            break_term: (&break_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.break_token(&break_token_built)?;
        self.push(ASTType::BreakToken(break_token_built), context);
        Ok(())
    }

    /// Semantic action for production 250:
    ///
    /// `SameToken: SameTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn same_token(
        &mut self,
        _same_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let same_term = pop_item!(self, same_term, SameTerm, context);
        let same_token_built = SameToken {
            same_term: (&same_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.same_token(&same_token_built)?;
        self.push(ASTType::SameToken(same_token_built), context);
        Ok(())
    }

    /// Semantic action for production 251:
    ///
    /// `SignedToken: SignedTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn signed_token(
        &mut self,
        _signed_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let signed_term = pop_item!(self, signed_term, SignedTerm, context);
        let signed_token_built = SignedToken {
            signed_term: (&signed_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.signed_token(&signed_token_built)?;
        self.push(ASTType::SignedToken(signed_token_built), context);
        Ok(())
    }

    /// Semantic action for production 252:
    ///
    /// `StepToken: StepTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn step_token(
        &mut self,
        _step_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let step_term = pop_item!(self, step_term, StepTerm, context);
        let step_token_built = StepToken {
            step_term: (&step_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.step_token(&step_token_built)?;
        self.push(ASTType::StepToken(step_token_built), context);
        Ok(())
    }

    /// Semantic action for production 253:
    ///
    /// `StringToken: StringTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn string_token(
        &mut self,
        _string_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let string_term = pop_item!(self, string_term, StringTerm, context);
        let string_token_built = StringToken {
            string_term: (&string_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.string_token(&string_token_built)?;
        self.push(ASTType::StringToken(string_token_built), context);
        Ok(())
    }

    /// Semantic action for production 254:
    ///
    /// `StructToken: StructTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_token(
        &mut self,
        _struct_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let struct_term = pop_item!(self, struct_term, StructTerm, context);
        let struct_token_built = StructToken {
            struct_term: (&struct_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.struct_token(&struct_token_built)?;
        self.push(ASTType::StructToken(struct_token_built), context);
        Ok(())
    }

    /// Semantic action for production 255:
    ///
    /// `SwitchToken: SwitchTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn switch_token(
        &mut self,
        _switch_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let switch_term = pop_item!(self, switch_term, SwitchTerm, context);
        let switch_token_built = SwitchToken {
            switch_term: (&switch_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.switch_token(&switch_token_built)?;
        self.push(ASTType::SwitchToken(switch_token_built), context);
        Ok(())
    }

    /// Semantic action for production 256:
    ///
    /// `TriToken: TriTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn tri_token(
        &mut self,
        _tri_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let tri_term = pop_item!(self, tri_term, TriTerm, context);
        let tri_token_built = TriToken {
            tri_term: (&tri_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.tri_token(&tri_token_built)?;
        self.push(ASTType::TriToken(tri_token_built), context);
        Ok(())
    }

    /// Semantic action for production 257:
    ///
    /// `TrueToken: TrueTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn true_token(
        &mut self,
        _true_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let true_term = pop_item!(self, true_term, TrueTerm, context);
        let true_token_built = TrueToken {
            true_term: (&true_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.true_token(&true_token_built)?;
        self.push(ASTType::TrueToken(true_token_built), context);
        Ok(())
    }

    /// Semantic action for production 258:
    ///
    /// `TypeToken: TypeTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn type_token(
        &mut self,
        _type_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let type_term = pop_item!(self, type_term, TypeTerm, context);
        let type_token_built = TypeToken {
            type_term: (&type_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.type_token(&type_token_built)?;
        self.push(ASTType::TypeToken(type_token_built), context);
        Ok(())
    }

    /// Semantic action for production 259:
    ///
    /// `U8Token: U8Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn u8_token(
        &mut self,
        _u8_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let u8_term = pop_item!(self, u8_term, U8Term, context);
        let u8_token_built = U8Token {
            u8_term: (&u8_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.u8_token(&u8_token_built)?;
        self.push(ASTType::U8Token(u8_token_built), context);
        Ok(())
    }

    /// Semantic action for production 260:
    ///
    /// `U16Token: U16Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn u16_token(
        &mut self,
        _u16_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let u16_term = pop_item!(self, u16_term, U16Term, context);
        let u16_token_built = U16Token {
            u16_term: (&u16_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.u16_token(&u16_token_built)?;
        self.push(ASTType::U16Token(u16_token_built), context);
        Ok(())
    }

    /// Semantic action for production 261:
    ///
    /// `U32Token: U32Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn u32_token(
        &mut self,
        _u32_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let u32_term = pop_item!(self, u32_term, U32Term, context);
        let u32_token_built = U32Token {
            u32_term: (&u32_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.u32_token(&u32_token_built)?;
        self.push(ASTType::U32Token(u32_token_built), context);
        Ok(())
    }

    /// Semantic action for production 262:
    ///
    /// `U64Token: U64Term : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn u64_token(
        &mut self,
        _u64_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let u64_term = pop_item!(self, u64_term, U64Term, context);
        let u64_token_built = U64Token {
            u64_term: (&u64_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.u64_token(&u64_token_built)?;
        self.push(ASTType::U64Token(u64_token_built), context);
        Ok(())
    }

    /// Semantic action for production 263:
    ///
    /// `UnionToken: UnionTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn union_token(
        &mut self,
        _union_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let union_term = pop_item!(self, union_term, UnionTerm, context);
        let union_token_built = UnionToken {
            union_term: (&union_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.union_token(&union_token_built)?;
        self.push(ASTType::UnionToken(union_token_built), context);
        Ok(())
    }

    /// Semantic action for production 264:
    ///
    /// `UnsafeToken: UnsafeTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn unsafe_token(
        &mut self,
        _unsafe_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let unsafe_term = pop_item!(self, unsafe_term, UnsafeTerm, context);
        let unsafe_token_built = UnsafeToken {
            unsafe_term: (&unsafe_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.unsafe_token(&unsafe_token_built)?;
        self.push(ASTType::UnsafeToken(unsafe_token_built), context);
        Ok(())
    }

    /// Semantic action for production 265:
    ///
    /// `VarToken: VarTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn var_token(
        &mut self,
        _var_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let var_term = pop_item!(self, var_term, VarTerm, context);
        let var_token_built = VarToken {
            var_term: (&var_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar.var_token(&var_token_built)?;
        self.push(ASTType::VarToken(var_token_built), context);
        Ok(())
    }

    /// Semantic action for production 266:
    ///
    /// `DollarIdentifierToken: DollarIdentifierTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn dollar_identifier_token(
        &mut self,
        _dollar_identifier_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let dollar_identifier_term =
            pop_item!(self, dollar_identifier_term, DollarIdentifierTerm, context);
        let dollar_identifier_token_built = DollarIdentifierToken {
            dollar_identifier_term: (&dollar_identifier_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .dollar_identifier_token(&dollar_identifier_token_built)?;
        self.push(
            ASTType::DollarIdentifierToken(dollar_identifier_token_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 267:
    ///
    /// `IdentifierToken: IdentifierTerm : Token Comments;`
    ///
    #[parol_runtime::function_name::named]
    fn identifier_token(
        &mut self,
        _identifier_term: &ParseTreeType<'t>,
        _comments: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comments = pop_item!(self, comments, Comments, context);
        let identifier_term = pop_item!(self, identifier_term, IdentifierTerm, context);
        let identifier_token_built = IdentifierToken {
            identifier_term: (&identifier_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
            comments: Box::new(comments),
        };
        // Calling user action here
        self.user_grammar
            .identifier_token(&identifier_token_built)?;
        self.push(ASTType::IdentifierToken(identifier_token_built), context);
        Ok(())
    }

    /// Semantic action for production 268:
    ///
    /// `AnyToken: AnyTerm : Token;`
    ///
    #[parol_runtime::function_name::named]
    fn any_token(&mut self, _any_term: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let any_term = pop_item!(self, any_term, AnyTerm, context);
        let any_token_built = AnyToken {
            any_term: (&any_term)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.any_token(&any_token_built)?;
        self.push(ASTType::AnyToken(any_token_built), context);
        Ok(())
    }

    /// Semantic action for production 269:
    ///
    /// `Start: StartToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn start(&mut self, _start_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let start_token = pop_item!(self, start_token, StartToken, context);
        let start_built = Start {
            start_token: (&start_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.start(&start_built)?;
        self.push(ASTType::Start(start_built), context);
        Ok(())
    }

    /// Semantic action for production 270:
    ///
    /// `StringLiteral: StringLiteralToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn string_literal(&mut self, _string_literal_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string_literal_token =
            pop_item!(self, string_literal_token, StringLiteralToken, context);
        let string_literal_built = StringLiteral {
            string_literal_token: (&string_literal_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.string_literal(&string_literal_built)?;
        self.push(ASTType::StringLiteral(string_literal_built), context);
        Ok(())
    }

    /// Semantic action for production 271:
    ///
    /// `Exponent: ExponentToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn exponent(&mut self, _exponent_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let exponent_token = pop_item!(self, exponent_token, ExponentToken, context);
        let exponent_built = Exponent {
            exponent_token: (&exponent_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.exponent(&exponent_built)?;
        self.push(ASTType::Exponent(exponent_built), context);
        Ok(())
    }

    /// Semantic action for production 272:
    ///
    /// `FixedPoint: FixedPointToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn fixed_point(&mut self, _fixed_point_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fixed_point_token = pop_item!(self, fixed_point_token, FixedPointToken, context);
        let fixed_point_built = FixedPoint {
            fixed_point_token: (&fixed_point_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.fixed_point(&fixed_point_built)?;
        self.push(ASTType::FixedPoint(fixed_point_built), context);
        Ok(())
    }

    /// Semantic action for production 273:
    ///
    /// `Based: BasedToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn based(&mut self, _based_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based_token = pop_item!(self, based_token, BasedToken, context);
        let based_built = Based {
            based_token: (&based_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.based(&based_built)?;
        self.push(ASTType::Based(based_built), context);
        Ok(())
    }

    /// Semantic action for production 274:
    ///
    /// `BaseLess: BaseLessToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn base_less(&mut self, _base_less_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let base_less_token = pop_item!(self, base_less_token, BaseLessToken, context);
        let base_less_built = BaseLess {
            base_less_token: (&base_less_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.base_less(&base_less_built)?;
        self.push(ASTType::BaseLess(base_less_built), context);
        Ok(())
    }

    /// Semantic action for production 275:
    ///
    /// `AllBit: AllBitToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn all_bit(&mut self, _all_bit_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let all_bit_token = pop_item!(self, all_bit_token, AllBitToken, context);
        let all_bit_built = AllBit {
            all_bit_token: (&all_bit_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.all_bit(&all_bit_built)?;
        self.push(ASTType::AllBit(all_bit_built), context);
        Ok(())
    }

    /// Semantic action for production 276:
    ///
    /// `AssignmentOperator: AssignmentOperatorToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn assignment_operator(
        &mut self,
        _assignment_operator_token: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment_operator_token = pop_item!(
            self,
            assignment_operator_token,
            AssignmentOperatorToken,
            context
        );
        let assignment_operator_built = AssignmentOperator {
            assignment_operator_token: (&assignment_operator_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .assignment_operator(&assignment_operator_built)?;
        self.push(
            ASTType::AssignmentOperator(assignment_operator_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 277:
    ///
    /// `DiamondOperator: DiamondOperatorToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn diamond_operator(&mut self, _diamond_operator_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let diamond_operator_token =
            pop_item!(self, diamond_operator_token, DiamondOperatorToken, context);
        let diamond_operator_built = DiamondOperator {
            diamond_operator_token: (&diamond_operator_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .diamond_operator(&diamond_operator_built)?;
        self.push(ASTType::DiamondOperator(diamond_operator_built), context);
        Ok(())
    }

    /// Semantic action for production 278:
    ///
    /// `Operator02: Operator02Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn operator02(&mut self, _operator02_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator02_token = pop_item!(self, operator02_token, Operator02Token, context);
        let operator02_built = Operator02 {
            operator02_token: (&operator02_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator02(&operator02_built)?;
        self.push(ASTType::Operator02(operator02_built), context);
        Ok(())
    }

    /// Semantic action for production 279:
    ///
    /// `Operator03: Operator03Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn operator03(&mut self, _operator03_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator03_token = pop_item!(self, operator03_token, Operator03Token, context);
        let operator03_built = Operator03 {
            operator03_token: (&operator03_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator03(&operator03_built)?;
        self.push(ASTType::Operator03(operator03_built), context);
        Ok(())
    }

    /// Semantic action for production 280:
    ///
    /// `Operator04: Operator04Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn operator04(&mut self, _operator04_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator04_token = pop_item!(self, operator04_token, Operator04Token, context);
        let operator04_built = Operator04 {
            operator04_token: (&operator04_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator04(&operator04_built)?;
        self.push(ASTType::Operator04(operator04_built), context);
        Ok(())
    }

    /// Semantic action for production 281:
    ///
    /// `Operator05: Operator05Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn operator05(&mut self, _operator05_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator05_token = pop_item!(self, operator05_token, Operator05Token, context);
        let operator05_built = Operator05 {
            operator05_token: (&operator05_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator05(&operator05_built)?;
        self.push(ASTType::Operator05(operator05_built), context);
        Ok(())
    }

    /// Semantic action for production 282:
    ///
    /// `Operator06: Operator06Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn operator06(&mut self, _operator06_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator06_token = pop_item!(self, operator06_token, Operator06Token, context);
        let operator06_built = Operator06 {
            operator06_token: (&operator06_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator06(&operator06_built)?;
        self.push(ASTType::Operator06(operator06_built), context);
        Ok(())
    }

    /// Semantic action for production 283:
    ///
    /// `Operator07: Operator07Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn operator07(&mut self, _operator07_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator07_token = pop_item!(self, operator07_token, Operator07Token, context);
        let operator07_built = Operator07 {
            operator07_token: (&operator07_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator07(&operator07_built)?;
        self.push(ASTType::Operator07(operator07_built), context);
        Ok(())
    }

    /// Semantic action for production 284:
    ///
    /// `Operator08: Operator08Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn operator08(&mut self, _operator08_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator08_token = pop_item!(self, operator08_token, Operator08Token, context);
        let operator08_built = Operator08 {
            operator08_token: (&operator08_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator08(&operator08_built)?;
        self.push(ASTType::Operator08(operator08_built), context);
        Ok(())
    }

    /// Semantic action for production 285:
    ///
    /// `Operator09: Operator09Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn operator09(&mut self, _operator09_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator09_token = pop_item!(self, operator09_token, Operator09Token, context);
        let operator09_built = Operator09 {
            operator09_token: (&operator09_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator09(&operator09_built)?;
        self.push(ASTType::Operator09(operator09_built), context);
        Ok(())
    }

    /// Semantic action for production 286:
    ///
    /// `Operator10: Operator10Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn operator10(&mut self, _operator10_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator10_token = pop_item!(self, operator10_token, Operator10Token, context);
        let operator10_built = Operator10 {
            operator10_token: (&operator10_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator10(&operator10_built)?;
        self.push(ASTType::Operator10(operator10_built), context);
        Ok(())
    }

    /// Semantic action for production 287:
    ///
    /// `Operator11: Operator11Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn operator11(&mut self, _operator11_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator11_token = pop_item!(self, operator11_token, Operator11Token, context);
        let operator11_built = Operator11 {
            operator11_token: (&operator11_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator11(&operator11_built)?;
        self.push(ASTType::Operator11(operator11_built), context);
        Ok(())
    }

    /// Semantic action for production 288:
    ///
    /// `Operator12: Operator12Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn operator12(&mut self, _operator12_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator12_token = pop_item!(self, operator12_token, Operator12Token, context);
        let operator12_built = Operator12 {
            operator12_token: (&operator12_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.operator12(&operator12_built)?;
        self.push(ASTType::Operator12(operator12_built), context);
        Ok(())
    }

    /// Semantic action for production 289:
    ///
    /// `UnaryOperator: UnaryOperatorToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn unary_operator(&mut self, _unary_operator_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unary_operator_token =
            pop_item!(self, unary_operator_token, UnaryOperatorToken, context);
        let unary_operator_built = UnaryOperator {
            unary_operator_token: (&unary_operator_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.unary_operator(&unary_operator_built)?;
        self.push(ASTType::UnaryOperator(unary_operator_built), context);
        Ok(())
    }

    /// Semantic action for production 290:
    ///
    /// `Colon: ColonToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn colon(&mut self, _colon_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon_token = pop_item!(self, colon_token, ColonToken, context);
        let colon_built = Colon {
            colon_token: (&colon_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.colon(&colon_built)?;
        self.push(ASTType::Colon(colon_built), context);
        Ok(())
    }

    /// Semantic action for production 291:
    ///
    /// `ColonColonLAngle: ColonColonLAngleToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn colon_colon_l_angle(
        &mut self,
        _colon_colon_l_angle_token: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon_colon_l_angle_token = pop_item!(
            self,
            colon_colon_l_angle_token,
            ColonColonLAngleToken,
            context
        );
        let colon_colon_l_angle_built = ColonColonLAngle {
            colon_colon_l_angle_token: (&colon_colon_l_angle_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .colon_colon_l_angle(&colon_colon_l_angle_built)?;
        self.push(
            ASTType::ColonColonLAngle(colon_colon_l_angle_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 292:
    ///
    /// `ColonColon: ColonColonToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn colon_colon(&mut self, _colon_colon_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon_colon_token = pop_item!(self, colon_colon_token, ColonColonToken, context);
        let colon_colon_built = ColonColon {
            colon_colon_token: (&colon_colon_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.colon_colon(&colon_colon_built)?;
        self.push(ASTType::ColonColon(colon_colon_built), context);
        Ok(())
    }

    /// Semantic action for production 293:
    ///
    /// `Comma: CommaToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn comma(&mut self, _comma_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma_token = pop_item!(self, comma_token, CommaToken, context);
        let comma_built = Comma {
            comma_token: (&comma_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.comma(&comma_built)?;
        self.push(ASTType::Comma(comma_built), context);
        Ok(())
    }

    /// Semantic action for production 294:
    ///
    /// `DotDot: DotDotToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn dot_dot(&mut self, _dot_dot_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_dot_token = pop_item!(self, dot_dot_token, DotDotToken, context);
        let dot_dot_built = DotDot {
            dot_dot_token: (&dot_dot_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.dot_dot(&dot_dot_built)?;
        self.push(ASTType::DotDot(dot_dot_built), context);
        Ok(())
    }

    /// Semantic action for production 295:
    ///
    /// `DotDotEqu: DotDotEquToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn dot_dot_equ(&mut self, _dot_dot_equ_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_dot_equ_token = pop_item!(self, dot_dot_equ_token, DotDotEquToken, context);
        let dot_dot_equ_built = DotDotEqu {
            dot_dot_equ_token: (&dot_dot_equ_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.dot_dot_equ(&dot_dot_equ_built)?;
        self.push(ASTType::DotDotEqu(dot_dot_equ_built), context);
        Ok(())
    }

    /// Semantic action for production 296:
    ///
    /// `Dot: DotToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn dot(&mut self, _dot_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_token = pop_item!(self, dot_token, DotToken, context);
        let dot_built = Dot {
            dot_token: (&dot_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.dot(&dot_built)?;
        self.push(ASTType::Dot(dot_built), context);
        Ok(())
    }

    /// Semantic action for production 297:
    ///
    /// `Equ: EquToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn equ(&mut self, _equ_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ_token = pop_item!(self, equ_token, EquToken, context);
        let equ_built = Equ {
            equ_token: (&equ_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.equ(&equ_built)?;
        self.push(ASTType::Equ(equ_built), context);
        Ok(())
    }

    /// Semantic action for production 298:
    ///
    /// `HashLBracket: HashLBracketToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn hash_l_bracket(&mut self, _hash_l_bracket_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hash_l_bracket_token =
            pop_item!(self, hash_l_bracket_token, HashLBracketToken, context);
        let hash_l_bracket_built = HashLBracket {
            hash_l_bracket_token: (&hash_l_bracket_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.hash_l_bracket(&hash_l_bracket_built)?;
        self.push(ASTType::HashLBracket(hash_l_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 299:
    ///
    /// `Hash: HashToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn hash(&mut self, _hash_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hash_token = pop_item!(self, hash_token, HashToken, context);
        let hash_built = Hash {
            hash_token: (&hash_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.hash(&hash_built)?;
        self.push(ASTType::Hash(hash_built), context);
        Ok(())
    }

    /// Semantic action for production 300:
    ///
    /// `Question: QuestionToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn question(&mut self, _question_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let question_token = pop_item!(self, question_token, QuestionToken, context);
        let question_built = Question {
            question_token: (&question_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.question(&question_built)?;
        self.push(ASTType::Question(question_built), context);
        Ok(())
    }

    /// Semantic action for production 301:
    ///
    /// `QuoteLBrace: QuoteLBraceToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn quote_l_brace(&mut self, _quote_l_brace_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quote_l_brace_token = pop_item!(self, quote_l_brace_token, QuoteLBraceToken, context);
        let quote_l_brace_built = QuoteLBrace {
            quote_l_brace_token: (&quote_l_brace_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.quote_l_brace(&quote_l_brace_built)?;
        self.push(ASTType::QuoteLBrace(quote_l_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 302:
    ///
    /// `Quote: QuoteToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn quote(&mut self, _quote_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let quote_token = pop_item!(self, quote_token, QuoteToken, context);
        let quote_built = Quote {
            quote_token: (&quote_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.quote(&quote_built)?;
        self.push(ASTType::Quote(quote_built), context);
        Ok(())
    }

    /// Semantic action for production 303:
    ///
    /// `LAngle: LAngleToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn l_angle(&mut self, _l_angle_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_angle_token = pop_item!(self, l_angle_token, LAngleToken, context);
        let l_angle_built = LAngle {
            l_angle_token: (&l_angle_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.l_angle(&l_angle_built)?;
        self.push(ASTType::LAngle(l_angle_built), context);
        Ok(())
    }

    /// Semantic action for production 304:
    ///
    /// `EmbedLBrace: EmbedLBraceToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn embed_l_brace(&mut self, _embed_l_brace_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let embed_l_brace_token = pop_item!(self, embed_l_brace_token, EmbedLBraceToken, context);
        let embed_l_brace_built = EmbedLBrace {
            embed_l_brace_token: (&embed_l_brace_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.embed_l_brace(&embed_l_brace_built)?;
        self.push(ASTType::EmbedLBrace(embed_l_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 305:
    ///
    /// `EscapedLBrace: EscapedLBraceToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn escaped_l_brace(&mut self, _escaped_l_brace_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let escaped_l_brace_token =
            pop_item!(self, escaped_l_brace_token, EscapedLBraceToken, context);
        let escaped_l_brace_built = EscapedLBrace {
            escaped_l_brace_token: (&escaped_l_brace_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.escaped_l_brace(&escaped_l_brace_built)?;
        self.push(ASTType::EscapedLBrace(escaped_l_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 306:
    ///
    /// `TripleLBrace: TripleLBraceToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn triple_l_brace(&mut self, _triple_l_brace_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let triple_l_brace_token =
            pop_item!(self, triple_l_brace_token, TripleLBraceToken, context);
        let triple_l_brace_built = TripleLBrace {
            triple_l_brace_token: (&triple_l_brace_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.triple_l_brace(&triple_l_brace_built)?;
        self.push(ASTType::TripleLBrace(triple_l_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 307:
    ///
    /// `LBrace: LBraceToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn l_brace(&mut self, _l_brace_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_brace_token = pop_item!(self, l_brace_token, LBraceToken, context);
        let l_brace_built = LBrace {
            l_brace_token: (&l_brace_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.l_brace(&l_brace_built)?;
        self.push(ASTType::LBrace(l_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 308:
    ///
    /// `LBracket: LBracketToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn l_bracket(&mut self, _l_bracket_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_bracket_token = pop_item!(self, l_bracket_token, LBracketToken, context);
        let l_bracket_built = LBracket {
            l_bracket_token: (&l_bracket_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.l_bracket(&l_bracket_built)?;
        self.push(ASTType::LBracket(l_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 309:
    ///
    /// `LParen: LParenToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn l_paren(&mut self, _l_paren_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_paren_token = pop_item!(self, l_paren_token, LParenToken, context);
        let l_paren_built = LParen {
            l_paren_token: (&l_paren_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.l_paren(&l_paren_built)?;
        self.push(ASTType::LParen(l_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 310:
    ///
    /// `LTMinus: LTMinusToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn l_t_minus(&mut self, _l_t_minus_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let l_t_minus_token = pop_item!(self, l_t_minus_token, LTMinusToken, context);
        let l_t_minus_built = LTMinus {
            l_t_minus_token: (&l_t_minus_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.l_t_minus(&l_t_minus_built)?;
        self.push(ASTType::LTMinus(l_t_minus_built), context);
        Ok(())
    }

    /// Semantic action for production 311:
    ///
    /// `MinusColon: MinusColonToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn minus_colon(&mut self, _minus_colon_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_colon_token = pop_item!(self, minus_colon_token, MinusColonToken, context);
        let minus_colon_built = MinusColon {
            minus_colon_token: (&minus_colon_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.minus_colon(&minus_colon_built)?;
        self.push(ASTType::MinusColon(minus_colon_built), context);
        Ok(())
    }

    /// Semantic action for production 312:
    ///
    /// `MinusGT: MinusGTToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn minus_g_t(&mut self, _minus_g_t_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_g_t_token = pop_item!(self, minus_g_t_token, MinusGTToken, context);
        let minus_g_t_built = MinusGT {
            minus_g_t_token: (&minus_g_t_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.minus_g_t(&minus_g_t_built)?;
        self.push(ASTType::MinusGT(minus_g_t_built), context);
        Ok(())
    }

    /// Semantic action for production 313:
    ///
    /// `PlusColon: PlusColonToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn plus_colon(&mut self, _plus_colon_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus_colon_token = pop_item!(self, plus_colon_token, PlusColonToken, context);
        let plus_colon_built = PlusColon {
            plus_colon_token: (&plus_colon_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.plus_colon(&plus_colon_built)?;
        self.push(ASTType::PlusColon(plus_colon_built), context);
        Ok(())
    }

    /// Semantic action for production 314:
    ///
    /// `RAngle: RAngleToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r_angle(&mut self, _r_angle_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_angle_token = pop_item!(self, r_angle_token, RAngleToken, context);
        let r_angle_built = RAngle {
            r_angle_token: (&r_angle_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r_angle(&r_angle_built)?;
        self.push(ASTType::RAngle(r_angle_built), context);
        Ok(())
    }

    /// Semantic action for production 315:
    ///
    /// `EmbedRBrace: EmbedRBraceToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn embed_r_brace(&mut self, _embed_r_brace_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let embed_r_brace_token = pop_item!(self, embed_r_brace_token, EmbedRBraceToken, context);
        let embed_r_brace_built = EmbedRBrace {
            embed_r_brace_token: (&embed_r_brace_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.embed_r_brace(&embed_r_brace_built)?;
        self.push(ASTType::EmbedRBrace(embed_r_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 316:
    ///
    /// `EscapedRBrace: EscapedRBraceToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn escaped_r_brace(&mut self, _escaped_r_brace_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let escaped_r_brace_token =
            pop_item!(self, escaped_r_brace_token, EscapedRBraceToken, context);
        let escaped_r_brace_built = EscapedRBrace {
            escaped_r_brace_token: (&escaped_r_brace_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.escaped_r_brace(&escaped_r_brace_built)?;
        self.push(ASTType::EscapedRBrace(escaped_r_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 317:
    ///
    /// `TripleRBrace: TripleRBraceToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn triple_r_brace(&mut self, _triple_r_brace_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let triple_r_brace_token =
            pop_item!(self, triple_r_brace_token, TripleRBraceToken, context);
        let triple_r_brace_built = TripleRBrace {
            triple_r_brace_token: (&triple_r_brace_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.triple_r_brace(&triple_r_brace_built)?;
        self.push(ASTType::TripleRBrace(triple_r_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 318:
    ///
    /// `RBrace: RBraceToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r_brace(&mut self, _r_brace_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace_token = pop_item!(self, r_brace_token, RBraceToken, context);
        let r_brace_built = RBrace {
            r_brace_token: (&r_brace_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r_brace(&r_brace_built)?;
        self.push(ASTType::RBrace(r_brace_built), context);
        Ok(())
    }

    /// Semantic action for production 319:
    ///
    /// `RBracket: RBracketToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r_bracket(&mut self, _r_bracket_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket_token = pop_item!(self, r_bracket_token, RBracketToken, context);
        let r_bracket_built = RBracket {
            r_bracket_token: (&r_bracket_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r_bracket(&r_bracket_built)?;
        self.push(ASTType::RBracket(r_bracket_built), context);
        Ok(())
    }

    /// Semantic action for production 320:
    ///
    /// `RParen: RParenToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r_paren(&mut self, _r_paren_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren_token = pop_item!(self, r_paren_token, RParenToken, context);
        let r_paren_built = RParen {
            r_paren_token: (&r_paren_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r_paren(&r_paren_built)?;
        self.push(ASTType::RParen(r_paren_built), context);
        Ok(())
    }

    /// Semantic action for production 321:
    ///
    /// `Semicolon: SemicolonToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn semicolon(&mut self, _semicolon_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon_token = pop_item!(self, semicolon_token, SemicolonToken, context);
        let semicolon_built = Semicolon {
            semicolon_token: (&semicolon_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.semicolon(&semicolon_built)?;
        self.push(ASTType::Semicolon(semicolon_built), context);
        Ok(())
    }

    /// Semantic action for production 322:
    ///
    /// `Star: StarToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn star(&mut self, _star_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star_token = pop_item!(self, star_token, StarToken, context);
        let star_built = Star {
            star_token: (&star_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.star(&star_built)?;
        self.push(ASTType::Star(star_built), context);
        Ok(())
    }

    /// Semantic action for production 323:
    ///
    /// `Alias: AliasToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn alias(&mut self, _alias_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alias_token = pop_item!(self, alias_token, AliasToken, context);
        let alias_built = Alias {
            alias_token: (&alias_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.alias(&alias_built)?;
        self.push(ASTType::Alias(alias_built), context);
        Ok(())
    }

    /// Semantic action for production 324:
    ///
    /// `AlwaysComb: AlwaysCombToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn always_comb(&mut self, _always_comb_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_comb_token = pop_item!(self, always_comb_token, AlwaysCombToken, context);
        let always_comb_built = AlwaysComb {
            always_comb_token: (&always_comb_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.always_comb(&always_comb_built)?;
        self.push(ASTType::AlwaysComb(always_comb_built), context);
        Ok(())
    }

    /// Semantic action for production 325:
    ///
    /// `AlwaysFf: AlwaysFfToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn always_ff(&mut self, _always_ff_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_token = pop_item!(self, always_ff_token, AlwaysFfToken, context);
        let always_ff_built = AlwaysFf {
            always_ff_token: (&always_ff_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.always_ff(&always_ff_built)?;
        self.push(ASTType::AlwaysFf(always_ff_built), context);
        Ok(())
    }

    /// Semantic action for production 326:
    ///
    /// `As: AsToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r#as(&mut self, _as_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let as_token = pop_item!(self, as_token, AsToken, context);
        let r#as_built = As {
            as_token: (&as_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#as(&r#as_built)?;
        self.push(ASTType::As(r#as_built), context);
        Ok(())
    }

    /// Semantic action for production 327:
    ///
    /// `Assign: AssignToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn assign(&mut self, _assign_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign_token = pop_item!(self, assign_token, AssignToken, context);
        let assign_built = Assign {
            assign_token: (&assign_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.assign(&assign_built)?;
        self.push(ASTType::Assign(assign_built), context);
        Ok(())
    }

    /// Semantic action for production 328:
    ///
    /// `Bind: BindToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn bind(&mut self, _bind_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bind_token = pop_item!(self, bind_token, BindToken, context);
        let bind_built = Bind {
            bind_token: (&bind_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.bind(&bind_built)?;
        self.push(ASTType::Bind(bind_built), context);
        Ok(())
    }

    /// Semantic action for production 329:
    ///
    /// `Bit: BitToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn bit(&mut self, _bit_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bit_token = pop_item!(self, bit_token, BitToken, context);
        let bit_built = Bit {
            bit_token: (&bit_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.bit(&bit_built)?;
        self.push(ASTType::Bit(bit_built), context);
        Ok(())
    }

    /// Semantic action for production 330:
    ///
    /// `Bool: BoolToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn bool(&mut self, _bool_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bool_token = pop_item!(self, bool_token, BoolToken, context);
        let bool_built = Bool {
            bool_token: (&bool_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.bool(&bool_built)?;
        self.push(ASTType::Bool(bool_built), context);
        Ok(())
    }

    /// Semantic action for production 331:
    ///
    /// `Break: BreakToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r#break(&mut self, _break_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let break_token = pop_item!(self, break_token, BreakToken, context);
        let r#break_built = Break {
            break_token: (&break_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#break(&r#break_built)?;
        self.push(ASTType::Break(r#break_built), context);
        Ok(())
    }

    /// Semantic action for production 332:
    ///
    /// `Case: CaseToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn case(&mut self, _case_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_token = pop_item!(self, case_token, CaseToken, context);
        let case_built = Case {
            case_token: (&case_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.case(&case_built)?;
        self.push(ASTType::Case(case_built), context);
        Ok(())
    }

    /// Semantic action for production 333:
    ///
    /// `Clock: ClockToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn clock(&mut self, _clock_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let clock_token = pop_item!(self, clock_token, ClockToken, context);
        let clock_built = Clock {
            clock_token: (&clock_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.clock(&clock_built)?;
        self.push(ASTType::Clock(clock_built), context);
        Ok(())
    }

    /// Semantic action for production 334:
    ///
    /// `ClockPosedge: ClockPosedgeToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn clock_posedge(&mut self, _clock_posedge_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let clock_posedge_token = pop_item!(self, clock_posedge_token, ClockPosedgeToken, context);
        let clock_posedge_built = ClockPosedge {
            clock_posedge_token: (&clock_posedge_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.clock_posedge(&clock_posedge_built)?;
        self.push(ASTType::ClockPosedge(clock_posedge_built), context);
        Ok(())
    }

    /// Semantic action for production 335:
    ///
    /// `ClockNegedge: ClockNegedgeToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn clock_negedge(&mut self, _clock_negedge_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let clock_negedge_token = pop_item!(self, clock_negedge_token, ClockNegedgeToken, context);
        let clock_negedge_built = ClockNegedge {
            clock_negedge_token: (&clock_negedge_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.clock_negedge(&clock_negedge_built)?;
        self.push(ASTType::ClockNegedge(clock_negedge_built), context);
        Ok(())
    }

    /// Semantic action for production 336:
    ///
    /// `Connect: ConnectToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn connect(&mut self, _connect_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let connect_token = pop_item!(self, connect_token, ConnectToken, context);
        let connect_built = Connect {
            connect_token: (&connect_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.connect(&connect_built)?;
        self.push(ASTType::Connect(connect_built), context);
        Ok(())
    }

    /// Semantic action for production 337:
    ///
    /// `Const: ConstToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r#const(&mut self, _const_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_token = pop_item!(self, const_token, ConstToken, context);
        let r#const_built = Const {
            const_token: (&const_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#const(&r#const_built)?;
        self.push(ASTType::Const(r#const_built), context);
        Ok(())
    }

    /// Semantic action for production 338:
    ///
    /// `Converse: ConverseToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn converse(&mut self, _converse_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let converse_token = pop_item!(self, converse_token, ConverseToken, context);
        let converse_built = Converse {
            converse_token: (&converse_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.converse(&converse_built)?;
        self.push(ASTType::Converse(converse_built), context);
        Ok(())
    }

    /// Semantic action for production 339:
    ///
    /// `Defaul: DefaultToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn defaul(&mut self, _default_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let default_token = pop_item!(self, default_token, DefaultToken, context);
        let defaul_built = Defaul {
            default_token: (&default_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.defaul(&defaul_built)?;
        self.push(ASTType::Defaul(defaul_built), context);
        Ok(())
    }

    /// Semantic action for production 340:
    ///
    /// `Else: ElseToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r#else(&mut self, _else_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let else_token = pop_item!(self, else_token, ElseToken, context);
        let r#else_built = Else {
            else_token: (&else_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#else(&r#else_built)?;
        self.push(ASTType::Else(r#else_built), context);
        Ok(())
    }

    /// Semantic action for production 341:
    ///
    /// `Embed: EmbedToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn embed(&mut self, _embed_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let embed_token = pop_item!(self, embed_token, EmbedToken, context);
        let embed_built = Embed {
            embed_token: (&embed_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.embed(&embed_built)?;
        self.push(ASTType::Embed(embed_built), context);
        Ok(())
    }

    /// Semantic action for production 342:
    ///
    /// `Enum: EnumToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r#enum(&mut self, _enum_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_token = pop_item!(self, enum_token, EnumToken, context);
        let r#enum_built = Enum {
            enum_token: (&enum_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#enum(&r#enum_built)?;
        self.push(ASTType::Enum(r#enum_built), context);
        Ok(())
    }

    /// Semantic action for production 343:
    ///
    /// `F32: F32Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn f32(&mut self, _f32_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f32_token = pop_item!(self, f32_token, F32Token, context);
        let f32_built = F32 {
            f32_token: (&f32_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.f32(&f32_built)?;
        self.push(ASTType::F32(f32_built), context);
        Ok(())
    }

    /// Semantic action for production 344:
    ///
    /// `F64: F64Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn f64(&mut self, _f64_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f64_token = pop_item!(self, f64_token, F64Token, context);
        let f64_built = F64 {
            f64_token: (&f64_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.f64(&f64_built)?;
        self.push(ASTType::F64(f64_built), context);
        Ok(())
    }

    /// Semantic action for production 345:
    ///
    /// `False: FalseToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r#false(&mut self, _false_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let false_token = pop_item!(self, false_token, FalseToken, context);
        let r#false_built = False {
            false_token: (&false_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#false(&r#false_built)?;
        self.push(ASTType::False(r#false_built), context);
        Ok(())
    }

    /// Semantic action for production 346:
    ///
    /// `Final: FinalToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r#final(&mut self, _final_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let final_token = pop_item!(self, final_token, FinalToken, context);
        let r#final_built = Final {
            final_token: (&final_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#final(&r#final_built)?;
        self.push(ASTType::Final(r#final_built), context);
        Ok(())
    }

    /// Semantic action for production 347:
    ///
    /// `For: ForToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r#for(&mut self, _for_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_token = pop_item!(self, for_token, ForToken, context);
        let r#for_built = For {
            for_token: (&for_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#for(&r#for_built)?;
        self.push(ASTType::For(r#for_built), context);
        Ok(())
    }

    /// Semantic action for production 348:
    ///
    /// `Function: FunctionToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn function(&mut self, _function_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_token = pop_item!(self, function_token, FunctionToken, context);
        let function_built = Function {
            function_token: (&function_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.function(&function_built)?;
        self.push(ASTType::Function(function_built), context);
        Ok(())
    }

    /// Semantic action for production 349:
    ///
    /// `I8: I8Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn i8(&mut self, _i8_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i8_token = pop_item!(self, i8_token, I8Token, context);
        let i8_built = I8 {
            i8_token: (&i8_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.i8(&i8_built)?;
        self.push(ASTType::I8(i8_built), context);
        Ok(())
    }

    /// Semantic action for production 350:
    ///
    /// `I16: I16Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn i16(&mut self, _i16_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i16_token = pop_item!(self, i16_token, I16Token, context);
        let i16_built = I16 {
            i16_token: (&i16_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.i16(&i16_built)?;
        self.push(ASTType::I16(i16_built), context);
        Ok(())
    }

    /// Semantic action for production 351:
    ///
    /// `I32: I32Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn i32(&mut self, _i32_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i32_token = pop_item!(self, i32_token, I32Token, context);
        let i32_built = I32 {
            i32_token: (&i32_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.i32(&i32_built)?;
        self.push(ASTType::I32(i32_built), context);
        Ok(())
    }

    /// Semantic action for production 352:
    ///
    /// `I64: I64Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn i64(&mut self, _i64_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i64_token = pop_item!(self, i64_token, I64Token, context);
        let i64_built = I64 {
            i64_token: (&i64_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.i64(&i64_built)?;
        self.push(ASTType::I64(i64_built), context);
        Ok(())
    }

    /// Semantic action for production 353:
    ///
    /// `If: IfToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r#if(&mut self, _if_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_token = pop_item!(self, if_token, IfToken, context);
        let r#if_built = If {
            if_token: (&if_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#if(&r#if_built)?;
        self.push(ASTType::If(r#if_built), context);
        Ok(())
    }

    /// Semantic action for production 354:
    ///
    /// `IfReset: IfResetToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn if_reset(&mut self, _if_reset_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_token = pop_item!(self, if_reset_token, IfResetToken, context);
        let if_reset_built = IfReset {
            if_reset_token: (&if_reset_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.if_reset(&if_reset_built)?;
        self.push(ASTType::IfReset(if_reset_built), context);
        Ok(())
    }

    /// Semantic action for production 355:
    ///
    /// `Import: ImportToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn import(&mut self, _import_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_token = pop_item!(self, import_token, ImportToken, context);
        let import_built = Import {
            import_token: (&import_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.import(&import_built)?;
        self.push(ASTType::Import(import_built), context);
        Ok(())
    }

    /// Semantic action for production 356:
    ///
    /// `In: InToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r#in(&mut self, _in_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let in_token = pop_item!(self, in_token, InToken, context);
        let r#in_built = In {
            in_token: (&in_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#in(&r#in_built)?;
        self.push(ASTType::In(r#in_built), context);
        Ok(())
    }

    /// Semantic action for production 357:
    ///
    /// `Include: IncludeToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn include(&mut self, _include_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let include_token = pop_item!(self, include_token, IncludeToken, context);
        let include_built = Include {
            include_token: (&include_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.include(&include_built)?;
        self.push(ASTType::Include(include_built), context);
        Ok(())
    }

    /// Semantic action for production 358:
    ///
    /// `Initial: InitialToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn initial(&mut self, _initial_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let initial_token = pop_item!(self, initial_token, InitialToken, context);
        let initial_built = Initial {
            initial_token: (&initial_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.initial(&initial_built)?;
        self.push(ASTType::Initial(initial_built), context);
        Ok(())
    }

    /// Semantic action for production 359:
    ///
    /// `Inout: InoutToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn inout(&mut self, _inout_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inout_token = pop_item!(self, inout_token, InoutToken, context);
        let inout_built = Inout {
            inout_token: (&inout_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.inout(&inout_built)?;
        self.push(ASTType::Inout(inout_built), context);
        Ok(())
    }

    /// Semantic action for production 360:
    ///
    /// `Input: InputToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn input(&mut self, _input_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input_token = pop_item!(self, input_token, InputToken, context);
        let input_built = Input {
            input_token: (&input_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.input(&input_built)?;
        self.push(ASTType::Input(input_built), context);
        Ok(())
    }

    /// Semantic action for production 361:
    ///
    /// `Inside: InsideToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn inside(&mut self, _inside_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inside_token = pop_item!(self, inside_token, InsideToken, context);
        let inside_built = Inside {
            inside_token: (&inside_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.inside(&inside_built)?;
        self.push(ASTType::Inside(inside_built), context);
        Ok(())
    }

    /// Semantic action for production 362:
    ///
    /// `Inst: InstToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn inst(&mut self, _inst_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_token = pop_item!(self, inst_token, InstToken, context);
        let inst_built = Inst {
            inst_token: (&inst_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.inst(&inst_built)?;
        self.push(ASTType::Inst(inst_built), context);
        Ok(())
    }

    /// Semantic action for production 363:
    ///
    /// `Interface: InterfaceToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn interface(&mut self, _interface_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_token = pop_item!(self, interface_token, InterfaceToken, context);
        let interface_built = Interface {
            interface_token: (&interface_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.interface(&interface_built)?;
        self.push(ASTType::Interface(interface_built), context);
        Ok(())
    }

    /// Semantic action for production 364:
    ///
    /// `Let: LetToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r#let(&mut self, _let_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let let_token = pop_item!(self, let_token, LetToken, context);
        let r#let_built = Let {
            let_token: (&let_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#let(&r#let_built)?;
        self.push(ASTType::Let(r#let_built), context);
        Ok(())
    }

    /// Semantic action for production 365:
    ///
    /// `Logic: LogicToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn logic(&mut self, _logic_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logic_token = pop_item!(self, logic_token, LogicToken, context);
        let logic_built = Logic {
            logic_token: (&logic_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.logic(&logic_built)?;
        self.push(ASTType::Logic(logic_built), context);
        Ok(())
    }

    /// Semantic action for production 366:
    ///
    /// `Lsb: LsbToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn lsb(&mut self, _lsb_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let lsb_token = pop_item!(self, lsb_token, LsbToken, context);
        let lsb_built = Lsb {
            lsb_token: (&lsb_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.lsb(&lsb_built)?;
        self.push(ASTType::Lsb(lsb_built), context);
        Ok(())
    }

    /// Semantic action for production 367:
    ///
    /// `Modport: ModportToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn modport(&mut self, _modport_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_token = pop_item!(self, modport_token, ModportToken, context);
        let modport_built = Modport {
            modport_token: (&modport_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.modport(&modport_built)?;
        self.push(ASTType::Modport(modport_built), context);
        Ok(())
    }

    /// Semantic action for production 368:
    ///
    /// `Module: ModuleToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn module(&mut self, _module_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_token = pop_item!(self, module_token, ModuleToken, context);
        let module_built = Module {
            module_token: (&module_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.module(&module_built)?;
        self.push(ASTType::Module(module_built), context);
        Ok(())
    }

    /// Semantic action for production 369:
    ///
    /// `Msb: MsbToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn msb(&mut self, _msb_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let msb_token = pop_item!(self, msb_token, MsbToken, context);
        let msb_built = Msb {
            msb_token: (&msb_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.msb(&msb_built)?;
        self.push(ASTType::Msb(msb_built), context);
        Ok(())
    }

    /// Semantic action for production 370:
    ///
    /// `Output: OutputToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn output(&mut self, _output_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output_token = pop_item!(self, output_token, OutputToken, context);
        let output_built = Output {
            output_token: (&output_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.output(&output_built)?;
        self.push(ASTType::Output(output_built), context);
        Ok(())
    }

    /// Semantic action for production 371:
    ///
    /// `Outside: OutsideToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn outside(&mut self, _outside_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let outside_token = pop_item!(self, outside_token, OutsideToken, context);
        let outside_built = Outside {
            outside_token: (&outside_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.outside(&outside_built)?;
        self.push(ASTType::Outside(outside_built), context);
        Ok(())
    }

    /// Semantic action for production 372:
    ///
    /// `Package: PackageToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn package(&mut self, _package_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package_token = pop_item!(self, package_token, PackageToken, context);
        let package_built = Package {
            package_token: (&package_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.package(&package_built)?;
        self.push(ASTType::Package(package_built), context);
        Ok(())
    }

    /// Semantic action for production 373:
    ///
    /// `Param: ParamToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn param(&mut self, _param_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let param_token = pop_item!(self, param_token, ParamToken, context);
        let param_built = Param {
            param_token: (&param_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.param(&param_built)?;
        self.push(ASTType::Param(param_built), context);
        Ok(())
    }

    /// Semantic action for production 374:
    ///
    /// `Proto: ProtoToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn proto(&mut self, _proto_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let proto_token = pop_item!(self, proto_token, ProtoToken, context);
        let proto_built = Proto {
            proto_token: (&proto_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.proto(&proto_built)?;
        self.push(ASTType::Proto(proto_built), context);
        Ok(())
    }

    /// Semantic action for production 375:
    ///
    /// `Pub: PubToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r#pub(&mut self, _pub_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let pub_token = pop_item!(self, pub_token, PubToken, context);
        let r#pub_built = Pub {
            pub_token: (&pub_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#pub(&r#pub_built)?;
        self.push(ASTType::Pub(r#pub_built), context);
        Ok(())
    }

    /// Semantic action for production 376:
    ///
    /// `Repeat: RepeatToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn repeat(&mut self, _repeat_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let repeat_token = pop_item!(self, repeat_token, RepeatToken, context);
        let repeat_built = Repeat {
            repeat_token: (&repeat_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.repeat(&repeat_built)?;
        self.push(ASTType::Repeat(repeat_built), context);
        Ok(())
    }

    /// Semantic action for production 377:
    ///
    /// `Reset: ResetToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn reset(&mut self, _reset_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let reset_token = pop_item!(self, reset_token, ResetToken, context);
        let reset_built = Reset {
            reset_token: (&reset_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.reset(&reset_built)?;
        self.push(ASTType::Reset(reset_built), context);
        Ok(())
    }

    /// Semantic action for production 378:
    ///
    /// `ResetAsyncHigh: ResetAsyncHighToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn reset_async_high(&mut self, _reset_async_high_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let reset_async_high_token =
            pop_item!(self, reset_async_high_token, ResetAsyncHighToken, context);
        let reset_async_high_built = ResetAsyncHigh {
            reset_async_high_token: (&reset_async_high_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .reset_async_high(&reset_async_high_built)?;
        self.push(ASTType::ResetAsyncHigh(reset_async_high_built), context);
        Ok(())
    }

    /// Semantic action for production 379:
    ///
    /// `ResetAsyncLow: ResetAsyncLowToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn reset_async_low(&mut self, _reset_async_low_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let reset_async_low_token =
            pop_item!(self, reset_async_low_token, ResetAsyncLowToken, context);
        let reset_async_low_built = ResetAsyncLow {
            reset_async_low_token: (&reset_async_low_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.reset_async_low(&reset_async_low_built)?;
        self.push(ASTType::ResetAsyncLow(reset_async_low_built), context);
        Ok(())
    }

    /// Semantic action for production 380:
    ///
    /// `ResetSyncHigh: ResetSyncHighToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn reset_sync_high(&mut self, _reset_sync_high_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let reset_sync_high_token =
            pop_item!(self, reset_sync_high_token, ResetSyncHighToken, context);
        let reset_sync_high_built = ResetSyncHigh {
            reset_sync_high_token: (&reset_sync_high_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.reset_sync_high(&reset_sync_high_built)?;
        self.push(ASTType::ResetSyncHigh(reset_sync_high_built), context);
        Ok(())
    }

    /// Semantic action for production 381:
    ///
    /// `ResetSyncLow: ResetSyncLowToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn reset_sync_low(&mut self, _reset_sync_low_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let reset_sync_low_token =
            pop_item!(self, reset_sync_low_token, ResetSyncLowToken, context);
        let reset_sync_low_built = ResetSyncLow {
            reset_sync_low_token: (&reset_sync_low_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.reset_sync_low(&reset_sync_low_built)?;
        self.push(ASTType::ResetSyncLow(reset_sync_low_built), context);
        Ok(())
    }

    /// Semantic action for production 382:
    ///
    /// `Return: ReturnToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r#return(&mut self, _return_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let return_token = pop_item!(self, return_token, ReturnToken, context);
        let r#return_built = Return {
            return_token: (&return_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#return(&r#return_built)?;
        self.push(ASTType::Return(r#return_built), context);
        Ok(())
    }

    /// Semantic action for production 383:
    ///
    /// `Rev: RevToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn rev(&mut self, _rev_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let rev_token = pop_item!(self, rev_token, RevToken, context);
        let rev_built = Rev {
            rev_token: (&rev_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.rev(&rev_built)?;
        self.push(ASTType::Rev(rev_built), context);
        Ok(())
    }

    /// Semantic action for production 384:
    ///
    /// `Same: SameToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn same(&mut self, _same_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let same_token = pop_item!(self, same_token, SameToken, context);
        let same_built = Same {
            same_token: (&same_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.same(&same_built)?;
        self.push(ASTType::Same(same_built), context);
        Ok(())
    }

    /// Semantic action for production 385:
    ///
    /// `Signed: SignedToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn signed(&mut self, _signed_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let signed_token = pop_item!(self, signed_token, SignedToken, context);
        let signed_built = Signed {
            signed_token: (&signed_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.signed(&signed_built)?;
        self.push(ASTType::Signed(signed_built), context);
        Ok(())
    }

    /// Semantic action for production 386:
    ///
    /// `Step: StepToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn step(&mut self, _step_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let step_token = pop_item!(self, step_token, StepToken, context);
        let step_built = Step {
            step_token: (&step_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.step(&step_built)?;
        self.push(ASTType::Step(step_built), context);
        Ok(())
    }

    /// Semantic action for production 387:
    ///
    /// `Strin: StringToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn strin(&mut self, _string_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string_token = pop_item!(self, string_token, StringToken, context);
        let strin_built = Strin {
            string_token: (&string_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.strin(&strin_built)?;
        self.push(ASTType::Strin(strin_built), context);
        Ok(())
    }

    /// Semantic action for production 388:
    ///
    /// `Struct: StructToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r#struct(&mut self, _struct_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_token = pop_item!(self, struct_token, StructToken, context);
        let r#struct_built = Struct {
            struct_token: (&struct_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#struct(&r#struct_built)?;
        self.push(ASTType::Struct(r#struct_built), context);
        Ok(())
    }

    /// Semantic action for production 389:
    ///
    /// `Switch: SwitchToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn switch(&mut self, _switch_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let switch_token = pop_item!(self, switch_token, SwitchToken, context);
        let switch_built = Switch {
            switch_token: (&switch_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.switch(&switch_built)?;
        self.push(ASTType::Switch(switch_built), context);
        Ok(())
    }

    /// Semantic action for production 390:
    ///
    /// `Tri: TriToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn tri(&mut self, _tri_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tri_token = pop_item!(self, tri_token, TriToken, context);
        let tri_built = Tri {
            tri_token: (&tri_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.tri(&tri_built)?;
        self.push(ASTType::Tri(tri_built), context);
        Ok(())
    }

    /// Semantic action for production 391:
    ///
    /// `True: TrueToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r#true(&mut self, _true_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let true_token = pop_item!(self, true_token, TrueToken, context);
        let r#true_built = True {
            true_token: (&true_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#true(&r#true_built)?;
        self.push(ASTType::True(r#true_built), context);
        Ok(())
    }

    /// Semantic action for production 392:
    ///
    /// `Type: TypeToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r#type(&mut self, _type_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_token = pop_item!(self, type_token, TypeToken, context);
        let r#type_built = Type {
            type_token: (&type_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#type(&r#type_built)?;
        self.push(ASTType::Type(r#type_built), context);
        Ok(())
    }

    /// Semantic action for production 393:
    ///
    /// `U8: U8Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn u8(&mut self, _u8_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u8_token = pop_item!(self, u8_token, U8Token, context);
        let u8_built = U8 {
            u8_token: (&u8_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.u8(&u8_built)?;
        self.push(ASTType::U8(u8_built), context);
        Ok(())
    }

    /// Semantic action for production 394:
    ///
    /// `U16: U16Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn u16(&mut self, _u16_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u16_token = pop_item!(self, u16_token, U16Token, context);
        let u16_built = U16 {
            u16_token: (&u16_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.u16(&u16_built)?;
        self.push(ASTType::U16(u16_built), context);
        Ok(())
    }

    /// Semantic action for production 395:
    ///
    /// `U32: U32Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn u32(&mut self, _u32_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u32_token = pop_item!(self, u32_token, U32Token, context);
        let u32_built = U32 {
            u32_token: (&u32_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.u32(&u32_built)?;
        self.push(ASTType::U32(u32_built), context);
        Ok(())
    }

    /// Semantic action for production 396:
    ///
    /// `U64: U64Token : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn u64(&mut self, _u64_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u64_token = pop_item!(self, u64_token, U64Token, context);
        let u64_built = U64 {
            u64_token: (&u64_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.u64(&u64_built)?;
        self.push(ASTType::U64(u64_built), context);
        Ok(())
    }

    /// Semantic action for production 397:
    ///
    /// `Union: UnionToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r#union(&mut self, _union_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let union_token = pop_item!(self, union_token, UnionToken, context);
        let r#union_built = Union {
            union_token: (&union_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#union(&r#union_built)?;
        self.push(ASTType::Union(r#union_built), context);
        Ok(())
    }

    /// Semantic action for production 398:
    ///
    /// `Unsafe: UnsafeToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn r#unsafe(&mut self, _unsafe_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unsafe_token = pop_item!(self, unsafe_token, UnsafeToken, context);
        let r#unsafe_built = Unsafe {
            unsafe_token: (&unsafe_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.r#unsafe(&r#unsafe_built)?;
        self.push(ASTType::Unsafe(r#unsafe_built), context);
        Ok(())
    }

    /// Semantic action for production 399:
    ///
    /// `Var: VarToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn var(&mut self, _var_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_token = pop_item!(self, var_token, VarToken, context);
        let var_built = Var {
            var_token: (&var_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.var(&var_built)?;
        self.push(ASTType::Var(var_built), context);
        Ok(())
    }

    /// Semantic action for production 400:
    ///
    /// `DollarIdentifier: DollarIdentifierToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn dollar_identifier(&mut self, _dollar_identifier_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dollar_identifier_token = pop_item!(
            self,
            dollar_identifier_token,
            DollarIdentifierToken,
            context
        );
        let dollar_identifier_built = DollarIdentifier {
            dollar_identifier_token: (&dollar_identifier_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar
            .dollar_identifier(&dollar_identifier_built)?;
        self.push(ASTType::DollarIdentifier(dollar_identifier_built), context);
        Ok(())
    }

    /// Semantic action for production 401:
    ///
    /// `Identifier: IdentifierToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn identifier(&mut self, _identifier_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier_token = pop_item!(self, identifier_token, IdentifierToken, context);
        let identifier_built = Identifier {
            identifier_token: (&identifier_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.identifier(&identifier_built)?;
        self.push(ASTType::Identifier(identifier_built), context);
        Ok(())
    }

    /// Semantic action for production 402:
    ///
    /// `Any: AnyToken : VerylToken;`
    ///
    #[parol_runtime::function_name::named]
    fn any(&mut self, _any_token: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let any_token = pop_item!(self, any_token, AnyToken, context);
        let any_built = Any {
            any_token: (&any_token)
                .try_into()
                .map_err(parol_runtime::ParolError::UserError)?,
        };
        // Calling user action here
        self.user_grammar.any(&any_built)?;
        self.push(ASTType::Any(any_built), context);
        Ok(())
    }

    /// Semantic action for production 403:
    ///
    /// `Number: IntegralNumber;`
    ///
    #[parol_runtime::function_name::named]
    fn number_0(&mut self, _integral_number: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let integral_number = pop_item!(self, integral_number, IntegralNumber, context);
        let number_0_built = NumberIntegralNumber {
            integral_number: Box::new(integral_number),
        };
        let number_0_built = Number::IntegralNumber(number_0_built);
        // Calling user action here
        self.user_grammar.number(&number_0_built)?;
        self.push(ASTType::Number(number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 404:
    ///
    /// `Number: RealNumber;`
    ///
    #[parol_runtime::function_name::named]
    fn number_1(&mut self, _real_number: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let real_number = pop_item!(self, real_number, RealNumber, context);
        let number_1_built = NumberRealNumber {
            real_number: Box::new(real_number),
        };
        let number_1_built = Number::RealNumber(number_1_built);
        // Calling user action here
        self.user_grammar.number(&number_1_built)?;
        self.push(ASTType::Number(number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 405:
    ///
    /// `IntegralNumber: Based;`
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_0(&mut self, _based: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based = pop_item!(self, based, Based, context);
        let integral_number_0_built = IntegralNumberBased {
            based: Box::new(based),
        };
        let integral_number_0_built = IntegralNumber::Based(integral_number_0_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_0_built)?;
        self.push(ASTType::IntegralNumber(integral_number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 406:
    ///
    /// `IntegralNumber: BaseLess;`
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_1(&mut self, _base_less: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let base_less = pop_item!(self, base_less, BaseLess, context);
        let integral_number_1_built = IntegralNumberBaseLess {
            base_less: Box::new(base_less),
        };
        let integral_number_1_built = IntegralNumber::BaseLess(integral_number_1_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_1_built)?;
        self.push(ASTType::IntegralNumber(integral_number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 407:
    ///
    /// `IntegralNumber: AllBit;`
    ///
    #[parol_runtime::function_name::named]
    fn integral_number_2(&mut self, _all_bit: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let all_bit = pop_item!(self, all_bit, AllBit, context);
        let integral_number_2_built = IntegralNumberAllBit {
            all_bit: Box::new(all_bit),
        };
        let integral_number_2_built = IntegralNumber::AllBit(integral_number_2_built);
        // Calling user action here
        self.user_grammar
            .integral_number(&integral_number_2_built)?;
        self.push(ASTType::IntegralNumber(integral_number_2_built), context);
        Ok(())
    }

    /// Semantic action for production 408:
    ///
    /// `RealNumber: FixedPoint;`
    ///
    #[parol_runtime::function_name::named]
    fn real_number_0(&mut self, _fixed_point: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fixed_point = pop_item!(self, fixed_point, FixedPoint, context);
        let real_number_0_built = RealNumberFixedPoint {
            fixed_point: Box::new(fixed_point),
        };
        let real_number_0_built = RealNumber::FixedPoint(real_number_0_built);
        // Calling user action here
        self.user_grammar.real_number(&real_number_0_built)?;
        self.push(ASTType::RealNumber(real_number_0_built), context);
        Ok(())
    }

    /// Semantic action for production 409:
    ///
    /// `RealNumber: Exponent;`
    ///
    #[parol_runtime::function_name::named]
    fn real_number_1(&mut self, _exponent: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let exponent = pop_item!(self, exponent, Exponent, context);
        let real_number_1_built = RealNumberExponent {
            exponent: Box::new(exponent),
        };
        let real_number_1_built = RealNumber::Exponent(real_number_1_built);
        // Calling user action here
        self.user_grammar.real_number(&real_number_1_built)?;
        self.push(ASTType::RealNumber(real_number_1_built), context);
        Ok(())
    }

    /// Semantic action for production 410:
    ///
    /// `HierarchicalIdentifier: Identifier HierarchicalIdentifierList /* Vec */ HierarchicalIdentifierList0 /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _hierarchical_identifier_list: &ParseTreeType<'t>,
        _hierarchical_identifier_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hierarchical_identifier_list0 = pop_and_reverse_item!(
            self,
            hierarchical_identifier_list0,
            HierarchicalIdentifierList0,
            context
        );
        let hierarchical_identifier_list = pop_and_reverse_item!(
            self,
            hierarchical_identifier_list,
            HierarchicalIdentifierList,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let hierarchical_identifier_built = HierarchicalIdentifier {
            identifier: Box::new(identifier),
            hierarchical_identifier_list,
            hierarchical_identifier_list0,
        };
        // Calling user action here
        self.user_grammar
            .hierarchical_identifier(&hierarchical_identifier_built)?;
        self.push(
            ASTType::HierarchicalIdentifier(hierarchical_identifier_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 411:
    ///
    /// `HierarchicalIdentifierList0 /* Vec<T>::Push */: Dot Identifier HierarchicalIdentifierList0List /* Vec */ HierarchicalIdentifierList0;`
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier_list0_0(
        &mut self,
        _dot: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _hierarchical_identifier_list0_list: &ParseTreeType<'t>,
        _hierarchical_identifier_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut hierarchical_identifier_list0 = pop_item!(
            self,
            hierarchical_identifier_list0,
            HierarchicalIdentifierList0,
            context
        );
        let hierarchical_identifier_list0_list = pop_and_reverse_item!(
            self,
            hierarchical_identifier_list0_list,
            HierarchicalIdentifierList0List,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let dot = pop_item!(self, dot, Dot, context);
        let hierarchical_identifier_list0_0_built = HierarchicalIdentifierList0 {
            hierarchical_identifier_list0_list,
            identifier: Box::new(identifier),
            dot: Box::new(dot),
        };
        // Add an element to the vector
        hierarchical_identifier_list0.push(hierarchical_identifier_list0_0_built);
        self.push(
            ASTType::HierarchicalIdentifierList0(hierarchical_identifier_list0),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 412:
    ///
    /// `HierarchicalIdentifierList0List /* Vec<T>::Push */: Select HierarchicalIdentifierList0List;`
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier_list0_list_0(
        &mut self,
        _select: &ParseTreeType<'t>,
        _hierarchical_identifier_list0_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut hierarchical_identifier_list0_list = pop_item!(
            self,
            hierarchical_identifier_list0_list,
            HierarchicalIdentifierList0List,
            context
        );
        let select = pop_item!(self, select, Select, context);
        let hierarchical_identifier_list0_list_0_built = HierarchicalIdentifierList0List {
            select: Box::new(select),
        };
        // Add an element to the vector
        hierarchical_identifier_list0_list.push(hierarchical_identifier_list0_list_0_built);
        self.push(
            ASTType::HierarchicalIdentifierList0List(hierarchical_identifier_list0_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 413:
    ///
    /// `HierarchicalIdentifierList0List /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier_list0_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hierarchical_identifier_list0_list_1_built = Vec::new();
        self.push(
            ASTType::HierarchicalIdentifierList0List(hierarchical_identifier_list0_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 414:
    ///
    /// `HierarchicalIdentifierList0 /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier_list0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hierarchical_identifier_list0_1_built = Vec::new();
        self.push(
            ASTType::HierarchicalIdentifierList0(hierarchical_identifier_list0_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 415:
    ///
    /// `HierarchicalIdentifierList /* Vec<T>::Push */: Select HierarchicalIdentifierList;`
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier_list_0(
        &mut self,
        _select: &ParseTreeType<'t>,
        _hierarchical_identifier_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut hierarchical_identifier_list = pop_item!(
            self,
            hierarchical_identifier_list,
            HierarchicalIdentifierList,
            context
        );
        let select = pop_item!(self, select, Select, context);
        let hierarchical_identifier_list_0_built = HierarchicalIdentifierList {
            select: Box::new(select),
        };
        // Add an element to the vector
        hierarchical_identifier_list.push(hierarchical_identifier_list_0_built);
        self.push(
            ASTType::HierarchicalIdentifierList(hierarchical_identifier_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 416:
    ///
    /// `HierarchicalIdentifierList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn hierarchical_identifier_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hierarchical_identifier_list_1_built = Vec::new();
        self.push(
            ASTType::HierarchicalIdentifierList(hierarchical_identifier_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 417:
    ///
    /// `ScopedIdentifier: ScopedIdentifierGroup ScopedIdentifierList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_identifier(
        &mut self,
        _scoped_identifier_group: &ParseTreeType<'t>,
        _scoped_identifier_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_identifier_list =
            pop_and_reverse_item!(self, scoped_identifier_list, ScopedIdentifierList, context);
        let scoped_identifier_group = pop_item!(
            self,
            scoped_identifier_group,
            ScopedIdentifierGroup,
            context
        );
        let scoped_identifier_built = ScopedIdentifier {
            scoped_identifier_group: Box::new(scoped_identifier_group),
            scoped_identifier_list,
        };
        // Calling user action here
        self.user_grammar
            .scoped_identifier(&scoped_identifier_built)?;
        self.push(ASTType::ScopedIdentifier(scoped_identifier_built), context);
        Ok(())
    }

    /// Semantic action for production 418:
    ///
    /// `ScopedIdentifierGroup: DollarIdentifier;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_identifier_group_0(&mut self, _dollar_identifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dollar_identifier = pop_item!(self, dollar_identifier, DollarIdentifier, context);
        let scoped_identifier_group_0_built = ScopedIdentifierGroupDollarIdentifier {
            dollar_identifier: Box::new(dollar_identifier),
        };
        let scoped_identifier_group_0_built =
            ScopedIdentifierGroup::DollarIdentifier(scoped_identifier_group_0_built);
        self.push(
            ASTType::ScopedIdentifierGroup(scoped_identifier_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 419:
    ///
    /// `ScopedIdentifierGroup: Identifier ScopedIdentifierOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_identifier_group_1(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _scoped_identifier_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_identifier_opt =
            pop_item!(self, scoped_identifier_opt, ScopedIdentifierOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let scoped_identifier_group_1_built = ScopedIdentifierGroupIdentifierScopedIdentifierOpt {
            identifier: Box::new(identifier),
            scoped_identifier_opt,
        };
        let scoped_identifier_group_1_built =
            ScopedIdentifierGroup::IdentifierScopedIdentifierOpt(scoped_identifier_group_1_built);
        self.push(
            ASTType::ScopedIdentifierGroup(scoped_identifier_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 420:
    ///
    /// `ScopedIdentifierList /* Vec<T>::Push */: ColonColon Identifier ScopedIdentifierOpt0 /* Option */ ScopedIdentifierList;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_identifier_list_0(
        &mut self,
        _colon_colon: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _scoped_identifier_opt0: &ParseTreeType<'t>,
        _scoped_identifier_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut scoped_identifier_list =
            pop_item!(self, scoped_identifier_list, ScopedIdentifierList, context);
        let scoped_identifier_opt0 =
            pop_item!(self, scoped_identifier_opt0, ScopedIdentifierOpt0, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let colon_colon = pop_item!(self, colon_colon, ColonColon, context);
        let scoped_identifier_list_0_built = ScopedIdentifierList {
            scoped_identifier_opt0,
            identifier: Box::new(identifier),
            colon_colon: Box::new(colon_colon),
        };
        // Add an element to the vector
        scoped_identifier_list.push(scoped_identifier_list_0_built);
        self.push(
            ASTType::ScopedIdentifierList(scoped_identifier_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 421:
    ///
    /// `ScopedIdentifierList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_identifier_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_identifier_list_1_built = Vec::new();
        self.push(
            ASTType::ScopedIdentifierList(scoped_identifier_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 422:
    ///
    /// `ScopedIdentifierOpt0 /* Option<T>::Some */: WithGenericArgument;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_identifier_opt0_0(
        &mut self,
        _with_generic_argument: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_generic_argument =
            pop_item!(self, with_generic_argument, WithGenericArgument, context);
        let scoped_identifier_opt0_0_built = ScopedIdentifierOpt0 {
            with_generic_argument: Box::new(with_generic_argument),
        };
        self.push(
            ASTType::ScopedIdentifierOpt0(Some(scoped_identifier_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 423:
    ///
    /// `ScopedIdentifierOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_identifier_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ScopedIdentifierOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 424:
    ///
    /// `ScopedIdentifierOpt /* Option<T>::Some */: WithGenericArgument;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_identifier_opt_0(
        &mut self,
        _with_generic_argument: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_generic_argument =
            pop_item!(self, with_generic_argument, WithGenericArgument, context);
        let scoped_identifier_opt_0_built = ScopedIdentifierOpt {
            with_generic_argument: Box::new(with_generic_argument),
        };
        self.push(
            ASTType::ScopedIdentifierOpt(Some(scoped_identifier_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 425:
    ///
    /// `ScopedIdentifierOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn scoped_identifier_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ScopedIdentifierOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 426:
    ///
    /// `ExpressionIdentifier: ScopedIdentifier ExpressionIdentifierOpt /* Option */ ExpressionIdentifierList /* Vec */ ExpressionIdentifierList0 /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier(
        &mut self,
        _scoped_identifier: &ParseTreeType<'t>,
        _expression_identifier_opt: &ParseTreeType<'t>,
        _expression_identifier_list: &ParseTreeType<'t>,
        _expression_identifier_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression_identifier_list0 = pop_and_reverse_item!(
            self,
            expression_identifier_list0,
            ExpressionIdentifierList0,
            context
        );
        let expression_identifier_list = pop_and_reverse_item!(
            self,
            expression_identifier_list,
            ExpressionIdentifierList,
            context
        );
        let expression_identifier_opt = pop_item!(
            self,
            expression_identifier_opt,
            ExpressionIdentifierOpt,
            context
        );
        let scoped_identifier = pop_item!(self, scoped_identifier, ScopedIdentifier, context);
        let expression_identifier_built = ExpressionIdentifier {
            scoped_identifier: Box::new(scoped_identifier),
            expression_identifier_opt,
            expression_identifier_list,
            expression_identifier_list0,
        };
        // Calling user action here
        self.user_grammar
            .expression_identifier(&expression_identifier_built)?;
        self.push(
            ASTType::ExpressionIdentifier(expression_identifier_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 427:
    ///
    /// `ExpressionIdentifierList0 /* Vec<T>::Push */: Dot Identifier ExpressionIdentifierList0List /* Vec */ ExpressionIdentifierList0;`
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_list0_0(
        &mut self,
        _dot: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _expression_identifier_list0_list: &ParseTreeType<'t>,
        _expression_identifier_list0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression_identifier_list0 = pop_item!(
            self,
            expression_identifier_list0,
            ExpressionIdentifierList0,
            context
        );
        let expression_identifier_list0_list = pop_and_reverse_item!(
            self,
            expression_identifier_list0_list,
            ExpressionIdentifierList0List,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let dot = pop_item!(self, dot, Dot, context);
        let expression_identifier_list0_0_built = ExpressionIdentifierList0 {
            expression_identifier_list0_list,
            identifier: Box::new(identifier),
            dot: Box::new(dot),
        };
        // Add an element to the vector
        expression_identifier_list0.push(expression_identifier_list0_0_built);
        self.push(
            ASTType::ExpressionIdentifierList0(expression_identifier_list0),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 428:
    ///
    /// `ExpressionIdentifierList0List /* Vec<T>::Push */: Select ExpressionIdentifierList0List;`
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_list0_list_0(
        &mut self,
        _select: &ParseTreeType<'t>,
        _expression_identifier_list0_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression_identifier_list0_list = pop_item!(
            self,
            expression_identifier_list0_list,
            ExpressionIdentifierList0List,
            context
        );
        let select = pop_item!(self, select, Select, context);
        let expression_identifier_list0_list_0_built = ExpressionIdentifierList0List {
            select: Box::new(select),
        };
        // Add an element to the vector
        expression_identifier_list0_list.push(expression_identifier_list0_list_0_built);
        self.push(
            ASTType::ExpressionIdentifierList0List(expression_identifier_list0_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 429:
    ///
    /// `ExpressionIdentifierList0List /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_list0_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression_identifier_list0_list_1_built = Vec::new();
        self.push(
            ASTType::ExpressionIdentifierList0List(expression_identifier_list0_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 430:
    ///
    /// `ExpressionIdentifierList0 /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_list0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression_identifier_list0_1_built = Vec::new();
        self.push(
            ASTType::ExpressionIdentifierList0(expression_identifier_list0_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 431:
    ///
    /// `ExpressionIdentifierList /* Vec<T>::Push */: Select ExpressionIdentifierList;`
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_list_0(
        &mut self,
        _select: &ParseTreeType<'t>,
        _expression_identifier_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression_identifier_list = pop_item!(
            self,
            expression_identifier_list,
            ExpressionIdentifierList,
            context
        );
        let select = pop_item!(self, select, Select, context);
        let expression_identifier_list_0_built = ExpressionIdentifierList {
            select: Box::new(select),
        };
        // Add an element to the vector
        expression_identifier_list.push(expression_identifier_list_0_built);
        self.push(
            ASTType::ExpressionIdentifierList(expression_identifier_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 432:
    ///
    /// `ExpressionIdentifierList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression_identifier_list_1_built = Vec::new();
        self.push(
            ASTType::ExpressionIdentifierList(expression_identifier_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 433:
    ///
    /// `ExpressionIdentifierOpt /* Option<T>::Some */: Width;`
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_opt_0(&mut self, _width: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let width = pop_item!(self, width, Width, context);
        let expression_identifier_opt_0_built = ExpressionIdentifierOpt {
            width: Box::new(width),
        };
        self.push(
            ASTType::ExpressionIdentifierOpt(Some(expression_identifier_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 434:
    ///
    /// `ExpressionIdentifierOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn expression_identifier_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ExpressionIdentifierOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 435:
    ///
    /// `GenericArgIdentifier: ScopedIdentifier GenericArgIdentifierList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn generic_arg_identifier(
        &mut self,
        _scoped_identifier: &ParseTreeType<'t>,
        _generic_arg_identifier_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let generic_arg_identifier_list = pop_and_reverse_item!(
            self,
            generic_arg_identifier_list,
            GenericArgIdentifierList,
            context
        );
        let scoped_identifier = pop_item!(self, scoped_identifier, ScopedIdentifier, context);
        let generic_arg_identifier_built = GenericArgIdentifier {
            scoped_identifier: Box::new(scoped_identifier),
            generic_arg_identifier_list,
        };
        // Calling user action here
        self.user_grammar
            .generic_arg_identifier(&generic_arg_identifier_built)?;
        self.push(
            ASTType::GenericArgIdentifier(generic_arg_identifier_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 436:
    ///
    /// `GenericArgIdentifierList /* Vec<T>::Push */: Dot Identifier GenericArgIdentifierList;`
    ///
    #[parol_runtime::function_name::named]
    fn generic_arg_identifier_list_0(
        &mut self,
        _dot: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _generic_arg_identifier_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut generic_arg_identifier_list = pop_item!(
            self,
            generic_arg_identifier_list,
            GenericArgIdentifierList,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let dot = pop_item!(self, dot, Dot, context);
        let generic_arg_identifier_list_0_built = GenericArgIdentifierList {
            identifier: Box::new(identifier),
            dot: Box::new(dot),
        };
        // Add an element to the vector
        generic_arg_identifier_list.push(generic_arg_identifier_list_0_built);
        self.push(
            ASTType::GenericArgIdentifierList(generic_arg_identifier_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 437:
    ///
    /// `GenericArgIdentifierList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn generic_arg_identifier_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let generic_arg_identifier_list_1_built = Vec::new();
        self.push(
            ASTType::GenericArgIdentifierList(generic_arg_identifier_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 438:
    ///
    /// `Expression: IfExpression;`
    ///
    #[parol_runtime::function_name::named]
    fn expression(&mut self, _if_expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_expression = pop_item!(self, if_expression, IfExpression, context);
        let expression_built = Expression {
            if_expression: Box::new(if_expression),
        };
        // Calling user action here
        self.user_grammar.expression(&expression_built)?;
        self.push(ASTType::Expression(expression_built), context);
        Ok(())
    }

    /// Semantic action for production 439:
    ///
    /// `IfExpression: IfExpressionList /* Vec */ Expression01;`
    ///
    #[parol_runtime::function_name::named]
    fn if_expression(
        &mut self,
        _if_expression_list: &ParseTreeType<'t>,
        _expression01: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression01 = pop_item!(self, expression01, Expression01, context);
        let if_expression_list =
            pop_and_reverse_item!(self, if_expression_list, IfExpressionList, context);
        let if_expression_built = IfExpression {
            if_expression_list,
            expression01: Box::new(expression01),
        };
        // Calling user action here
        self.user_grammar.if_expression(&if_expression_built)?;
        self.push(ASTType::IfExpression(if_expression_built), context);
        Ok(())
    }

    /// Semantic action for production 440:
    ///
    /// `IfExpressionList /* Vec<T>::Push */: If Expression Question Expression Colon IfExpressionList;`
    ///
    #[parol_runtime::function_name::named]
    fn if_expression_list_0(
        &mut self,
        _if: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _question: &ParseTreeType<'t>,
        _expression0: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _if_expression_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_expression_list = pop_item!(self, if_expression_list, IfExpressionList, context);
        let colon = pop_item!(self, colon, Colon, context);
        let expression0 = pop_item!(self, expression0, Expression, context);
        let question = pop_item!(self, question, Question, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let if_expression_list_0_built = IfExpressionList {
            colon: Box::new(colon),
            expression0: Box::new(expression0),
            question: Box::new(question),
            expression: Box::new(expression),
            r#if: Box::new(r#if),
        };
        // Add an element to the vector
        if_expression_list.push(if_expression_list_0_built);
        self.push(ASTType::IfExpressionList(if_expression_list), context);
        Ok(())
    }

    /// Semantic action for production 441:
    ///
    /// `IfExpressionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn if_expression_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_expression_list_1_built = Vec::new();
        self.push(
            ASTType::IfExpressionList(if_expression_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 442:
    ///
    /// `Expression01: Expression02 Expression01List /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn expression01(
        &mut self,
        _expression02: &ParseTreeType<'t>,
        _expression01_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression01_list =
            pop_and_reverse_item!(self, expression01_list, Expression01List, context);
        let expression02 = pop_item!(self, expression02, Expression02, context);
        let expression01_built = Expression01 {
            expression02: Box::new(expression02),
            expression01_list,
        };
        // Calling user action here
        self.user_grammar.expression01(&expression01_built)?;
        self.push(ASTType::Expression01(expression01_built), context);
        Ok(())
    }

    /// Semantic action for production 443:
    ///
    /// `Expression01List /* Vec<T>::Push */: Operator02 Expression02 Expression01List;`
    ///
    #[parol_runtime::function_name::named]
    fn expression01_list_0(
        &mut self,
        _operator02: &ParseTreeType<'t>,
        _expression02: &ParseTreeType<'t>,
        _expression01_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression01_list = pop_item!(self, expression01_list, Expression01List, context);
        let expression02 = pop_item!(self, expression02, Expression02, context);
        let operator02 = pop_item!(self, operator02, Operator02, context);
        let expression01_list_0_built = Expression01List {
            expression02: Box::new(expression02),
            operator02: Box::new(operator02),
        };
        // Add an element to the vector
        expression01_list.push(expression01_list_0_built);
        self.push(ASTType::Expression01List(expression01_list), context);
        Ok(())
    }

    /// Semantic action for production 444:
    ///
    /// `Expression01List /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn expression01_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression01_list_1_built = Vec::new();
        self.push(
            ASTType::Expression01List(expression01_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 445:
    ///
    /// `Expression02: Expression03 Expression02List /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn expression02(
        &mut self,
        _expression03: &ParseTreeType<'t>,
        _expression02_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression02_list =
            pop_and_reverse_item!(self, expression02_list, Expression02List, context);
        let expression03 = pop_item!(self, expression03, Expression03, context);
        let expression02_built = Expression02 {
            expression03: Box::new(expression03),
            expression02_list,
        };
        // Calling user action here
        self.user_grammar.expression02(&expression02_built)?;
        self.push(ASTType::Expression02(expression02_built), context);
        Ok(())
    }

    /// Semantic action for production 446:
    ///
    /// `Expression02List /* Vec<T>::Push */: Operator03 Expression03 Expression02List;`
    ///
    #[parol_runtime::function_name::named]
    fn expression02_list_0(
        &mut self,
        _operator03: &ParseTreeType<'t>,
        _expression03: &ParseTreeType<'t>,
        _expression02_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression02_list = pop_item!(self, expression02_list, Expression02List, context);
        let expression03 = pop_item!(self, expression03, Expression03, context);
        let operator03 = pop_item!(self, operator03, Operator03, context);
        let expression02_list_0_built = Expression02List {
            expression03: Box::new(expression03),
            operator03: Box::new(operator03),
        };
        // Add an element to the vector
        expression02_list.push(expression02_list_0_built);
        self.push(ASTType::Expression02List(expression02_list), context);
        Ok(())
    }

    /// Semantic action for production 447:
    ///
    /// `Expression02List /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn expression02_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression02_list_1_built = Vec::new();
        self.push(
            ASTType::Expression02List(expression02_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 448:
    ///
    /// `Expression03: Expression04 Expression03List /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn expression03(
        &mut self,
        _expression04: &ParseTreeType<'t>,
        _expression03_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression03_list =
            pop_and_reverse_item!(self, expression03_list, Expression03List, context);
        let expression04 = pop_item!(self, expression04, Expression04, context);
        let expression03_built = Expression03 {
            expression04: Box::new(expression04),
            expression03_list,
        };
        // Calling user action here
        self.user_grammar.expression03(&expression03_built)?;
        self.push(ASTType::Expression03(expression03_built), context);
        Ok(())
    }

    /// Semantic action for production 449:
    ///
    /// `Expression03List /* Vec<T>::Push */: Operator04 Expression04 Expression03List;`
    ///
    #[parol_runtime::function_name::named]
    fn expression03_list_0(
        &mut self,
        _operator04: &ParseTreeType<'t>,
        _expression04: &ParseTreeType<'t>,
        _expression03_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression03_list = pop_item!(self, expression03_list, Expression03List, context);
        let expression04 = pop_item!(self, expression04, Expression04, context);
        let operator04 = pop_item!(self, operator04, Operator04, context);
        let expression03_list_0_built = Expression03List {
            expression04: Box::new(expression04),
            operator04: Box::new(operator04),
        };
        // Add an element to the vector
        expression03_list.push(expression03_list_0_built);
        self.push(ASTType::Expression03List(expression03_list), context);
        Ok(())
    }

    /// Semantic action for production 450:
    ///
    /// `Expression03List /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn expression03_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression03_list_1_built = Vec::new();
        self.push(
            ASTType::Expression03List(expression03_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 451:
    ///
    /// `Expression04: Expression05 Expression04List /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn expression04(
        &mut self,
        _expression05: &ParseTreeType<'t>,
        _expression04_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression04_list =
            pop_and_reverse_item!(self, expression04_list, Expression04List, context);
        let expression05 = pop_item!(self, expression05, Expression05, context);
        let expression04_built = Expression04 {
            expression05: Box::new(expression05),
            expression04_list,
        };
        // Calling user action here
        self.user_grammar.expression04(&expression04_built)?;
        self.push(ASTType::Expression04(expression04_built), context);
        Ok(())
    }

    /// Semantic action for production 452:
    ///
    /// `Expression04List /* Vec<T>::Push */: Operator05 Expression05 Expression04List;`
    ///
    #[parol_runtime::function_name::named]
    fn expression04_list_0(
        &mut self,
        _operator05: &ParseTreeType<'t>,
        _expression05: &ParseTreeType<'t>,
        _expression04_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression04_list = pop_item!(self, expression04_list, Expression04List, context);
        let expression05 = pop_item!(self, expression05, Expression05, context);
        let operator05 = pop_item!(self, operator05, Operator05, context);
        let expression04_list_0_built = Expression04List {
            expression05: Box::new(expression05),
            operator05: Box::new(operator05),
        };
        // Add an element to the vector
        expression04_list.push(expression04_list_0_built);
        self.push(ASTType::Expression04List(expression04_list), context);
        Ok(())
    }

    /// Semantic action for production 453:
    ///
    /// `Expression04List /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn expression04_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression04_list_1_built = Vec::new();
        self.push(
            ASTType::Expression04List(expression04_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 454:
    ///
    /// `Expression05: Expression06 Expression05List /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn expression05(
        &mut self,
        _expression06: &ParseTreeType<'t>,
        _expression05_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression05_list =
            pop_and_reverse_item!(self, expression05_list, Expression05List, context);
        let expression06 = pop_item!(self, expression06, Expression06, context);
        let expression05_built = Expression05 {
            expression06: Box::new(expression06),
            expression05_list,
        };
        // Calling user action here
        self.user_grammar.expression05(&expression05_built)?;
        self.push(ASTType::Expression05(expression05_built), context);
        Ok(())
    }

    /// Semantic action for production 455:
    ///
    /// `Expression05List /* Vec<T>::Push */: Operator06 Expression06 Expression05List;`
    ///
    #[parol_runtime::function_name::named]
    fn expression05_list_0(
        &mut self,
        _operator06: &ParseTreeType<'t>,
        _expression06: &ParseTreeType<'t>,
        _expression05_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression05_list = pop_item!(self, expression05_list, Expression05List, context);
        let expression06 = pop_item!(self, expression06, Expression06, context);
        let operator06 = pop_item!(self, operator06, Operator06, context);
        let expression05_list_0_built = Expression05List {
            expression06: Box::new(expression06),
            operator06: Box::new(operator06),
        };
        // Add an element to the vector
        expression05_list.push(expression05_list_0_built);
        self.push(ASTType::Expression05List(expression05_list), context);
        Ok(())
    }

    /// Semantic action for production 456:
    ///
    /// `Expression05List /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn expression05_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression05_list_1_built = Vec::new();
        self.push(
            ASTType::Expression05List(expression05_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 457:
    ///
    /// `Expression06: Expression07 Expression06List /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn expression06(
        &mut self,
        _expression07: &ParseTreeType<'t>,
        _expression06_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression06_list =
            pop_and_reverse_item!(self, expression06_list, Expression06List, context);
        let expression07 = pop_item!(self, expression07, Expression07, context);
        let expression06_built = Expression06 {
            expression07: Box::new(expression07),
            expression06_list,
        };
        // Calling user action here
        self.user_grammar.expression06(&expression06_built)?;
        self.push(ASTType::Expression06(expression06_built), context);
        Ok(())
    }

    /// Semantic action for production 458:
    ///
    /// `Expression06List /* Vec<T>::Push */: Operator07 Expression07 Expression06List;`
    ///
    #[parol_runtime::function_name::named]
    fn expression06_list_0(
        &mut self,
        _operator07: &ParseTreeType<'t>,
        _expression07: &ParseTreeType<'t>,
        _expression06_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression06_list = pop_item!(self, expression06_list, Expression06List, context);
        let expression07 = pop_item!(self, expression07, Expression07, context);
        let operator07 = pop_item!(self, operator07, Operator07, context);
        let expression06_list_0_built = Expression06List {
            expression07: Box::new(expression07),
            operator07: Box::new(operator07),
        };
        // Add an element to the vector
        expression06_list.push(expression06_list_0_built);
        self.push(ASTType::Expression06List(expression06_list), context);
        Ok(())
    }

    /// Semantic action for production 459:
    ///
    /// `Expression06List /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn expression06_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression06_list_1_built = Vec::new();
        self.push(
            ASTType::Expression06List(expression06_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 460:
    ///
    /// `Expression07: Expression08 Expression07List /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn expression07(
        &mut self,
        _expression08: &ParseTreeType<'t>,
        _expression07_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression07_list =
            pop_and_reverse_item!(self, expression07_list, Expression07List, context);
        let expression08 = pop_item!(self, expression08, Expression08, context);
        let expression07_built = Expression07 {
            expression08: Box::new(expression08),
            expression07_list,
        };
        // Calling user action here
        self.user_grammar.expression07(&expression07_built)?;
        self.push(ASTType::Expression07(expression07_built), context);
        Ok(())
    }

    /// Semantic action for production 461:
    ///
    /// `Expression07List /* Vec<T>::Push */: Operator08 Expression08 Expression07List;`
    ///
    #[parol_runtime::function_name::named]
    fn expression07_list_0(
        &mut self,
        _operator08: &ParseTreeType<'t>,
        _expression08: &ParseTreeType<'t>,
        _expression07_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression07_list = pop_item!(self, expression07_list, Expression07List, context);
        let expression08 = pop_item!(self, expression08, Expression08, context);
        let operator08 = pop_item!(self, operator08, Operator08, context);
        let expression07_list_0_built = Expression07List {
            expression08: Box::new(expression08),
            operator08: Box::new(operator08),
        };
        // Add an element to the vector
        expression07_list.push(expression07_list_0_built);
        self.push(ASTType::Expression07List(expression07_list), context);
        Ok(())
    }

    /// Semantic action for production 462:
    ///
    /// `Expression07List /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn expression07_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression07_list_1_built = Vec::new();
        self.push(
            ASTType::Expression07List(expression07_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 463:
    ///
    /// `Expression08: Expression09 Expression08List /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn expression08(
        &mut self,
        _expression09: &ParseTreeType<'t>,
        _expression08_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression08_list =
            pop_and_reverse_item!(self, expression08_list, Expression08List, context);
        let expression09 = pop_item!(self, expression09, Expression09, context);
        let expression08_built = Expression08 {
            expression09: Box::new(expression09),
            expression08_list,
        };
        // Calling user action here
        self.user_grammar.expression08(&expression08_built)?;
        self.push(ASTType::Expression08(expression08_built), context);
        Ok(())
    }

    /// Semantic action for production 464:
    ///
    /// `Expression08List /* Vec<T>::Push */: Operator09 Expression09 Expression08List;`
    ///
    #[parol_runtime::function_name::named]
    fn expression08_list_0(
        &mut self,
        _operator09: &ParseTreeType<'t>,
        _expression09: &ParseTreeType<'t>,
        _expression08_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression08_list = pop_item!(self, expression08_list, Expression08List, context);
        let expression09 = pop_item!(self, expression09, Expression09, context);
        let operator09 = pop_item!(self, operator09, Operator09, context);
        let expression08_list_0_built = Expression08List {
            expression09: Box::new(expression09),
            operator09: Box::new(operator09),
        };
        // Add an element to the vector
        expression08_list.push(expression08_list_0_built);
        self.push(ASTType::Expression08List(expression08_list), context);
        Ok(())
    }

    /// Semantic action for production 465:
    ///
    /// `Expression08List /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn expression08_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression08_list_1_built = Vec::new();
        self.push(
            ASTType::Expression08List(expression08_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 466:
    ///
    /// `Expression09: Expression10 Expression09List /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn expression09(
        &mut self,
        _expression10: &ParseTreeType<'t>,
        _expression09_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression09_list =
            pop_and_reverse_item!(self, expression09_list, Expression09List, context);
        let expression10 = pop_item!(self, expression10, Expression10, context);
        let expression09_built = Expression09 {
            expression10: Box::new(expression10),
            expression09_list,
        };
        // Calling user action here
        self.user_grammar.expression09(&expression09_built)?;
        self.push(ASTType::Expression09(expression09_built), context);
        Ok(())
    }

    /// Semantic action for production 467:
    ///
    /// `Expression09List /* Vec<T>::Push */: Operator10 Expression10 Expression09List;`
    ///
    #[parol_runtime::function_name::named]
    fn expression09_list_0(
        &mut self,
        _operator10: &ParseTreeType<'t>,
        _expression10: &ParseTreeType<'t>,
        _expression09_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression09_list = pop_item!(self, expression09_list, Expression09List, context);
        let expression10 = pop_item!(self, expression10, Expression10, context);
        let operator10 = pop_item!(self, operator10, Operator10, context);
        let expression09_list_0_built = Expression09List {
            expression10: Box::new(expression10),
            operator10: Box::new(operator10),
        };
        // Add an element to the vector
        expression09_list.push(expression09_list_0_built);
        self.push(ASTType::Expression09List(expression09_list), context);
        Ok(())
    }

    /// Semantic action for production 468:
    ///
    /// `Expression09List /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn expression09_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression09_list_1_built = Vec::new();
        self.push(
            ASTType::Expression09List(expression09_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 469:
    ///
    /// `Expression10: Expression11 Expression10List /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn expression10(
        &mut self,
        _expression11: &ParseTreeType<'t>,
        _expression10_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression10_list =
            pop_and_reverse_item!(self, expression10_list, Expression10List, context);
        let expression11 = pop_item!(self, expression11, Expression11, context);
        let expression10_built = Expression10 {
            expression11: Box::new(expression11),
            expression10_list,
        };
        // Calling user action here
        self.user_grammar.expression10(&expression10_built)?;
        self.push(ASTType::Expression10(expression10_built), context);
        Ok(())
    }

    /// Semantic action for production 470:
    ///
    /// `Expression10List /* Vec<T>::Push */: Expression10ListGroup Expression11 Expression10List;`
    ///
    #[parol_runtime::function_name::named]
    fn expression10_list_0(
        &mut self,
        _expression10_list_group: &ParseTreeType<'t>,
        _expression11: &ParseTreeType<'t>,
        _expression10_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression10_list = pop_item!(self, expression10_list, Expression10List, context);
        let expression11 = pop_item!(self, expression11, Expression11, context);
        let expression10_list_group = pop_item!(
            self,
            expression10_list_group,
            Expression10ListGroup,
            context
        );
        let expression10_list_0_built = Expression10List {
            expression11: Box::new(expression11),
            expression10_list_group: Box::new(expression10_list_group),
        };
        // Add an element to the vector
        expression10_list.push(expression10_list_0_built);
        self.push(ASTType::Expression10List(expression10_list), context);
        Ok(())
    }

    /// Semantic action for production 471:
    ///
    /// `Expression10ListGroup: Operator11;`
    ///
    #[parol_runtime::function_name::named]
    fn expression10_list_group_0(&mut self, _operator11: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator11 = pop_item!(self, operator11, Operator11, context);
        let expression10_list_group_0_built = Expression10ListGroupOperator11 {
            operator11: Box::new(operator11),
        };
        let expression10_list_group_0_built =
            Expression10ListGroup::Operator11(expression10_list_group_0_built);
        self.push(
            ASTType::Expression10ListGroup(expression10_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 472:
    ///
    /// `Expression10ListGroup: Star;`
    ///
    #[parol_runtime::function_name::named]
    fn expression10_list_group_1(&mut self, _star: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star = pop_item!(self, star, Star, context);
        let expression10_list_group_1_built = Expression10ListGroupStar {
            star: Box::new(star),
        };
        let expression10_list_group_1_built =
            Expression10ListGroup::Star(expression10_list_group_1_built);
        self.push(
            ASTType::Expression10ListGroup(expression10_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 473:
    ///
    /// `Expression10List /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn expression10_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression10_list_1_built = Vec::new();
        self.push(
            ASTType::Expression10List(expression10_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 474:
    ///
    /// `Expression11: Expression12 Expression11List /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn expression11(
        &mut self,
        _expression12: &ParseTreeType<'t>,
        _expression11_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression11_list =
            pop_and_reverse_item!(self, expression11_list, Expression11List, context);
        let expression12 = pop_item!(self, expression12, Expression12, context);
        let expression11_built = Expression11 {
            expression12: Box::new(expression12),
            expression11_list,
        };
        // Calling user action here
        self.user_grammar.expression11(&expression11_built)?;
        self.push(ASTType::Expression11(expression11_built), context);
        Ok(())
    }

    /// Semantic action for production 475:
    ///
    /// `Expression11List /* Vec<T>::Push */: Operator12 Expression12 Expression11List;`
    ///
    #[parol_runtime::function_name::named]
    fn expression11_list_0(
        &mut self,
        _operator12: &ParseTreeType<'t>,
        _expression12: &ParseTreeType<'t>,
        _expression11_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression11_list = pop_item!(self, expression11_list, Expression11List, context);
        let expression12 = pop_item!(self, expression12, Expression12, context);
        let operator12 = pop_item!(self, operator12, Operator12, context);
        let expression11_list_0_built = Expression11List {
            expression12: Box::new(expression12),
            operator12: Box::new(operator12),
        };
        // Add an element to the vector
        expression11_list.push(expression11_list_0_built);
        self.push(ASTType::Expression11List(expression11_list), context);
        Ok(())
    }

    /// Semantic action for production 476:
    ///
    /// `Expression11List /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn expression11_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression11_list_1_built = Vec::new();
        self.push(
            ASTType::Expression11List(expression11_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 477:
    ///
    /// `Expression12: Expression13 Expression12Opt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn expression12(
        &mut self,
        _expression13: &ParseTreeType<'t>,
        _expression12_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression12_opt = pop_item!(self, expression12_opt, Expression12Opt, context);
        let expression13 = pop_item!(self, expression13, Expression13, context);
        let expression12_built = Expression12 {
            expression13: Box::new(expression13),
            expression12_opt,
        };
        // Calling user action here
        self.user_grammar.expression12(&expression12_built)?;
        self.push(ASTType::Expression12(expression12_built), context);
        Ok(())
    }

    /// Semantic action for production 478:
    ///
    /// `Expression12Opt /* Option<T>::Some */: As CastingType;`
    ///
    #[parol_runtime::function_name::named]
    fn expression12_opt_0(
        &mut self,
        _as: &ParseTreeType<'t>,
        _casting_type: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let casting_type = pop_item!(self, casting_type, CastingType, context);
        let r#as = pop_item!(self, r#as, As, context);
        let expression12_opt_0_built = Expression12Opt {
            r#as: Box::new(r#as),
            casting_type: Box::new(casting_type),
        };
        self.push(
            ASTType::Expression12Opt(Some(expression12_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 479:
    ///
    /// `Expression12Opt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn expression12_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::Expression12Opt(None), context);
        Ok(())
    }

    /// Semantic action for production 480:
    ///
    /// `Expression13: Expression13List /* Vec */ Factor;`
    ///
    #[parol_runtime::function_name::named]
    fn expression13(
        &mut self,
        _expression13_list: &ParseTreeType<'t>,
        _factor: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor = pop_item!(self, factor, Factor, context);
        let expression13_list =
            pop_and_reverse_item!(self, expression13_list, Expression13List, context);
        let expression13_built = Expression13 {
            expression13_list,
            factor: Box::new(factor),
        };
        // Calling user action here
        self.user_grammar.expression13(&expression13_built)?;
        self.push(ASTType::Expression13(expression13_built), context);
        Ok(())
    }

    /// Semantic action for production 481:
    ///
    /// `Expression13List /* Vec<T>::Push */: Expression13ListGroup Expression13List;`
    ///
    #[parol_runtime::function_name::named]
    fn expression13_list_0(
        &mut self,
        _expression13_list_group: &ParseTreeType<'t>,
        _expression13_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut expression13_list = pop_item!(self, expression13_list, Expression13List, context);
        let expression13_list_group = pop_item!(
            self,
            expression13_list_group,
            Expression13ListGroup,
            context
        );
        let expression13_list_0_built = Expression13List {
            expression13_list_group: Box::new(expression13_list_group),
        };
        // Add an element to the vector
        expression13_list.push(expression13_list_0_built);
        self.push(ASTType::Expression13List(expression13_list), context);
        Ok(())
    }

    /// Semantic action for production 482:
    ///
    /// `Expression13ListGroup: UnaryOperator;`
    ///
    #[parol_runtime::function_name::named]
    fn expression13_list_group_0(&mut self, _unary_operator: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unary_operator = pop_item!(self, unary_operator, UnaryOperator, context);
        let expression13_list_group_0_built = Expression13ListGroupUnaryOperator {
            unary_operator: Box::new(unary_operator),
        };
        let expression13_list_group_0_built =
            Expression13ListGroup::UnaryOperator(expression13_list_group_0_built);
        self.push(
            ASTType::Expression13ListGroup(expression13_list_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 483:
    ///
    /// `Expression13ListGroup: Operator10;`
    ///
    #[parol_runtime::function_name::named]
    fn expression13_list_group_1(&mut self, _operator10: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator10 = pop_item!(self, operator10, Operator10, context);
        let expression13_list_group_1_built = Expression13ListGroupOperator10 {
            operator10: Box::new(operator10),
        };
        let expression13_list_group_1_built =
            Expression13ListGroup::Operator10(expression13_list_group_1_built);
        self.push(
            ASTType::Expression13ListGroup(expression13_list_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 484:
    ///
    /// `Expression13ListGroup: Operator06;`
    ///
    #[parol_runtime::function_name::named]
    fn expression13_list_group_2(&mut self, _operator06: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator06 = pop_item!(self, operator06, Operator06, context);
        let expression13_list_group_2_built = Expression13ListGroupOperator06 {
            operator06: Box::new(operator06),
        };
        let expression13_list_group_2_built =
            Expression13ListGroup::Operator06(expression13_list_group_2_built);
        self.push(
            ASTType::Expression13ListGroup(expression13_list_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 485:
    ///
    /// `Expression13ListGroup: Operator04;`
    ///
    #[parol_runtime::function_name::named]
    fn expression13_list_group_3(&mut self, _operator04: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator04 = pop_item!(self, operator04, Operator04, context);
        let expression13_list_group_3_built = Expression13ListGroupOperator04 {
            operator04: Box::new(operator04),
        };
        let expression13_list_group_3_built =
            Expression13ListGroup::Operator04(expression13_list_group_3_built);
        self.push(
            ASTType::Expression13ListGroup(expression13_list_group_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 486:
    ///
    /// `Expression13ListGroup: Operator05;`
    ///
    #[parol_runtime::function_name::named]
    fn expression13_list_group_4(&mut self, _operator05: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let operator05 = pop_item!(self, operator05, Operator05, context);
        let expression13_list_group_4_built = Expression13ListGroupOperator05 {
            operator05: Box::new(operator05),
        };
        let expression13_list_group_4_built =
            Expression13ListGroup::Operator05(expression13_list_group_4_built);
        self.push(
            ASTType::Expression13ListGroup(expression13_list_group_4_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 487:
    ///
    /// `Expression13List /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn expression13_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression13_list_1_built = Vec::new();
        self.push(
            ASTType::Expression13List(expression13_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 488:
    ///
    /// `Factor: Number;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_0(&mut self, _number: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = pop_item!(self, number, Number, context);
        let factor_0_built = FactorNumber {
            number: Box::new(number),
        };
        let factor_0_built = Factor::Number(factor_0_built);
        // Calling user action here
        self.user_grammar.factor(&factor_0_built)?;
        self.push(ASTType::Factor(factor_0_built), context);
        Ok(())
    }

    /// Semantic action for production 489:
    ///
    /// `Factor: BooleanLiteral;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_1(&mut self, _boolean_literal: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let boolean_literal = pop_item!(self, boolean_literal, BooleanLiteral, context);
        let factor_1_built = FactorBooleanLiteral {
            boolean_literal: Box::new(boolean_literal),
        };
        let factor_1_built = Factor::BooleanLiteral(factor_1_built);
        // Calling user action here
        self.user_grammar.factor(&factor_1_built)?;
        self.push(ASTType::Factor(factor_1_built), context);
        Ok(())
    }

    /// Semantic action for production 490:
    ///
    /// `Factor: IdentifierFactor;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_2(&mut self, _identifier_factor: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier_factor = pop_item!(self, identifier_factor, IdentifierFactor, context);
        let factor_2_built = FactorIdentifierFactor {
            identifier_factor: Box::new(identifier_factor),
        };
        let factor_2_built = Factor::IdentifierFactor(factor_2_built);
        // Calling user action here
        self.user_grammar.factor(&factor_2_built)?;
        self.push(ASTType::Factor(factor_2_built), context);
        Ok(())
    }

    /// Semantic action for production 491:
    ///
    /// `Factor: LParen Expression RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_3(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let factor_3_built = FactorLParenExpressionRParen {
            l_paren: Box::new(l_paren),
            expression: Box::new(expression),
            r_paren: Box::new(r_paren),
        };
        let factor_3_built = Factor::LParenExpressionRParen(factor_3_built);
        // Calling user action here
        self.user_grammar.factor(&factor_3_built)?;
        self.push(ASTType::Factor(factor_3_built), context);
        Ok(())
    }

    /// Semantic action for production 492:
    ///
    /// `Factor: LBrace ConcatenationList RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_4(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _concatenation_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let concatenation_list = pop_item!(self, concatenation_list, ConcatenationList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let factor_4_built = FactorLBraceConcatenationListRBrace {
            l_brace: Box::new(l_brace),
            concatenation_list: Box::new(concatenation_list),
            r_brace: Box::new(r_brace),
        };
        let factor_4_built = Factor::LBraceConcatenationListRBrace(factor_4_built);
        // Calling user action here
        self.user_grammar.factor(&factor_4_built)?;
        self.push(ASTType::Factor(factor_4_built), context);
        Ok(())
    }

    /// Semantic action for production 493:
    ///
    /// `Factor: QuoteLBrace ArrayLiteralList RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_5(
        &mut self,
        _quote_l_brace: &ParseTreeType<'t>,
        _array_literal_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let array_literal_list = pop_item!(self, array_literal_list, ArrayLiteralList, context);
        let quote_l_brace = pop_item!(self, quote_l_brace, QuoteLBrace, context);
        let factor_5_built = FactorQuoteLBraceArrayLiteralListRBrace {
            quote_l_brace: Box::new(quote_l_brace),
            array_literal_list: Box::new(array_literal_list),
            r_brace: Box::new(r_brace),
        };
        let factor_5_built = Factor::QuoteLBraceArrayLiteralListRBrace(factor_5_built);
        // Calling user action here
        self.user_grammar.factor(&factor_5_built)?;
        self.push(ASTType::Factor(factor_5_built), context);
        Ok(())
    }

    /// Semantic action for production 494:
    ///
    /// `Factor: CaseExpression;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_6(&mut self, _case_expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_expression = pop_item!(self, case_expression, CaseExpression, context);
        let factor_6_built = FactorCaseExpression {
            case_expression: Box::new(case_expression),
        };
        let factor_6_built = Factor::CaseExpression(factor_6_built);
        // Calling user action here
        self.user_grammar.factor(&factor_6_built)?;
        self.push(ASTType::Factor(factor_6_built), context);
        Ok(())
    }

    /// Semantic action for production 495:
    ///
    /// `Factor: SwitchExpression;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_7(&mut self, _switch_expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let switch_expression = pop_item!(self, switch_expression, SwitchExpression, context);
        let factor_7_built = FactorSwitchExpression {
            switch_expression: Box::new(switch_expression),
        };
        let factor_7_built = Factor::SwitchExpression(factor_7_built);
        // Calling user action here
        self.user_grammar.factor(&factor_7_built)?;
        self.push(ASTType::Factor(factor_7_built), context);
        Ok(())
    }

    /// Semantic action for production 496:
    ///
    /// `Factor: StringLiteral;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_8(&mut self, _string_literal: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string_literal = pop_item!(self, string_literal, StringLiteral, context);
        let factor_8_built = FactorStringLiteral {
            string_literal: Box::new(string_literal),
        };
        let factor_8_built = Factor::StringLiteral(factor_8_built);
        // Calling user action here
        self.user_grammar.factor(&factor_8_built)?;
        self.push(ASTType::Factor(factor_8_built), context);
        Ok(())
    }

    /// Semantic action for production 497:
    ///
    /// `Factor: FactorGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_9(&mut self, _factor_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_group = pop_item!(self, factor_group, FactorGroup, context);
        let factor_9_built = FactorFactorGroup {
            factor_group: Box::new(factor_group),
        };
        let factor_9_built = Factor::FactorGroup(factor_9_built);
        // Calling user action here
        self.user_grammar.factor(&factor_9_built)?;
        self.push(ASTType::Factor(factor_9_built), context);
        Ok(())
    }

    /// Semantic action for production 498:
    ///
    /// `FactorGroup: Msb;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_group_0(&mut self, _msb: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let msb = pop_item!(self, msb, Msb, context);
        let factor_group_0_built = FactorGroupMsb { msb: Box::new(msb) };
        let factor_group_0_built = FactorGroup::Msb(factor_group_0_built);
        self.push(ASTType::FactorGroup(factor_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 499:
    ///
    /// `FactorGroup: Lsb;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_group_1(&mut self, _lsb: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let lsb = pop_item!(self, lsb, Lsb, context);
        let factor_group_1_built = FactorGroupLsb { lsb: Box::new(lsb) };
        let factor_group_1_built = FactorGroup::Lsb(factor_group_1_built);
        self.push(ASTType::FactorGroup(factor_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 500:
    ///
    /// `Factor: InsideExpression;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_10(&mut self, _inside_expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inside_expression = pop_item!(self, inside_expression, InsideExpression, context);
        let factor_10_built = FactorInsideExpression {
            inside_expression: Box::new(inside_expression),
        };
        let factor_10_built = Factor::InsideExpression(factor_10_built);
        // Calling user action here
        self.user_grammar.factor(&factor_10_built)?;
        self.push(ASTType::Factor(factor_10_built), context);
        Ok(())
    }

    /// Semantic action for production 501:
    ///
    /// `Factor: OutsideExpression;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_11(&mut self, _outside_expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let outside_expression = pop_item!(self, outside_expression, OutsideExpression, context);
        let factor_11_built = FactorOutsideExpression {
            outside_expression: Box::new(outside_expression),
        };
        let factor_11_built = Factor::OutsideExpression(factor_11_built);
        // Calling user action here
        self.user_grammar.factor(&factor_11_built)?;
        self.push(ASTType::Factor(factor_11_built), context);
        Ok(())
    }

    /// Semantic action for production 502:
    ///
    /// `Factor: TypeExpression;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_12(&mut self, _type_expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_expression = pop_item!(self, type_expression, TypeExpression, context);
        let factor_12_built = FactorTypeExpression {
            type_expression: Box::new(type_expression),
        };
        let factor_12_built = Factor::TypeExpression(factor_12_built);
        // Calling user action here
        self.user_grammar.factor(&factor_12_built)?;
        self.push(ASTType::Factor(factor_12_built), context);
        Ok(())
    }

    /// Semantic action for production 503:
    ///
    /// `Factor: FactorTypeFactor;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_13(&mut self, _factor_type_factor: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_type_factor = pop_item!(self, factor_type_factor, FactorTypeFactor, context);
        let factor_13_built = FactorFactorTypeFactor {
            factor_type_factor: Box::new(factor_type_factor),
        };
        let factor_13_built = Factor::FactorTypeFactor(factor_13_built);
        // Calling user action here
        self.user_grammar.factor(&factor_13_built)?;
        self.push(ASTType::Factor(factor_13_built), context);
        Ok(())
    }

    /// Semantic action for production 504:
    ///
    /// `BooleanLiteral: True;`
    ///
    #[parol_runtime::function_name::named]
    fn boolean_literal_0(&mut self, _true: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#true = pop_item!(self, r#true, True, context);
        let boolean_literal_0_built = BooleanLiteralTrue {
            r#true: Box::new(r#true),
        };
        let boolean_literal_0_built = BooleanLiteral::True(boolean_literal_0_built);
        // Calling user action here
        self.user_grammar
            .boolean_literal(&boolean_literal_0_built)?;
        self.push(ASTType::BooleanLiteral(boolean_literal_0_built), context);
        Ok(())
    }

    /// Semantic action for production 505:
    ///
    /// `BooleanLiteral: False;`
    ///
    #[parol_runtime::function_name::named]
    fn boolean_literal_1(&mut self, _false: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#false = pop_item!(self, r#false, False, context);
        let boolean_literal_1_built = BooleanLiteralFalse {
            r#false: Box::new(r#false),
        };
        let boolean_literal_1_built = BooleanLiteral::False(boolean_literal_1_built);
        // Calling user action here
        self.user_grammar
            .boolean_literal(&boolean_literal_1_built)?;
        self.push(ASTType::BooleanLiteral(boolean_literal_1_built), context);
        Ok(())
    }

    /// Semantic action for production 506:
    ///
    /// `IdentifierFactor: ExpressionIdentifier IdentifierFactorOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn identifier_factor(
        &mut self,
        _expression_identifier: &ParseTreeType<'t>,
        _identifier_factor_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier_factor_opt =
            pop_item!(self, identifier_factor_opt, IdentifierFactorOpt, context);
        let expression_identifier =
            pop_item!(self, expression_identifier, ExpressionIdentifier, context);
        let identifier_factor_built = IdentifierFactor {
            expression_identifier: Box::new(expression_identifier),
            identifier_factor_opt,
        };
        // Calling user action here
        self.user_grammar
            .identifier_factor(&identifier_factor_built)?;
        self.push(ASTType::IdentifierFactor(identifier_factor_built), context);
        Ok(())
    }

    /// Semantic action for production 507:
    ///
    /// `IdentifierFactorOpt /* Option<T>::Some */: IdentifierFactorOptGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn identifier_factor_opt_0(
        &mut self,
        _identifier_factor_opt_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier_factor_opt_group = pop_item!(
            self,
            identifier_factor_opt_group,
            IdentifierFactorOptGroup,
            context
        );
        let identifier_factor_opt_0_built = IdentifierFactorOpt {
            identifier_factor_opt_group: Box::new(identifier_factor_opt_group),
        };
        self.push(
            ASTType::IdentifierFactorOpt(Some(identifier_factor_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 508:
    ///
    /// `IdentifierFactorOptGroup: FunctionCall;`
    ///
    #[parol_runtime::function_name::named]
    fn identifier_factor_opt_group_0(&mut self, _function_call: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_call = pop_item!(self, function_call, FunctionCall, context);
        let identifier_factor_opt_group_0_built = IdentifierFactorOptGroupFunctionCall {
            function_call: Box::new(function_call),
        };
        let identifier_factor_opt_group_0_built =
            IdentifierFactorOptGroup::FunctionCall(identifier_factor_opt_group_0_built);
        self.push(
            ASTType::IdentifierFactorOptGroup(identifier_factor_opt_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 509:
    ///
    /// `IdentifierFactorOptGroup: StructConstructor;`
    ///
    #[parol_runtime::function_name::named]
    fn identifier_factor_opt_group_1(
        &mut self,
        _struct_constructor: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_constructor = pop_item!(self, struct_constructor, StructConstructor, context);
        let identifier_factor_opt_group_1_built = IdentifierFactorOptGroupStructConstructor {
            struct_constructor: Box::new(struct_constructor),
        };
        let identifier_factor_opt_group_1_built =
            IdentifierFactorOptGroup::StructConstructor(identifier_factor_opt_group_1_built);
        self.push(
            ASTType::IdentifierFactorOptGroup(identifier_factor_opt_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 510:
    ///
    /// `IdentifierFactorOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn identifier_factor_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::IdentifierFactorOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 511:
    ///
    /// `FactorTypeFactor: FactorTypeFactorList /* Vec */ FactorType;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_type_factor(
        &mut self,
        _factor_type_factor_list: &ParseTreeType<'t>,
        _factor_type: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_type = pop_item!(self, factor_type, FactorType, context);
        let factor_type_factor_list =
            pop_and_reverse_item!(self, factor_type_factor_list, FactorTypeFactorList, context);
        let factor_type_factor_built = FactorTypeFactor {
            factor_type_factor_list,
            factor_type: Box::new(factor_type),
        };
        // Calling user action here
        self.user_grammar
            .factor_type_factor(&factor_type_factor_built)?;
        self.push(ASTType::FactorTypeFactor(factor_type_factor_built), context);
        Ok(())
    }

    /// Semantic action for production 512:
    ///
    /// `FactorTypeFactorList /* Vec<T>::Push */: TypeModifier FactorTypeFactorList;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_type_factor_list_0(
        &mut self,
        _type_modifier: &ParseTreeType<'t>,
        _factor_type_factor_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut factor_type_factor_list =
            pop_item!(self, factor_type_factor_list, FactorTypeFactorList, context);
        let type_modifier = pop_item!(self, type_modifier, TypeModifier, context);
        let factor_type_factor_list_0_built = FactorTypeFactorList {
            type_modifier: Box::new(type_modifier),
        };
        // Add an element to the vector
        factor_type_factor_list.push(factor_type_factor_list_0_built);
        self.push(
            ASTType::FactorTypeFactorList(factor_type_factor_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 513:
    ///
    /// `FactorTypeFactorList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_type_factor_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_type_factor_list_1_built = Vec::new();
        self.push(
            ASTType::FactorTypeFactorList(factor_type_factor_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 514:
    ///
    /// `FunctionCall: LParen FunctionCallOpt /* Option */ RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn function_call(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _function_call_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let function_call_opt = pop_item!(self, function_call_opt, FunctionCallOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let function_call_built = FunctionCall {
            l_paren: Box::new(l_paren),
            function_call_opt,
            r_paren: Box::new(r_paren),
        };
        // Calling user action here
        self.user_grammar.function_call(&function_call_built)?;
        self.push(ASTType::FunctionCall(function_call_built), context);
        Ok(())
    }

    /// Semantic action for production 515:
    ///
    /// `FunctionCallOpt /* Option<T>::Some */: ArgumentList;`
    ///
    #[parol_runtime::function_name::named]
    fn function_call_opt_0(&mut self, _argument_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let argument_list = pop_item!(self, argument_list, ArgumentList, context);
        let function_call_opt_0_built = FunctionCallOpt {
            argument_list: Box::new(argument_list),
        };
        self.push(
            ASTType::FunctionCallOpt(Some(function_call_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 516:
    ///
    /// `FunctionCallOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn function_call_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FunctionCallOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 517:
    ///
    /// `ArgumentList: ArgumentItem ArgumentListList /* Vec */ ArgumentListOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_list(
        &mut self,
        _argument_item: &ParseTreeType<'t>,
        _argument_list_list: &ParseTreeType<'t>,
        _argument_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let argument_list_opt = pop_item!(self, argument_list_opt, ArgumentListOpt, context);
        let argument_list_list =
            pop_and_reverse_item!(self, argument_list_list, ArgumentListList, context);
        let argument_item = pop_item!(self, argument_item, ArgumentItem, context);
        let argument_list_built = ArgumentList {
            argument_item: Box::new(argument_item),
            argument_list_list,
            argument_list_opt,
        };
        // Calling user action here
        self.user_grammar.argument_list(&argument_list_built)?;
        self.push(ASTType::ArgumentList(argument_list_built), context);
        Ok(())
    }

    /// Semantic action for production 518:
    ///
    /// `ArgumentListList /* Vec<T>::Push */: Comma ArgumentItem ArgumentListList;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _argument_item: &ParseTreeType<'t>,
        _argument_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut argument_list_list = pop_item!(self, argument_list_list, ArgumentListList, context);
        let argument_item = pop_item!(self, argument_item, ArgumentItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let argument_list_list_0_built = ArgumentListList {
            argument_item: Box::new(argument_item),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        argument_list_list.push(argument_list_list_0_built);
        self.push(ASTType::ArgumentListList(argument_list_list), context);
        Ok(())
    }

    /// Semantic action for production 519:
    ///
    /// `ArgumentListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let argument_list_list_1_built = Vec::new();
        self.push(
            ASTType::ArgumentListList(argument_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 520:
    ///
    /// `ArgumentListOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let argument_list_opt_0_built = ArgumentListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::ArgumentListOpt(Some(argument_list_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 521:
    ///
    /// `ArgumentListOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArgumentListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 522:
    ///
    /// `ArgumentItem: ArgumentExpression ArgumentItemOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_item(
        &mut self,
        _argument_expression: &ParseTreeType<'t>,
        _argument_item_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let argument_item_opt = pop_item!(self, argument_item_opt, ArgumentItemOpt, context);
        let argument_expression = pop_item!(self, argument_expression, ArgumentExpression, context);
        let argument_item_built = ArgumentItem {
            argument_expression: Box::new(argument_expression),
            argument_item_opt,
        };
        // Calling user action here
        self.user_grammar.argument_item(&argument_item_built)?;
        self.push(ASTType::ArgumentItem(argument_item_built), context);
        Ok(())
    }

    /// Semantic action for production 523:
    ///
    /// `ArgumentItemOpt /* Option<T>::Some */: Colon Expression;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_item_opt_0(
        &mut self,
        _colon: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let colon = pop_item!(self, colon, Colon, context);
        let argument_item_opt_0_built = ArgumentItemOpt {
            colon: Box::new(colon),
            expression: Box::new(expression),
        };
        self.push(
            ASTType::ArgumentItemOpt(Some(argument_item_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 524:
    ///
    /// `ArgumentItemOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_item_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArgumentItemOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 525:
    ///
    /// `ArgumentExpression: Expression;`
    ///
    #[parol_runtime::function_name::named]
    fn argument_expression(&mut self, _expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let argument_expression_built = ArgumentExpression {
            expression: Box::new(expression),
        };
        // Calling user action here
        self.user_grammar
            .argument_expression(&argument_expression_built)?;
        self.push(
            ASTType::ArgumentExpression(argument_expression_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 526:
    ///
    /// `StructConstructor: QuoteLBrace StructConstructorList StructConstructorOpt /* Option */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_constructor(
        &mut self,
        _quote_l_brace: &ParseTreeType<'t>,
        _struct_constructor_list: &ParseTreeType<'t>,
        _struct_constructor_opt: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let struct_constructor_opt =
            pop_item!(self, struct_constructor_opt, StructConstructorOpt, context);
        let struct_constructor_list = pop_item!(
            self,
            struct_constructor_list,
            StructConstructorList,
            context
        );
        let quote_l_brace = pop_item!(self, quote_l_brace, QuoteLBrace, context);
        let struct_constructor_built = StructConstructor {
            quote_l_brace: Box::new(quote_l_brace),
            struct_constructor_list: Box::new(struct_constructor_list),
            struct_constructor_opt,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .struct_constructor(&struct_constructor_built)?;
        self.push(
            ASTType::StructConstructor(struct_constructor_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 527:
    ///
    /// `StructConstructorOpt /* Option<T>::Some */: DotDot Defaul LParen Expression RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_constructor_opt_0(
        &mut self,
        _dot_dot: &ParseTreeType<'t>,
        _defaul: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let defaul = pop_item!(self, defaul, Defaul, context);
        let dot_dot = pop_item!(self, dot_dot, DotDot, context);
        let struct_constructor_opt_0_built = StructConstructorOpt {
            dot_dot: Box::new(dot_dot),
            defaul: Box::new(defaul),
            l_paren: Box::new(l_paren),
            expression: Box::new(expression),
            r_paren: Box::new(r_paren),
        };
        self.push(
            ASTType::StructConstructorOpt(Some(struct_constructor_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 528:
    ///
    /// `StructConstructorOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_constructor_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StructConstructorOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 529:
    ///
    /// `StructConstructorList: StructConstructorItem StructConstructorListList /* Vec */ StructConstructorListOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_constructor_list(
        &mut self,
        _struct_constructor_item: &ParseTreeType<'t>,
        _struct_constructor_list_list: &ParseTreeType<'t>,
        _struct_constructor_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_constructor_list_opt = pop_item!(
            self,
            struct_constructor_list_opt,
            StructConstructorListOpt,
            context
        );
        let struct_constructor_list_list = pop_and_reverse_item!(
            self,
            struct_constructor_list_list,
            StructConstructorListList,
            context
        );
        let struct_constructor_item = pop_item!(
            self,
            struct_constructor_item,
            StructConstructorItem,
            context
        );
        let struct_constructor_list_built = StructConstructorList {
            struct_constructor_item: Box::new(struct_constructor_item),
            struct_constructor_list_list,
            struct_constructor_list_opt,
        };
        // Calling user action here
        self.user_grammar
            .struct_constructor_list(&struct_constructor_list_built)?;
        self.push(
            ASTType::StructConstructorList(struct_constructor_list_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 530:
    ///
    /// `StructConstructorListList /* Vec<T>::Push */: Comma StructConstructorItem StructConstructorListList;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_constructor_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _struct_constructor_item: &ParseTreeType<'t>,
        _struct_constructor_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut struct_constructor_list_list = pop_item!(
            self,
            struct_constructor_list_list,
            StructConstructorListList,
            context
        );
        let struct_constructor_item = pop_item!(
            self,
            struct_constructor_item,
            StructConstructorItem,
            context
        );
        let comma = pop_item!(self, comma, Comma, context);
        let struct_constructor_list_list_0_built = StructConstructorListList {
            struct_constructor_item: Box::new(struct_constructor_item),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        struct_constructor_list_list.push(struct_constructor_list_list_0_built);
        self.push(
            ASTType::StructConstructorListList(struct_constructor_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 531:
    ///
    /// `StructConstructorListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_constructor_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_constructor_list_list_1_built = Vec::new();
        self.push(
            ASTType::StructConstructorListList(struct_constructor_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 532:
    ///
    /// `StructConstructorListOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_constructor_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let struct_constructor_list_opt_0_built = StructConstructorListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::StructConstructorListOpt(Some(struct_constructor_list_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 533:
    ///
    /// `StructConstructorListOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_constructor_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StructConstructorListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 534:
    ///
    /// `StructConstructorItem: Identifier Colon Expression;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_constructor_item(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let struct_constructor_item_built = StructConstructorItem {
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            expression: Box::new(expression),
        };
        // Calling user action here
        self.user_grammar
            .struct_constructor_item(&struct_constructor_item_built)?;
        self.push(
            ASTType::StructConstructorItem(struct_constructor_item_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 535:
    ///
    /// `ConcatenationList: ConcatenationItem ConcatenationListList /* Vec */ ConcatenationListOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn concatenation_list(
        &mut self,
        _concatenation_item: &ParseTreeType<'t>,
        _concatenation_list_list: &ParseTreeType<'t>,
        _concatenation_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let concatenation_list_opt =
            pop_item!(self, concatenation_list_opt, ConcatenationListOpt, context);
        let concatenation_list_list = pop_and_reverse_item!(
            self,
            concatenation_list_list,
            ConcatenationListList,
            context
        );
        let concatenation_item = pop_item!(self, concatenation_item, ConcatenationItem, context);
        let concatenation_list_built = ConcatenationList {
            concatenation_item: Box::new(concatenation_item),
            concatenation_list_list,
            concatenation_list_opt,
        };
        // Calling user action here
        self.user_grammar
            .concatenation_list(&concatenation_list_built)?;
        self.push(
            ASTType::ConcatenationList(concatenation_list_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 536:
    ///
    /// `ConcatenationListList /* Vec<T>::Push */: Comma ConcatenationItem ConcatenationListList;`
    ///
    #[parol_runtime::function_name::named]
    fn concatenation_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _concatenation_item: &ParseTreeType<'t>,
        _concatenation_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut concatenation_list_list = pop_item!(
            self,
            concatenation_list_list,
            ConcatenationListList,
            context
        );
        let concatenation_item = pop_item!(self, concatenation_item, ConcatenationItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let concatenation_list_list_0_built = ConcatenationListList {
            concatenation_item: Box::new(concatenation_item),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        concatenation_list_list.push(concatenation_list_list_0_built);
        self.push(
            ASTType::ConcatenationListList(concatenation_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 537:
    ///
    /// `ConcatenationListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn concatenation_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let concatenation_list_list_1_built = Vec::new();
        self.push(
            ASTType::ConcatenationListList(concatenation_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 538:
    ///
    /// `ConcatenationListOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn concatenation_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let concatenation_list_opt_0_built = ConcatenationListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::ConcatenationListOpt(Some(concatenation_list_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 539:
    ///
    /// `ConcatenationListOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn concatenation_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ConcatenationListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 540:
    ///
    /// `ConcatenationItem: Expression ConcatenationItemOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn concatenation_item(
        &mut self,
        _expression: &ParseTreeType<'t>,
        _concatenation_item_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let concatenation_item_opt =
            pop_item!(self, concatenation_item_opt, ConcatenationItemOpt, context);
        let expression = pop_item!(self, expression, Expression, context);
        let concatenation_item_built = ConcatenationItem {
            expression: Box::new(expression),
            concatenation_item_opt,
        };
        // Calling user action here
        self.user_grammar
            .concatenation_item(&concatenation_item_built)?;
        self.push(
            ASTType::ConcatenationItem(concatenation_item_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 541:
    ///
    /// `ConcatenationItemOpt /* Option<T>::Some */: Repeat Expression;`
    ///
    #[parol_runtime::function_name::named]
    fn concatenation_item_opt_0(
        &mut self,
        _repeat: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let repeat = pop_item!(self, repeat, Repeat, context);
        let concatenation_item_opt_0_built = ConcatenationItemOpt {
            repeat: Box::new(repeat),
            expression: Box::new(expression),
        };
        self.push(
            ASTType::ConcatenationItemOpt(Some(concatenation_item_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 542:
    ///
    /// `ConcatenationItemOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn concatenation_item_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ConcatenationItemOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 543:
    ///
    /// `ArrayLiteralList: ArrayLiteralItem ArrayLiteralListList /* Vec */ ArrayLiteralListOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn array_literal_list(
        &mut self,
        _array_literal_item: &ParseTreeType<'t>,
        _array_literal_list_list: &ParseTreeType<'t>,
        _array_literal_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_literal_list_opt =
            pop_item!(self, array_literal_list_opt, ArrayLiteralListOpt, context);
        let array_literal_list_list =
            pop_and_reverse_item!(self, array_literal_list_list, ArrayLiteralListList, context);
        let array_literal_item = pop_item!(self, array_literal_item, ArrayLiteralItem, context);
        let array_literal_list_built = ArrayLiteralList {
            array_literal_item: Box::new(array_literal_item),
            array_literal_list_list,
            array_literal_list_opt,
        };
        // Calling user action here
        self.user_grammar
            .array_literal_list(&array_literal_list_built)?;
        self.push(ASTType::ArrayLiteralList(array_literal_list_built), context);
        Ok(())
    }

    /// Semantic action for production 544:
    ///
    /// `ArrayLiteralListList /* Vec<T>::Push */: Comma ArrayLiteralItem ArrayLiteralListList;`
    ///
    #[parol_runtime::function_name::named]
    fn array_literal_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _array_literal_item: &ParseTreeType<'t>,
        _array_literal_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut array_literal_list_list =
            pop_item!(self, array_literal_list_list, ArrayLiteralListList, context);
        let array_literal_item = pop_item!(self, array_literal_item, ArrayLiteralItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let array_literal_list_list_0_built = ArrayLiteralListList {
            array_literal_item: Box::new(array_literal_item),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        array_literal_list_list.push(array_literal_list_list_0_built);
        self.push(
            ASTType::ArrayLiteralListList(array_literal_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 545:
    ///
    /// `ArrayLiteralListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_literal_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_literal_list_list_1_built = Vec::new();
        self.push(
            ASTType::ArrayLiteralListList(array_literal_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 546:
    ///
    /// `ArrayLiteralListOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn array_literal_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let array_literal_list_opt_0_built = ArrayLiteralListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::ArrayLiteralListOpt(Some(array_literal_list_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 547:
    ///
    /// `ArrayLiteralListOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_literal_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayLiteralListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 548:
    ///
    /// `ArrayLiteralItem: ArrayLiteralItemGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn array_literal_item(&mut self, _array_literal_item_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_literal_item_group = pop_item!(
            self,
            array_literal_item_group,
            ArrayLiteralItemGroup,
            context
        );
        let array_literal_item_built = ArrayLiteralItem {
            array_literal_item_group: Box::new(array_literal_item_group),
        };
        // Calling user action here
        self.user_grammar
            .array_literal_item(&array_literal_item_built)?;
        self.push(ASTType::ArrayLiteralItem(array_literal_item_built), context);
        Ok(())
    }

    /// Semantic action for production 549:
    ///
    /// `ArrayLiteralItemGroup: Expression ArrayLiteralItemOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn array_literal_item_group_0(
        &mut self,
        _expression: &ParseTreeType<'t>,
        _array_literal_item_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_literal_item_opt =
            pop_item!(self, array_literal_item_opt, ArrayLiteralItemOpt, context);
        let expression = pop_item!(self, expression, Expression, context);
        let array_literal_item_group_0_built = ArrayLiteralItemGroupExpressionArrayLiteralItemOpt {
            expression: Box::new(expression),
            array_literal_item_opt,
        };
        let array_literal_item_group_0_built =
            ArrayLiteralItemGroup::ExpressionArrayLiteralItemOpt(array_literal_item_group_0_built);
        self.push(
            ASTType::ArrayLiteralItemGroup(array_literal_item_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 550:
    ///
    /// `ArrayLiteralItemGroup: Defaul Colon Expression;`
    ///
    #[parol_runtime::function_name::named]
    fn array_literal_item_group_1(
        &mut self,
        _defaul: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let colon = pop_item!(self, colon, Colon, context);
        let defaul = pop_item!(self, defaul, Defaul, context);
        let array_literal_item_group_1_built = ArrayLiteralItemGroupDefaulColonExpression {
            defaul: Box::new(defaul),
            colon: Box::new(colon),
            expression: Box::new(expression),
        };
        let array_literal_item_group_1_built =
            ArrayLiteralItemGroup::DefaulColonExpression(array_literal_item_group_1_built);
        self.push(
            ASTType::ArrayLiteralItemGroup(array_literal_item_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 551:
    ///
    /// `ArrayLiteralItemOpt /* Option<T>::Some */: Repeat Expression;`
    ///
    #[parol_runtime::function_name::named]
    fn array_literal_item_opt_0(
        &mut self,
        _repeat: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let repeat = pop_item!(self, repeat, Repeat, context);
        let array_literal_item_opt_0_built = ArrayLiteralItemOpt {
            repeat: Box::new(repeat),
            expression: Box::new(expression),
        };
        self.push(
            ASTType::ArrayLiteralItemOpt(Some(array_literal_item_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 552:
    ///
    /// `ArrayLiteralItemOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_literal_item_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayLiteralItemOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 553:
    ///
    /// `CaseExpression: Case Expression LBrace CaseCondition Colon Expression Comma CaseExpressionList /* Vec */ Defaul Colon Expression CaseExpressionOpt /* Option */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn case_expression(
        &mut self,
        _case: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _case_condition: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _expression0: &ParseTreeType<'t>,
        _comma: &ParseTreeType<'t>,
        _case_expression_list: &ParseTreeType<'t>,
        _defaul: &ParseTreeType<'t>,
        _colon0: &ParseTreeType<'t>,
        _expression1: &ParseTreeType<'t>,
        _case_expression_opt: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let case_expression_opt = pop_item!(self, case_expression_opt, CaseExpressionOpt, context);
        let expression1 = pop_item!(self, expression1, Expression, context);
        let colon0 = pop_item!(self, colon0, Colon, context);
        let defaul = pop_item!(self, defaul, Defaul, context);
        let case_expression_list =
            pop_and_reverse_item!(self, case_expression_list, CaseExpressionList, context);
        let comma = pop_item!(self, comma, Comma, context);
        let expression0 = pop_item!(self, expression0, Expression, context);
        let colon = pop_item!(self, colon, Colon, context);
        let case_condition = pop_item!(self, case_condition, CaseCondition, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let case = pop_item!(self, case, Case, context);
        let case_expression_built = CaseExpression {
            case: Box::new(case),
            expression: Box::new(expression),
            l_brace: Box::new(l_brace),
            case_condition: Box::new(case_condition),
            colon: Box::new(colon),
            expression0: Box::new(expression0),
            comma: Box::new(comma),
            case_expression_list,
            defaul: Box::new(defaul),
            colon0: Box::new(colon0),
            expression1: Box::new(expression1),
            case_expression_opt,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar.case_expression(&case_expression_built)?;
        self.push(ASTType::CaseExpression(case_expression_built), context);
        Ok(())
    }

    /// Semantic action for production 554:
    ///
    /// `CaseExpressionList /* Vec<T>::Push */: CaseCondition Colon Expression Comma CaseExpressionList;`
    ///
    #[parol_runtime::function_name::named]
    fn case_expression_list_0(
        &mut self,
        _case_condition: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _comma: &ParseTreeType<'t>,
        _case_expression_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut case_expression_list =
            pop_item!(self, case_expression_list, CaseExpressionList, context);
        let comma = pop_item!(self, comma, Comma, context);
        let expression = pop_item!(self, expression, Expression, context);
        let colon = pop_item!(self, colon, Colon, context);
        let case_condition = pop_item!(self, case_condition, CaseCondition, context);
        let case_expression_list_0_built = CaseExpressionList {
            comma: Box::new(comma),
            expression: Box::new(expression),
            colon: Box::new(colon),
            case_condition: Box::new(case_condition),
        };
        // Add an element to the vector
        case_expression_list.push(case_expression_list_0_built);
        self.push(ASTType::CaseExpressionList(case_expression_list), context);
        Ok(())
    }

    /// Semantic action for production 555:
    ///
    /// `CaseExpressionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn case_expression_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_expression_list_1_built = Vec::new();
        self.push(
            ASTType::CaseExpressionList(case_expression_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 556:
    ///
    /// `CaseExpressionOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn case_expression_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let case_expression_opt_0_built = CaseExpressionOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::CaseExpressionOpt(Some(case_expression_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 557:
    ///
    /// `CaseExpressionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn case_expression_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::CaseExpressionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 558:
    ///
    /// `SwitchExpression: Switch LBrace SwitchCondition Colon Expression Comma SwitchExpressionList /* Vec */ Defaul Colon Expression SwitchExpressionOpt /* Option */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn switch_expression(
        &mut self,
        _switch: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _switch_condition: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _comma: &ParseTreeType<'t>,
        _switch_expression_list: &ParseTreeType<'t>,
        _defaul: &ParseTreeType<'t>,
        _colon0: &ParseTreeType<'t>,
        _expression0: &ParseTreeType<'t>,
        _switch_expression_opt: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let switch_expression_opt =
            pop_item!(self, switch_expression_opt, SwitchExpressionOpt, context);
        let expression0 = pop_item!(self, expression0, Expression, context);
        let colon0 = pop_item!(self, colon0, Colon, context);
        let defaul = pop_item!(self, defaul, Defaul, context);
        let switch_expression_list =
            pop_and_reverse_item!(self, switch_expression_list, SwitchExpressionList, context);
        let comma = pop_item!(self, comma, Comma, context);
        let expression = pop_item!(self, expression, Expression, context);
        let colon = pop_item!(self, colon, Colon, context);
        let switch_condition = pop_item!(self, switch_condition, SwitchCondition, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let switch = pop_item!(self, switch, Switch, context);
        let switch_expression_built = SwitchExpression {
            switch: Box::new(switch),
            l_brace: Box::new(l_brace),
            switch_condition: Box::new(switch_condition),
            colon: Box::new(colon),
            expression: Box::new(expression),
            comma: Box::new(comma),
            switch_expression_list,
            defaul: Box::new(defaul),
            colon0: Box::new(colon0),
            expression0: Box::new(expression0),
            switch_expression_opt,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .switch_expression(&switch_expression_built)?;
        self.push(ASTType::SwitchExpression(switch_expression_built), context);
        Ok(())
    }

    /// Semantic action for production 559:
    ///
    /// `SwitchExpressionList /* Vec<T>::Push */: SwitchCondition Colon Expression Comma SwitchExpressionList;`
    ///
    #[parol_runtime::function_name::named]
    fn switch_expression_list_0(
        &mut self,
        _switch_condition: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _comma: &ParseTreeType<'t>,
        _switch_expression_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut switch_expression_list =
            pop_item!(self, switch_expression_list, SwitchExpressionList, context);
        let comma = pop_item!(self, comma, Comma, context);
        let expression = pop_item!(self, expression, Expression, context);
        let colon = pop_item!(self, colon, Colon, context);
        let switch_condition = pop_item!(self, switch_condition, SwitchCondition, context);
        let switch_expression_list_0_built = SwitchExpressionList {
            comma: Box::new(comma),
            expression: Box::new(expression),
            colon: Box::new(colon),
            switch_condition: Box::new(switch_condition),
        };
        // Add an element to the vector
        switch_expression_list.push(switch_expression_list_0_built);
        self.push(
            ASTType::SwitchExpressionList(switch_expression_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 560:
    ///
    /// `SwitchExpressionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn switch_expression_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let switch_expression_list_1_built = Vec::new();
        self.push(
            ASTType::SwitchExpressionList(switch_expression_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 561:
    ///
    /// `SwitchExpressionOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn switch_expression_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let switch_expression_opt_0_built = SwitchExpressionOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::SwitchExpressionOpt(Some(switch_expression_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 562:
    ///
    /// `SwitchExpressionOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn switch_expression_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::SwitchExpressionOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 563:
    ///
    /// `TypeExpression: Type LParen Expression RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn type_expression(
        &mut self,
        _type: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let type_expression_built = TypeExpression {
            r#type: Box::new(r#type),
            l_paren: Box::new(l_paren),
            expression: Box::new(expression),
            r_paren: Box::new(r_paren),
        };
        // Calling user action here
        self.user_grammar.type_expression(&type_expression_built)?;
        self.push(ASTType::TypeExpression(type_expression_built), context);
        Ok(())
    }

    /// Semantic action for production 564:
    ///
    /// `InsideExpression: Inside Expression LBrace RangeList RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn inside_expression(
        &mut self,
        _inside: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _range_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let range_list = pop_item!(self, range_list, RangeList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let inside = pop_item!(self, inside, Inside, context);
        let inside_expression_built = InsideExpression {
            inside: Box::new(inside),
            expression: Box::new(expression),
            l_brace: Box::new(l_brace),
            range_list: Box::new(range_list),
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .inside_expression(&inside_expression_built)?;
        self.push(ASTType::InsideExpression(inside_expression_built), context);
        Ok(())
    }

    /// Semantic action for production 565:
    ///
    /// `OutsideExpression: Outside Expression LBrace RangeList RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn outside_expression(
        &mut self,
        _outside: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _range_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let range_list = pop_item!(self, range_list, RangeList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let outside = pop_item!(self, outside, Outside, context);
        let outside_expression_built = OutsideExpression {
            outside: Box::new(outside),
            expression: Box::new(expression),
            l_brace: Box::new(l_brace),
            range_list: Box::new(range_list),
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .outside_expression(&outside_expression_built)?;
        self.push(
            ASTType::OutsideExpression(outside_expression_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 566:
    ///
    /// `RangeList: RangeItem RangeListList /* Vec */ RangeListOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn range_list(
        &mut self,
        _range_item: &ParseTreeType<'t>,
        _range_list_list: &ParseTreeType<'t>,
        _range_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let range_list_opt = pop_item!(self, range_list_opt, RangeListOpt, context);
        let range_list_list = pop_and_reverse_item!(self, range_list_list, RangeListList, context);
        let range_item = pop_item!(self, range_item, RangeItem, context);
        let range_list_built = RangeList {
            range_item: Box::new(range_item),
            range_list_list,
            range_list_opt,
        };
        // Calling user action here
        self.user_grammar.range_list(&range_list_built)?;
        self.push(ASTType::RangeList(range_list_built), context);
        Ok(())
    }

    /// Semantic action for production 567:
    ///
    /// `RangeListList /* Vec<T>::Push */: Comma RangeItem RangeListList;`
    ///
    #[parol_runtime::function_name::named]
    fn range_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _range_item: &ParseTreeType<'t>,
        _range_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut range_list_list = pop_item!(self, range_list_list, RangeListList, context);
        let range_item = pop_item!(self, range_item, RangeItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let range_list_list_0_built = RangeListList {
            range_item: Box::new(range_item),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        range_list_list.push(range_list_list_0_built);
        self.push(ASTType::RangeListList(range_list_list), context);
        Ok(())
    }

    /// Semantic action for production 568:
    ///
    /// `RangeListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn range_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let range_list_list_1_built = Vec::new();
        self.push(ASTType::RangeListList(range_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 569:
    ///
    /// `RangeListOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn range_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let range_list_opt_0_built = RangeListOpt {
            comma: Box::new(comma),
        };
        self.push(ASTType::RangeListOpt(Some(range_list_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 570:
    ///
    /// `RangeListOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn range_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::RangeListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 571:
    ///
    /// `RangeItem: Range;`
    ///
    #[parol_runtime::function_name::named]
    fn range_item(&mut self, _range: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let range = pop_item!(self, range, Range, context);
        let range_item_built = RangeItem {
            range: Box::new(range),
        };
        // Calling user action here
        self.user_grammar.range_item(&range_item_built)?;
        self.push(ASTType::RangeItem(range_item_built), context);
        Ok(())
    }

    /// Semantic action for production 572:
    ///
    /// `Select: LBracket Expression SelectOpt /* Option */ RBracket;`
    ///
    #[parol_runtime::function_name::named]
    fn select(
        &mut self,
        _l_bracket: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _select_opt: &ParseTreeType<'t>,
        _r_bracket: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = pop_item!(self, r_bracket, RBracket, context);
        let select_opt = pop_item!(self, select_opt, SelectOpt, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_bracket = pop_item!(self, l_bracket, LBracket, context);
        let select_built = Select {
            l_bracket: Box::new(l_bracket),
            expression: Box::new(expression),
            select_opt,
            r_bracket: Box::new(r_bracket),
        };
        // Calling user action here
        self.user_grammar.select(&select_built)?;
        self.push(ASTType::Select(select_built), context);
        Ok(())
    }

    /// Semantic action for production 573:
    ///
    /// `SelectOpt /* Option<T>::Some */: SelectOperator Expression;`
    ///
    #[parol_runtime::function_name::named]
    fn select_opt_0(
        &mut self,
        _select_operator: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let select_operator = pop_item!(self, select_operator, SelectOperator, context);
        let select_opt_0_built = SelectOpt {
            select_operator: Box::new(select_operator),
            expression: Box::new(expression),
        };
        self.push(ASTType::SelectOpt(Some(select_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 574:
    ///
    /// `SelectOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn select_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::SelectOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 575:
    ///
    /// `SelectOperator: Colon;`
    ///
    #[parol_runtime::function_name::named]
    fn select_operator_0(&mut self, _colon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let colon = pop_item!(self, colon, Colon, context);
        let select_operator_0_built = SelectOperatorColon {
            colon: Box::new(colon),
        };
        let select_operator_0_built = SelectOperator::Colon(select_operator_0_built);
        // Calling user action here
        self.user_grammar
            .select_operator(&select_operator_0_built)?;
        self.push(ASTType::SelectOperator(select_operator_0_built), context);
        Ok(())
    }

    /// Semantic action for production 576:
    ///
    /// `SelectOperator: PlusColon;`
    ///
    #[parol_runtime::function_name::named]
    fn select_operator_1(&mut self, _plus_colon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let plus_colon = pop_item!(self, plus_colon, PlusColon, context);
        let select_operator_1_built = SelectOperatorPlusColon {
            plus_colon: Box::new(plus_colon),
        };
        let select_operator_1_built = SelectOperator::PlusColon(select_operator_1_built);
        // Calling user action here
        self.user_grammar
            .select_operator(&select_operator_1_built)?;
        self.push(ASTType::SelectOperator(select_operator_1_built), context);
        Ok(())
    }

    /// Semantic action for production 577:
    ///
    /// `SelectOperator: MinusColon;`
    ///
    #[parol_runtime::function_name::named]
    fn select_operator_2(&mut self, _minus_colon: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let minus_colon = pop_item!(self, minus_colon, MinusColon, context);
        let select_operator_2_built = SelectOperatorMinusColon {
            minus_colon: Box::new(minus_colon),
        };
        let select_operator_2_built = SelectOperator::MinusColon(select_operator_2_built);
        // Calling user action here
        self.user_grammar
            .select_operator(&select_operator_2_built)?;
        self.push(ASTType::SelectOperator(select_operator_2_built), context);
        Ok(())
    }

    /// Semantic action for production 578:
    ///
    /// `SelectOperator: Step;`
    ///
    #[parol_runtime::function_name::named]
    fn select_operator_3(&mut self, _step: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let step = pop_item!(self, step, Step, context);
        let select_operator_3_built = SelectOperatorStep {
            step: Box::new(step),
        };
        let select_operator_3_built = SelectOperator::Step(select_operator_3_built);
        // Calling user action here
        self.user_grammar
            .select_operator(&select_operator_3_built)?;
        self.push(ASTType::SelectOperator(select_operator_3_built), context);
        Ok(())
    }

    /// Semantic action for production 579:
    ///
    /// `Width: LAngle Expression WidthList /* Vec */ RAngle;`
    ///
    #[parol_runtime::function_name::named]
    fn width(
        &mut self,
        _l_angle: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _width_list: &ParseTreeType<'t>,
        _r_angle: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_angle = pop_item!(self, r_angle, RAngle, context);
        let width_list = pop_and_reverse_item!(self, width_list, WidthList, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_angle = pop_item!(self, l_angle, LAngle, context);
        let width_built = Width {
            l_angle: Box::new(l_angle),
            expression: Box::new(expression),
            width_list,
            r_angle: Box::new(r_angle),
        };
        // Calling user action here
        self.user_grammar.width(&width_built)?;
        self.push(ASTType::Width(width_built), context);
        Ok(())
    }

    /// Semantic action for production 580:
    ///
    /// `WidthList /* Vec<T>::Push */: Comma Expression WidthList;`
    ///
    #[parol_runtime::function_name::named]
    fn width_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _width_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut width_list = pop_item!(self, width_list, WidthList, context);
        let expression = pop_item!(self, expression, Expression, context);
        let comma = pop_item!(self, comma, Comma, context);
        let width_list_0_built = WidthList {
            expression: Box::new(expression),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        width_list.push(width_list_0_built);
        self.push(ASTType::WidthList(width_list), context);
        Ok(())
    }

    /// Semantic action for production 581:
    ///
    /// `WidthList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn width_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let width_list_1_built = Vec::new();
        self.push(ASTType::WidthList(width_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 582:
    ///
    /// `Array: LBracket Expression ArrayList /* Vec */ RBracket;`
    ///
    #[parol_runtime::function_name::named]
    fn array(
        &mut self,
        _l_bracket: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _array_list: &ParseTreeType<'t>,
        _r_bracket: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = pop_item!(self, r_bracket, RBracket, context);
        let array_list = pop_and_reverse_item!(self, array_list, ArrayList, context);
        let expression = pop_item!(self, expression, Expression, context);
        let l_bracket = pop_item!(self, l_bracket, LBracket, context);
        let array_built = Array {
            l_bracket: Box::new(l_bracket),
            expression: Box::new(expression),
            array_list,
            r_bracket: Box::new(r_bracket),
        };
        // Calling user action here
        self.user_grammar.array(&array_built)?;
        self.push(ASTType::Array(array_built), context);
        Ok(())
    }

    /// Semantic action for production 583:
    ///
    /// `ArrayList /* Vec<T>::Push */: Comma Expression ArrayList;`
    ///
    #[parol_runtime::function_name::named]
    fn array_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _array_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut array_list = pop_item!(self, array_list, ArrayList, context);
        let expression = pop_item!(self, expression, Expression, context);
        let comma = pop_item!(self, comma, Comma, context);
        let array_list_0_built = ArrayList {
            expression: Box::new(expression),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        array_list.push(array_list_0_built);
        self.push(ASTType::ArrayList(array_list), context);
        Ok(())
    }

    /// Semantic action for production 584:
    ///
    /// `ArrayList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_list_1_built = Vec::new();
        self.push(ASTType::ArrayList(array_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 585:
    ///
    /// `Range: Expression RangeOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn range(
        &mut self,
        _expression: &ParseTreeType<'t>,
        _range_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let range_opt = pop_item!(self, range_opt, RangeOpt, context);
        let expression = pop_item!(self, expression, Expression, context);
        let range_built = Range {
            expression: Box::new(expression),
            range_opt,
        };
        // Calling user action here
        self.user_grammar.range(&range_built)?;
        self.push(ASTType::Range(range_built), context);
        Ok(())
    }

    /// Semantic action for production 586:
    ///
    /// `RangeOpt /* Option<T>::Some */: RangeOperator Expression;`
    ///
    #[parol_runtime::function_name::named]
    fn range_opt_0(
        &mut self,
        _range_operator: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let range_operator = pop_item!(self, range_operator, RangeOperator, context);
        let range_opt_0_built = RangeOpt {
            range_operator: Box::new(range_operator),
            expression: Box::new(expression),
        };
        self.push(ASTType::RangeOpt(Some(range_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 587:
    ///
    /// `RangeOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn range_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::RangeOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 588:
    ///
    /// `RangeOperator: DotDot;`
    ///
    #[parol_runtime::function_name::named]
    fn range_operator_0(&mut self, _dot_dot: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_dot = pop_item!(self, dot_dot, DotDot, context);
        let range_operator_0_built = RangeOperatorDotDot {
            dot_dot: Box::new(dot_dot),
        };
        let range_operator_0_built = RangeOperator::DotDot(range_operator_0_built);
        // Calling user action here
        self.user_grammar.range_operator(&range_operator_0_built)?;
        self.push(ASTType::RangeOperator(range_operator_0_built), context);
        Ok(())
    }

    /// Semantic action for production 589:
    ///
    /// `RangeOperator: DotDotEqu;`
    ///
    #[parol_runtime::function_name::named]
    fn range_operator_1(&mut self, _dot_dot_equ: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let dot_dot_equ = pop_item!(self, dot_dot_equ, DotDotEqu, context);
        let range_operator_1_built = RangeOperatorDotDotEqu {
            dot_dot_equ: Box::new(dot_dot_equ),
        };
        let range_operator_1_built = RangeOperator::DotDotEqu(range_operator_1_built);
        // Calling user action here
        self.user_grammar.range_operator(&range_operator_1_built)?;
        self.push(ASTType::RangeOperator(range_operator_1_built), context);
        Ok(())
    }

    /// Semantic action for production 590:
    ///
    /// `FixedType: U8;`
    ///
    #[parol_runtime::function_name::named]
    fn fixed_type_0(&mut self, _u8: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u8 = pop_item!(self, u8, U8, context);
        let fixed_type_0_built = FixedTypeU8 { u8: Box::new(u8) };
        let fixed_type_0_built = FixedType::U8(fixed_type_0_built);
        // Calling user action here
        self.user_grammar.fixed_type(&fixed_type_0_built)?;
        self.push(ASTType::FixedType(fixed_type_0_built), context);
        Ok(())
    }

    /// Semantic action for production 591:
    ///
    /// `FixedType: U16;`
    ///
    #[parol_runtime::function_name::named]
    fn fixed_type_1(&mut self, _u16: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u16 = pop_item!(self, u16, U16, context);
        let fixed_type_1_built = FixedTypeU16 { u16: Box::new(u16) };
        let fixed_type_1_built = FixedType::U16(fixed_type_1_built);
        // Calling user action here
        self.user_grammar.fixed_type(&fixed_type_1_built)?;
        self.push(ASTType::FixedType(fixed_type_1_built), context);
        Ok(())
    }

    /// Semantic action for production 592:
    ///
    /// `FixedType: U32;`
    ///
    #[parol_runtime::function_name::named]
    fn fixed_type_2(&mut self, _u32: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u32 = pop_item!(self, u32, U32, context);
        let fixed_type_2_built = FixedTypeU32 { u32: Box::new(u32) };
        let fixed_type_2_built = FixedType::U32(fixed_type_2_built);
        // Calling user action here
        self.user_grammar.fixed_type(&fixed_type_2_built)?;
        self.push(ASTType::FixedType(fixed_type_2_built), context);
        Ok(())
    }

    /// Semantic action for production 593:
    ///
    /// `FixedType: U64;`
    ///
    #[parol_runtime::function_name::named]
    fn fixed_type_3(&mut self, _u64: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u64 = pop_item!(self, u64, U64, context);
        let fixed_type_3_built = FixedTypeU64 { u64: Box::new(u64) };
        let fixed_type_3_built = FixedType::U64(fixed_type_3_built);
        // Calling user action here
        self.user_grammar.fixed_type(&fixed_type_3_built)?;
        self.push(ASTType::FixedType(fixed_type_3_built), context);
        Ok(())
    }

    /// Semantic action for production 594:
    ///
    /// `FixedType: I8;`
    ///
    #[parol_runtime::function_name::named]
    fn fixed_type_4(&mut self, _i8: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i8 = pop_item!(self, i8, I8, context);
        let fixed_type_4_built = FixedTypeI8 { i8: Box::new(i8) };
        let fixed_type_4_built = FixedType::I8(fixed_type_4_built);
        // Calling user action here
        self.user_grammar.fixed_type(&fixed_type_4_built)?;
        self.push(ASTType::FixedType(fixed_type_4_built), context);
        Ok(())
    }

    /// Semantic action for production 595:
    ///
    /// `FixedType: I16;`
    ///
    #[parol_runtime::function_name::named]
    fn fixed_type_5(&mut self, _i16: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i16 = pop_item!(self, i16, I16, context);
        let fixed_type_5_built = FixedTypeI16 { i16: Box::new(i16) };
        let fixed_type_5_built = FixedType::I16(fixed_type_5_built);
        // Calling user action here
        self.user_grammar.fixed_type(&fixed_type_5_built)?;
        self.push(ASTType::FixedType(fixed_type_5_built), context);
        Ok(())
    }

    /// Semantic action for production 596:
    ///
    /// `FixedType: I32;`
    ///
    #[parol_runtime::function_name::named]
    fn fixed_type_6(&mut self, _i32: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i32 = pop_item!(self, i32, I32, context);
        let fixed_type_6_built = FixedTypeI32 { i32: Box::new(i32) };
        let fixed_type_6_built = FixedType::I32(fixed_type_6_built);
        // Calling user action here
        self.user_grammar.fixed_type(&fixed_type_6_built)?;
        self.push(ASTType::FixedType(fixed_type_6_built), context);
        Ok(())
    }

    /// Semantic action for production 597:
    ///
    /// `FixedType: I64;`
    ///
    #[parol_runtime::function_name::named]
    fn fixed_type_7(&mut self, _i64: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i64 = pop_item!(self, i64, I64, context);
        let fixed_type_7_built = FixedTypeI64 { i64: Box::new(i64) };
        let fixed_type_7_built = FixedType::I64(fixed_type_7_built);
        // Calling user action here
        self.user_grammar.fixed_type(&fixed_type_7_built)?;
        self.push(ASTType::FixedType(fixed_type_7_built), context);
        Ok(())
    }

    /// Semantic action for production 598:
    ///
    /// `FixedType: F32;`
    ///
    #[parol_runtime::function_name::named]
    fn fixed_type_8(&mut self, _f32: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f32 = pop_item!(self, f32, F32, context);
        let fixed_type_8_built = FixedTypeF32 { f32: Box::new(f32) };
        let fixed_type_8_built = FixedType::F32(fixed_type_8_built);
        // Calling user action here
        self.user_grammar.fixed_type(&fixed_type_8_built)?;
        self.push(ASTType::FixedType(fixed_type_8_built), context);
        Ok(())
    }

    /// Semantic action for production 599:
    ///
    /// `FixedType: F64;`
    ///
    #[parol_runtime::function_name::named]
    fn fixed_type_9(&mut self, _f64: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f64 = pop_item!(self, f64, F64, context);
        let fixed_type_9_built = FixedTypeF64 { f64: Box::new(f64) };
        let fixed_type_9_built = FixedType::F64(fixed_type_9_built);
        // Calling user action here
        self.user_grammar.fixed_type(&fixed_type_9_built)?;
        self.push(ASTType::FixedType(fixed_type_9_built), context);
        Ok(())
    }

    /// Semantic action for production 600:
    ///
    /// `FixedType: Bool;`
    ///
    #[parol_runtime::function_name::named]
    fn fixed_type_10(&mut self, _bool: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bool = pop_item!(self, bool, Bool, context);
        let fixed_type_10_built = FixedTypeBool {
            bool: Box::new(bool),
        };
        let fixed_type_10_built = FixedType::Bool(fixed_type_10_built);
        // Calling user action here
        self.user_grammar.fixed_type(&fixed_type_10_built)?;
        self.push(ASTType::FixedType(fixed_type_10_built), context);
        Ok(())
    }

    /// Semantic action for production 601:
    ///
    /// `FixedType: Strin;`
    ///
    #[parol_runtime::function_name::named]
    fn fixed_type_11(&mut self, _strin: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let strin = pop_item!(self, strin, Strin, context);
        let fixed_type_11_built = FixedTypeStrin {
            strin: Box::new(strin),
        };
        let fixed_type_11_built = FixedType::Strin(fixed_type_11_built);
        // Calling user action here
        self.user_grammar.fixed_type(&fixed_type_11_built)?;
        self.push(ASTType::FixedType(fixed_type_11_built), context);
        Ok(())
    }

    /// Semantic action for production 602:
    ///
    /// `VariableType: Clock;`
    ///
    #[parol_runtime::function_name::named]
    fn variable_type_0(&mut self, _clock: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let clock = pop_item!(self, clock, Clock, context);
        let variable_type_0_built = VariableTypeClock {
            clock: Box::new(clock),
        };
        let variable_type_0_built = VariableType::Clock(variable_type_0_built);
        // Calling user action here
        self.user_grammar.variable_type(&variable_type_0_built)?;
        self.push(ASTType::VariableType(variable_type_0_built), context);
        Ok(())
    }

    /// Semantic action for production 603:
    ///
    /// `VariableType: ClockPosedge;`
    ///
    #[parol_runtime::function_name::named]
    fn variable_type_1(&mut self, _clock_posedge: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let clock_posedge = pop_item!(self, clock_posedge, ClockPosedge, context);
        let variable_type_1_built = VariableTypeClockPosedge {
            clock_posedge: Box::new(clock_posedge),
        };
        let variable_type_1_built = VariableType::ClockPosedge(variable_type_1_built);
        // Calling user action here
        self.user_grammar.variable_type(&variable_type_1_built)?;
        self.push(ASTType::VariableType(variable_type_1_built), context);
        Ok(())
    }

    /// Semantic action for production 604:
    ///
    /// `VariableType: ClockNegedge;`
    ///
    #[parol_runtime::function_name::named]
    fn variable_type_2(&mut self, _clock_negedge: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let clock_negedge = pop_item!(self, clock_negedge, ClockNegedge, context);
        let variable_type_2_built = VariableTypeClockNegedge {
            clock_negedge: Box::new(clock_negedge),
        };
        let variable_type_2_built = VariableType::ClockNegedge(variable_type_2_built);
        // Calling user action here
        self.user_grammar.variable_type(&variable_type_2_built)?;
        self.push(ASTType::VariableType(variable_type_2_built), context);
        Ok(())
    }

    /// Semantic action for production 605:
    ///
    /// `VariableType: Reset;`
    ///
    #[parol_runtime::function_name::named]
    fn variable_type_3(&mut self, _reset: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let reset = pop_item!(self, reset, Reset, context);
        let variable_type_3_built = VariableTypeReset {
            reset: Box::new(reset),
        };
        let variable_type_3_built = VariableType::Reset(variable_type_3_built);
        // Calling user action here
        self.user_grammar.variable_type(&variable_type_3_built)?;
        self.push(ASTType::VariableType(variable_type_3_built), context);
        Ok(())
    }

    /// Semantic action for production 606:
    ///
    /// `VariableType: ResetAsyncHigh;`
    ///
    #[parol_runtime::function_name::named]
    fn variable_type_4(&mut self, _reset_async_high: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let reset_async_high = pop_item!(self, reset_async_high, ResetAsyncHigh, context);
        let variable_type_4_built = VariableTypeResetAsyncHigh {
            reset_async_high: Box::new(reset_async_high),
        };
        let variable_type_4_built = VariableType::ResetAsyncHigh(variable_type_4_built);
        // Calling user action here
        self.user_grammar.variable_type(&variable_type_4_built)?;
        self.push(ASTType::VariableType(variable_type_4_built), context);
        Ok(())
    }

    /// Semantic action for production 607:
    ///
    /// `VariableType: ResetAsyncLow;`
    ///
    #[parol_runtime::function_name::named]
    fn variable_type_5(&mut self, _reset_async_low: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let reset_async_low = pop_item!(self, reset_async_low, ResetAsyncLow, context);
        let variable_type_5_built = VariableTypeResetAsyncLow {
            reset_async_low: Box::new(reset_async_low),
        };
        let variable_type_5_built = VariableType::ResetAsyncLow(variable_type_5_built);
        // Calling user action here
        self.user_grammar.variable_type(&variable_type_5_built)?;
        self.push(ASTType::VariableType(variable_type_5_built), context);
        Ok(())
    }

    /// Semantic action for production 608:
    ///
    /// `VariableType: ResetSyncHigh;`
    ///
    #[parol_runtime::function_name::named]
    fn variable_type_6(&mut self, _reset_sync_high: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let reset_sync_high = pop_item!(self, reset_sync_high, ResetSyncHigh, context);
        let variable_type_6_built = VariableTypeResetSyncHigh {
            reset_sync_high: Box::new(reset_sync_high),
        };
        let variable_type_6_built = VariableType::ResetSyncHigh(variable_type_6_built);
        // Calling user action here
        self.user_grammar.variable_type(&variable_type_6_built)?;
        self.push(ASTType::VariableType(variable_type_6_built), context);
        Ok(())
    }

    /// Semantic action for production 609:
    ///
    /// `VariableType: ResetSyncLow;`
    ///
    #[parol_runtime::function_name::named]
    fn variable_type_7(&mut self, _reset_sync_low: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let reset_sync_low = pop_item!(self, reset_sync_low, ResetSyncLow, context);
        let variable_type_7_built = VariableTypeResetSyncLow {
            reset_sync_low: Box::new(reset_sync_low),
        };
        let variable_type_7_built = VariableType::ResetSyncLow(variable_type_7_built);
        // Calling user action here
        self.user_grammar.variable_type(&variable_type_7_built)?;
        self.push(ASTType::VariableType(variable_type_7_built), context);
        Ok(())
    }

    /// Semantic action for production 610:
    ///
    /// `VariableType: Logic;`
    ///
    #[parol_runtime::function_name::named]
    fn variable_type_8(&mut self, _logic: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let logic = pop_item!(self, logic, Logic, context);
        let variable_type_8_built = VariableTypeLogic {
            logic: Box::new(logic),
        };
        let variable_type_8_built = VariableType::Logic(variable_type_8_built);
        // Calling user action here
        self.user_grammar.variable_type(&variable_type_8_built)?;
        self.push(ASTType::VariableType(variable_type_8_built), context);
        Ok(())
    }

    /// Semantic action for production 611:
    ///
    /// `VariableType: Bit;`
    ///
    #[parol_runtime::function_name::named]
    fn variable_type_9(&mut self, _bit: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bit = pop_item!(self, bit, Bit, context);
        let variable_type_9_built = VariableTypeBit { bit: Box::new(bit) };
        let variable_type_9_built = VariableType::Bit(variable_type_9_built);
        // Calling user action here
        self.user_grammar.variable_type(&variable_type_9_built)?;
        self.push(ASTType::VariableType(variable_type_9_built), context);
        Ok(())
    }

    /// Semantic action for production 612:
    ///
    /// `UserDefinedType: ScopedIdentifier;`
    ///
    #[parol_runtime::function_name::named]
    fn user_defined_type(&mut self, _scoped_identifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_identifier = pop_item!(self, scoped_identifier, ScopedIdentifier, context);
        let user_defined_type_built = UserDefinedType {
            scoped_identifier: Box::new(scoped_identifier),
        };
        // Calling user action here
        self.user_grammar
            .user_defined_type(&user_defined_type_built)?;
        self.push(ASTType::UserDefinedType(user_defined_type_built), context);
        Ok(())
    }

    /// Semantic action for production 613:
    ///
    /// `TypeModifier: Tri;`
    ///
    #[parol_runtime::function_name::named]
    fn type_modifier_0(&mut self, _tri: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let tri = pop_item!(self, tri, Tri, context);
        let type_modifier_0_built = TypeModifierTri { tri: Box::new(tri) };
        let type_modifier_0_built = TypeModifier::Tri(type_modifier_0_built);
        // Calling user action here
        self.user_grammar.type_modifier(&type_modifier_0_built)?;
        self.push(ASTType::TypeModifier(type_modifier_0_built), context);
        Ok(())
    }

    /// Semantic action for production 614:
    ///
    /// `TypeModifier: Signed;`
    ///
    #[parol_runtime::function_name::named]
    fn type_modifier_1(&mut self, _signed: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let signed = pop_item!(self, signed, Signed, context);
        let type_modifier_1_built = TypeModifierSigned {
            signed: Box::new(signed),
        };
        let type_modifier_1_built = TypeModifier::Signed(type_modifier_1_built);
        // Calling user action here
        self.user_grammar.type_modifier(&type_modifier_1_built)?;
        self.push(ASTType::TypeModifier(type_modifier_1_built), context);
        Ok(())
    }

    /// Semantic action for production 615:
    ///
    /// `TypeModifier: Defaul;`
    ///
    #[parol_runtime::function_name::named]
    fn type_modifier_2(&mut self, _defaul: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let defaul = pop_item!(self, defaul, Defaul, context);
        let type_modifier_2_built = TypeModifierDefaul {
            defaul: Box::new(defaul),
        };
        let type_modifier_2_built = TypeModifier::Defaul(type_modifier_2_built);
        // Calling user action here
        self.user_grammar.type_modifier(&type_modifier_2_built)?;
        self.push(ASTType::TypeModifier(type_modifier_2_built), context);
        Ok(())
    }

    /// Semantic action for production 616:
    ///
    /// `FactorType: FactorTypeGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_type(&mut self, _factor_type_group: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_type_group = pop_item!(self, factor_type_group, FactorTypeGroup, context);
        let factor_type_built = FactorType {
            factor_type_group: Box::new(factor_type_group),
        };
        // Calling user action here
        self.user_grammar.factor_type(&factor_type_built)?;
        self.push(ASTType::FactorType(factor_type_built), context);
        Ok(())
    }

    /// Semantic action for production 617:
    ///
    /// `FactorTypeGroup: VariableType FactorTypeOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_type_group_0(
        &mut self,
        _variable_type: &ParseTreeType<'t>,
        _factor_type_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_type_opt = pop_item!(self, factor_type_opt, FactorTypeOpt, context);
        let variable_type = pop_item!(self, variable_type, VariableType, context);
        let factor_type_group_0_built = FactorTypeGroupVariableTypeFactorTypeOpt {
            variable_type: Box::new(variable_type),
            factor_type_opt,
        };
        let factor_type_group_0_built =
            FactorTypeGroup::VariableTypeFactorTypeOpt(factor_type_group_0_built);
        self.push(ASTType::FactorTypeGroup(factor_type_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 618:
    ///
    /// `FactorTypeGroup: FixedType;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_type_group_1(&mut self, _fixed_type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fixed_type = pop_item!(self, fixed_type, FixedType, context);
        let factor_type_group_1_built = FactorTypeGroupFixedType {
            fixed_type: Box::new(fixed_type),
        };
        let factor_type_group_1_built = FactorTypeGroup::FixedType(factor_type_group_1_built);
        self.push(ASTType::FactorTypeGroup(factor_type_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 619:
    ///
    /// `FactorTypeOpt /* Option<T>::Some */: Width;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_type_opt_0(&mut self, _width: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let width = pop_item!(self, width, Width, context);
        let factor_type_opt_0_built = FactorTypeOpt {
            width: Box::new(width),
        };
        self.push(
            ASTType::FactorTypeOpt(Some(factor_type_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 620:
    ///
    /// `FactorTypeOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn factor_type_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FactorTypeOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 621:
    ///
    /// `ScalarType: ScalarTypeList /* Vec */ ScalarTypeGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn scalar_type(
        &mut self,
        _scalar_type_list: &ParseTreeType<'t>,
        _scalar_type_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scalar_type_group = pop_item!(self, scalar_type_group, ScalarTypeGroup, context);
        let scalar_type_list =
            pop_and_reverse_item!(self, scalar_type_list, ScalarTypeList, context);
        let scalar_type_built = ScalarType {
            scalar_type_list,
            scalar_type_group: Box::new(scalar_type_group),
        };
        // Calling user action here
        self.user_grammar.scalar_type(&scalar_type_built)?;
        self.push(ASTType::ScalarType(scalar_type_built), context);
        Ok(())
    }

    /// Semantic action for production 622:
    ///
    /// `ScalarTypeGroup: UserDefinedType ScalarTypeOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn scalar_type_group_0(
        &mut self,
        _user_defined_type: &ParseTreeType<'t>,
        _scalar_type_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scalar_type_opt = pop_item!(self, scalar_type_opt, ScalarTypeOpt, context);
        let user_defined_type = pop_item!(self, user_defined_type, UserDefinedType, context);
        let scalar_type_group_0_built = ScalarTypeGroupUserDefinedTypeScalarTypeOpt {
            user_defined_type: Box::new(user_defined_type),
            scalar_type_opt,
        };
        let scalar_type_group_0_built =
            ScalarTypeGroup::UserDefinedTypeScalarTypeOpt(scalar_type_group_0_built);
        self.push(ASTType::ScalarTypeGroup(scalar_type_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 623:
    ///
    /// `ScalarTypeGroup: FactorType;`
    ///
    #[parol_runtime::function_name::named]
    fn scalar_type_group_1(&mut self, _factor_type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let factor_type = pop_item!(self, factor_type, FactorType, context);
        let scalar_type_group_1_built = ScalarTypeGroupFactorType {
            factor_type: Box::new(factor_type),
        };
        let scalar_type_group_1_built = ScalarTypeGroup::FactorType(scalar_type_group_1_built);
        self.push(ASTType::ScalarTypeGroup(scalar_type_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 624:
    ///
    /// `ScalarTypeList /* Vec<T>::Push */: TypeModifier ScalarTypeList;`
    ///
    #[parol_runtime::function_name::named]
    fn scalar_type_list_0(
        &mut self,
        _type_modifier: &ParseTreeType<'t>,
        _scalar_type_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut scalar_type_list = pop_item!(self, scalar_type_list, ScalarTypeList, context);
        let type_modifier = pop_item!(self, type_modifier, TypeModifier, context);
        let scalar_type_list_0_built = ScalarTypeList {
            type_modifier: Box::new(type_modifier),
        };
        // Add an element to the vector
        scalar_type_list.push(scalar_type_list_0_built);
        self.push(ASTType::ScalarTypeList(scalar_type_list), context);
        Ok(())
    }

    /// Semantic action for production 625:
    ///
    /// `ScalarTypeList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn scalar_type_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scalar_type_list_1_built = Vec::new();
        self.push(ASTType::ScalarTypeList(scalar_type_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 626:
    ///
    /// `ScalarTypeOpt /* Option<T>::Some */: Width;`
    ///
    #[parol_runtime::function_name::named]
    fn scalar_type_opt_0(&mut self, _width: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let width = pop_item!(self, width, Width, context);
        let scalar_type_opt_0_built = ScalarTypeOpt {
            width: Box::new(width),
        };
        self.push(
            ASTType::ScalarTypeOpt(Some(scalar_type_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 627:
    ///
    /// `ScalarTypeOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn scalar_type_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ScalarTypeOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 628:
    ///
    /// `ArrayType: ScalarType ArrayTypeOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn array_type(
        &mut self,
        _scalar_type: &ParseTreeType<'t>,
        _array_type_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_type_opt = pop_item!(self, array_type_opt, ArrayTypeOpt, context);
        let scalar_type = pop_item!(self, scalar_type, ScalarType, context);
        let array_type_built = ArrayType {
            scalar_type: Box::new(scalar_type),
            array_type_opt,
        };
        // Calling user action here
        self.user_grammar.array_type(&array_type_built)?;
        self.push(ASTType::ArrayType(array_type_built), context);
        Ok(())
    }

    /// Semantic action for production 629:
    ///
    /// `ArrayTypeOpt /* Option<T>::Some */: Array;`
    ///
    #[parol_runtime::function_name::named]
    fn array_type_opt_0(&mut self, _array: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array = pop_item!(self, array, Array, context);
        let array_type_opt_0_built = ArrayTypeOpt {
            array: Box::new(array),
        };
        self.push(ASTType::ArrayTypeOpt(Some(array_type_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 630:
    ///
    /// `ArrayTypeOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn array_type_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ArrayTypeOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 631:
    ///
    /// `CastingType: U8;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_0(&mut self, _u8: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u8 = pop_item!(self, u8, U8, context);
        let casting_type_0_built = CastingTypeU8 { u8: Box::new(u8) };
        let casting_type_0_built = CastingType::U8(casting_type_0_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_0_built)?;
        self.push(ASTType::CastingType(casting_type_0_built), context);
        Ok(())
    }

    /// Semantic action for production 632:
    ///
    /// `CastingType: U16;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_1(&mut self, _u16: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u16 = pop_item!(self, u16, U16, context);
        let casting_type_1_built = CastingTypeU16 { u16: Box::new(u16) };
        let casting_type_1_built = CastingType::U16(casting_type_1_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_1_built)?;
        self.push(ASTType::CastingType(casting_type_1_built), context);
        Ok(())
    }

    /// Semantic action for production 633:
    ///
    /// `CastingType: U32;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_2(&mut self, _u32: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u32 = pop_item!(self, u32, U32, context);
        let casting_type_2_built = CastingTypeU32 { u32: Box::new(u32) };
        let casting_type_2_built = CastingType::U32(casting_type_2_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_2_built)?;
        self.push(ASTType::CastingType(casting_type_2_built), context);
        Ok(())
    }

    /// Semantic action for production 634:
    ///
    /// `CastingType: U64;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_3(&mut self, _u64: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let u64 = pop_item!(self, u64, U64, context);
        let casting_type_3_built = CastingTypeU64 { u64: Box::new(u64) };
        let casting_type_3_built = CastingType::U64(casting_type_3_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_3_built)?;
        self.push(ASTType::CastingType(casting_type_3_built), context);
        Ok(())
    }

    /// Semantic action for production 635:
    ///
    /// `CastingType: I8;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_4(&mut self, _i8: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i8 = pop_item!(self, i8, I8, context);
        let casting_type_4_built = CastingTypeI8 { i8: Box::new(i8) };
        let casting_type_4_built = CastingType::I8(casting_type_4_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_4_built)?;
        self.push(ASTType::CastingType(casting_type_4_built), context);
        Ok(())
    }

    /// Semantic action for production 636:
    ///
    /// `CastingType: I16;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_5(&mut self, _i16: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i16 = pop_item!(self, i16, I16, context);
        let casting_type_5_built = CastingTypeI16 { i16: Box::new(i16) };
        let casting_type_5_built = CastingType::I16(casting_type_5_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_5_built)?;
        self.push(ASTType::CastingType(casting_type_5_built), context);
        Ok(())
    }

    /// Semantic action for production 637:
    ///
    /// `CastingType: I32;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_6(&mut self, _i32: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i32 = pop_item!(self, i32, I32, context);
        let casting_type_6_built = CastingTypeI32 { i32: Box::new(i32) };
        let casting_type_6_built = CastingType::I32(casting_type_6_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_6_built)?;
        self.push(ASTType::CastingType(casting_type_6_built), context);
        Ok(())
    }

    /// Semantic action for production 638:
    ///
    /// `CastingType: I64;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_7(&mut self, _i64: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let i64 = pop_item!(self, i64, I64, context);
        let casting_type_7_built = CastingTypeI64 { i64: Box::new(i64) };
        let casting_type_7_built = CastingType::I64(casting_type_7_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_7_built)?;
        self.push(ASTType::CastingType(casting_type_7_built), context);
        Ok(())
    }

    /// Semantic action for production 639:
    ///
    /// `CastingType: F32;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_8(&mut self, _f32: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f32 = pop_item!(self, f32, F32, context);
        let casting_type_8_built = CastingTypeF32 { f32: Box::new(f32) };
        let casting_type_8_built = CastingType::F32(casting_type_8_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_8_built)?;
        self.push(ASTType::CastingType(casting_type_8_built), context);
        Ok(())
    }

    /// Semantic action for production 640:
    ///
    /// `CastingType: F64;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_9(&mut self, _f64: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let f64 = pop_item!(self, f64, F64, context);
        let casting_type_9_built = CastingTypeF64 { f64: Box::new(f64) };
        let casting_type_9_built = CastingType::F64(casting_type_9_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_9_built)?;
        self.push(ASTType::CastingType(casting_type_9_built), context);
        Ok(())
    }

    /// Semantic action for production 641:
    ///
    /// `CastingType: Bool;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_10(&mut self, _bool: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bool = pop_item!(self, bool, Bool, context);
        let casting_type_10_built = CastingTypeBool {
            bool: Box::new(bool),
        };
        let casting_type_10_built = CastingType::Bool(casting_type_10_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_10_built)?;
        self.push(ASTType::CastingType(casting_type_10_built), context);
        Ok(())
    }

    /// Semantic action for production 642:
    ///
    /// `CastingType: Clock;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_11(&mut self, _clock: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let clock = pop_item!(self, clock, Clock, context);
        let casting_type_11_built = CastingTypeClock {
            clock: Box::new(clock),
        };
        let casting_type_11_built = CastingType::Clock(casting_type_11_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_11_built)?;
        self.push(ASTType::CastingType(casting_type_11_built), context);
        Ok(())
    }

    /// Semantic action for production 643:
    ///
    /// `CastingType: ClockPosedge;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_12(&mut self, _clock_posedge: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let clock_posedge = pop_item!(self, clock_posedge, ClockPosedge, context);
        let casting_type_12_built = CastingTypeClockPosedge {
            clock_posedge: Box::new(clock_posedge),
        };
        let casting_type_12_built = CastingType::ClockPosedge(casting_type_12_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_12_built)?;
        self.push(ASTType::CastingType(casting_type_12_built), context);
        Ok(())
    }

    /// Semantic action for production 644:
    ///
    /// `CastingType: ClockNegedge;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_13(&mut self, _clock_negedge: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let clock_negedge = pop_item!(self, clock_negedge, ClockNegedge, context);
        let casting_type_13_built = CastingTypeClockNegedge {
            clock_negedge: Box::new(clock_negedge),
        };
        let casting_type_13_built = CastingType::ClockNegedge(casting_type_13_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_13_built)?;
        self.push(ASTType::CastingType(casting_type_13_built), context);
        Ok(())
    }

    /// Semantic action for production 645:
    ///
    /// `CastingType: Reset;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_14(&mut self, _reset: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let reset = pop_item!(self, reset, Reset, context);
        let casting_type_14_built = CastingTypeReset {
            reset: Box::new(reset),
        };
        let casting_type_14_built = CastingType::Reset(casting_type_14_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_14_built)?;
        self.push(ASTType::CastingType(casting_type_14_built), context);
        Ok(())
    }

    /// Semantic action for production 646:
    ///
    /// `CastingType: ResetAsyncHigh;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_15(&mut self, _reset_async_high: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let reset_async_high = pop_item!(self, reset_async_high, ResetAsyncHigh, context);
        let casting_type_15_built = CastingTypeResetAsyncHigh {
            reset_async_high: Box::new(reset_async_high),
        };
        let casting_type_15_built = CastingType::ResetAsyncHigh(casting_type_15_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_15_built)?;
        self.push(ASTType::CastingType(casting_type_15_built), context);
        Ok(())
    }

    /// Semantic action for production 647:
    ///
    /// `CastingType: ResetAsyncLow;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_16(&mut self, _reset_async_low: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let reset_async_low = pop_item!(self, reset_async_low, ResetAsyncLow, context);
        let casting_type_16_built = CastingTypeResetAsyncLow {
            reset_async_low: Box::new(reset_async_low),
        };
        let casting_type_16_built = CastingType::ResetAsyncLow(casting_type_16_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_16_built)?;
        self.push(ASTType::CastingType(casting_type_16_built), context);
        Ok(())
    }

    /// Semantic action for production 648:
    ///
    /// `CastingType: ResetSyncHigh;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_17(&mut self, _reset_sync_high: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let reset_sync_high = pop_item!(self, reset_sync_high, ResetSyncHigh, context);
        let casting_type_17_built = CastingTypeResetSyncHigh {
            reset_sync_high: Box::new(reset_sync_high),
        };
        let casting_type_17_built = CastingType::ResetSyncHigh(casting_type_17_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_17_built)?;
        self.push(ASTType::CastingType(casting_type_17_built), context);
        Ok(())
    }

    /// Semantic action for production 649:
    ///
    /// `CastingType: ResetSyncLow;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_18(&mut self, _reset_sync_low: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let reset_sync_low = pop_item!(self, reset_sync_low, ResetSyncLow, context);
        let casting_type_18_built = CastingTypeResetSyncLow {
            reset_sync_low: Box::new(reset_sync_low),
        };
        let casting_type_18_built = CastingType::ResetSyncLow(casting_type_18_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_18_built)?;
        self.push(ASTType::CastingType(casting_type_18_built), context);
        Ok(())
    }

    /// Semantic action for production 650:
    ///
    /// `CastingType: UserDefinedType;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_19(&mut self, _user_defined_type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let user_defined_type = pop_item!(self, user_defined_type, UserDefinedType, context);
        let casting_type_19_built = CastingTypeUserDefinedType {
            user_defined_type: Box::new(user_defined_type),
        };
        let casting_type_19_built = CastingType::UserDefinedType(casting_type_19_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_19_built)?;
        self.push(ASTType::CastingType(casting_type_19_built), context);
        Ok(())
    }

    /// Semantic action for production 651:
    ///
    /// `CastingType: Based;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_20(&mut self, _based: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let based = pop_item!(self, based, Based, context);
        let casting_type_20_built = CastingTypeBased {
            based: Box::new(based),
        };
        let casting_type_20_built = CastingType::Based(casting_type_20_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_20_built)?;
        self.push(ASTType::CastingType(casting_type_20_built), context);
        Ok(())
    }

    /// Semantic action for production 652:
    ///
    /// `CastingType: BaseLess;`
    ///
    #[parol_runtime::function_name::named]
    fn casting_type_21(&mut self, _base_less: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let base_less = pop_item!(self, base_less, BaseLess, context);
        let casting_type_21_built = CastingTypeBaseLess {
            base_less: Box::new(base_less),
        };
        let casting_type_21_built = CastingType::BaseLess(casting_type_21_built);
        // Calling user action here
        self.user_grammar.casting_type(&casting_type_21_built)?;
        self.push(ASTType::CastingType(casting_type_21_built), context);
        Ok(())
    }

    /// Semantic action for production 653:
    ///
    /// `ClockDomain: Quote Identifier;`
    ///
    #[parol_runtime::function_name::named]
    fn clock_domain(
        &mut self,
        _quote: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let quote = pop_item!(self, quote, Quote, context);
        let clock_domain_built = ClockDomain {
            quote: Box::new(quote),
            identifier: Box::new(identifier),
        };
        // Calling user action here
        self.user_grammar.clock_domain(&clock_domain_built)?;
        self.push(ASTType::ClockDomain(clock_domain_built), context);
        Ok(())
    }

    /// Semantic action for production 654:
    ///
    /// `StatementBlock: LBrace StatementBlockList /* Vec */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_block(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _statement_block_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let statement_block_list =
            pop_and_reverse_item!(self, statement_block_list, StatementBlockList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let statement_block_built = StatementBlock {
            l_brace: Box::new(l_brace),
            statement_block_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar.statement_block(&statement_block_built)?;
        self.push(ASTType::StatementBlock(statement_block_built), context);
        Ok(())
    }

    /// Semantic action for production 655:
    ///
    /// `StatementBlockList /* Vec<T>::Push */: StatementBlockGroup StatementBlockList;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_block_list_0(
        &mut self,
        _statement_block_group: &ParseTreeType<'t>,
        _statement_block_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut statement_block_list =
            pop_item!(self, statement_block_list, StatementBlockList, context);
        let statement_block_group =
            pop_item!(self, statement_block_group, StatementBlockGroup, context);
        let statement_block_list_0_built = StatementBlockList {
            statement_block_group: Box::new(statement_block_group),
        };
        // Add an element to the vector
        statement_block_list.push(statement_block_list_0_built);
        self.push(ASTType::StatementBlockList(statement_block_list), context);
        Ok(())
    }

    /// Semantic action for production 656:
    ///
    /// `StatementBlockList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_block_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block_list_1_built = Vec::new();
        self.push(
            ASTType::StatementBlockList(statement_block_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 657:
    ///
    /// `StatementBlockGroup: StatementBlockGroupList /* Vec */ StatementBlockGroupGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_block_group(
        &mut self,
        _statement_block_group_list: &ParseTreeType<'t>,
        _statement_block_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block_group_group = pop_item!(
            self,
            statement_block_group_group,
            StatementBlockGroupGroup,
            context
        );
        let statement_block_group_list = pop_and_reverse_item!(
            self,
            statement_block_group_list,
            StatementBlockGroupList,
            context
        );
        let statement_block_group_built = StatementBlockGroup {
            statement_block_group_list,
            statement_block_group_group: Box::new(statement_block_group_group),
        };
        // Calling user action here
        self.user_grammar
            .statement_block_group(&statement_block_group_built)?;
        self.push(
            ASTType::StatementBlockGroup(statement_block_group_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 658:
    ///
    /// `StatementBlockGroupGroup: LBrace StatementBlockGroupGroupList /* Vec */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_block_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _statement_block_group_group_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let statement_block_group_group_list = pop_and_reverse_item!(
            self,
            statement_block_group_group_list,
            StatementBlockGroupGroupList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let statement_block_group_group_0_built =
            StatementBlockGroupGroupLBraceStatementBlockGroupGroupListRBrace {
                l_brace: Box::new(l_brace),
                statement_block_group_group_list,
                r_brace: Box::new(r_brace),
            };
        let statement_block_group_group_0_built =
            StatementBlockGroupGroup::LBraceStatementBlockGroupGroupListRBrace(
                statement_block_group_group_0_built,
            );
        self.push(
            ASTType::StatementBlockGroupGroup(statement_block_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 659:
    ///
    /// `StatementBlockGroupGroupList /* Vec<T>::Push */: StatementBlockGroup StatementBlockGroupGroupList;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_block_group_group_list_0(
        &mut self,
        _statement_block_group: &ParseTreeType<'t>,
        _statement_block_group_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut statement_block_group_group_list = pop_item!(
            self,
            statement_block_group_group_list,
            StatementBlockGroupGroupList,
            context
        );
        let statement_block_group =
            pop_item!(self, statement_block_group, StatementBlockGroup, context);
        let statement_block_group_group_list_0_built = StatementBlockGroupGroupList {
            statement_block_group: Box::new(statement_block_group),
        };
        // Add an element to the vector
        statement_block_group_group_list.push(statement_block_group_group_list_0_built);
        self.push(
            ASTType::StatementBlockGroupGroupList(statement_block_group_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 660:
    ///
    /// `StatementBlockGroupGroupList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_block_group_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block_group_group_list_1_built = Vec::new();
        self.push(
            ASTType::StatementBlockGroupGroupList(statement_block_group_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 661:
    ///
    /// `StatementBlockGroupGroup: StatementBlockItem;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_block_group_group_1(
        &mut self,
        _statement_block_item: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block_item =
            pop_item!(self, statement_block_item, StatementBlockItem, context);
        let statement_block_group_group_1_built = StatementBlockGroupGroupStatementBlockItem {
            statement_block_item: Box::new(statement_block_item),
        };
        let statement_block_group_group_1_built =
            StatementBlockGroupGroup::StatementBlockItem(statement_block_group_group_1_built);
        self.push(
            ASTType::StatementBlockGroupGroup(statement_block_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 662:
    ///
    /// `StatementBlockGroupList /* Vec<T>::Push */: Attribute StatementBlockGroupList;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_block_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _statement_block_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut statement_block_group_list = pop_item!(
            self,
            statement_block_group_list,
            StatementBlockGroupList,
            context
        );
        let attribute = pop_item!(self, attribute, Attribute, context);
        let statement_block_group_list_0_built = StatementBlockGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        statement_block_group_list.push(statement_block_group_list_0_built);
        self.push(
            ASTType::StatementBlockGroupList(statement_block_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 663:
    ///
    /// `StatementBlockGroupList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_block_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block_group_list_1_built = Vec::new();
        self.push(
            ASTType::StatementBlockGroupList(statement_block_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 664:
    ///
    /// `StatementBlockItem: VarDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_block_item_0(&mut self, _var_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_declaration = pop_item!(self, var_declaration, VarDeclaration, context);
        let statement_block_item_0_built = StatementBlockItemVarDeclaration {
            var_declaration: Box::new(var_declaration),
        };
        let statement_block_item_0_built =
            StatementBlockItem::VarDeclaration(statement_block_item_0_built);
        // Calling user action here
        self.user_grammar
            .statement_block_item(&statement_block_item_0_built)?;
        self.push(
            ASTType::StatementBlockItem(statement_block_item_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 665:
    ///
    /// `StatementBlockItem: LetStatement;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_block_item_1(&mut self, _let_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let let_statement = pop_item!(self, let_statement, LetStatement, context);
        let statement_block_item_1_built = StatementBlockItemLetStatement {
            let_statement: Box::new(let_statement),
        };
        let statement_block_item_1_built =
            StatementBlockItem::LetStatement(statement_block_item_1_built);
        // Calling user action here
        self.user_grammar
            .statement_block_item(&statement_block_item_1_built)?;
        self.push(
            ASTType::StatementBlockItem(statement_block_item_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 666:
    ///
    /// `StatementBlockItem: ConstDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_block_item_2(&mut self, _const_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_declaration = pop_item!(self, const_declaration, ConstDeclaration, context);
        let statement_block_item_2_built = StatementBlockItemConstDeclaration {
            const_declaration: Box::new(const_declaration),
        };
        let statement_block_item_2_built =
            StatementBlockItem::ConstDeclaration(statement_block_item_2_built);
        // Calling user action here
        self.user_grammar
            .statement_block_item(&statement_block_item_2_built)?;
        self.push(
            ASTType::StatementBlockItem(statement_block_item_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 667:
    ///
    /// `StatementBlockItem: Statement;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_block_item_3(&mut self, _statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement = pop_item!(self, statement, Statement, context);
        let statement_block_item_3_built = StatementBlockItemStatement {
            statement: Box::new(statement),
        };
        let statement_block_item_3_built =
            StatementBlockItem::Statement(statement_block_item_3_built);
        // Calling user action here
        self.user_grammar
            .statement_block_item(&statement_block_item_3_built)?;
        self.push(
            ASTType::StatementBlockItem(statement_block_item_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 668:
    ///
    /// `Statement: IdentifierStatement;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_0(&mut self, _identifier_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier_statement =
            pop_item!(self, identifier_statement, IdentifierStatement, context);
        let statement_0_built = StatementIdentifierStatement {
            identifier_statement: Box::new(identifier_statement),
        };
        let statement_0_built = Statement::IdentifierStatement(statement_0_built);
        // Calling user action here
        self.user_grammar.statement(&statement_0_built)?;
        self.push(ASTType::Statement(statement_0_built), context);
        Ok(())
    }

    /// Semantic action for production 669:
    ///
    /// `Statement: IfStatement;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_1(&mut self, _if_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement = pop_item!(self, if_statement, IfStatement, context);
        let statement_1_built = StatementIfStatement {
            if_statement: Box::new(if_statement),
        };
        let statement_1_built = Statement::IfStatement(statement_1_built);
        // Calling user action here
        self.user_grammar.statement(&statement_1_built)?;
        self.push(ASTType::Statement(statement_1_built), context);
        Ok(())
    }

    /// Semantic action for production 670:
    ///
    /// `Statement: IfResetStatement;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_2(&mut self, _if_reset_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_statement = pop_item!(self, if_reset_statement, IfResetStatement, context);
        let statement_2_built = StatementIfResetStatement {
            if_reset_statement: Box::new(if_reset_statement),
        };
        let statement_2_built = Statement::IfResetStatement(statement_2_built);
        // Calling user action here
        self.user_grammar.statement(&statement_2_built)?;
        self.push(ASTType::Statement(statement_2_built), context);
        Ok(())
    }

    /// Semantic action for production 671:
    ///
    /// `Statement: ReturnStatement;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_3(&mut self, _return_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let return_statement = pop_item!(self, return_statement, ReturnStatement, context);
        let statement_3_built = StatementReturnStatement {
            return_statement: Box::new(return_statement),
        };
        let statement_3_built = Statement::ReturnStatement(statement_3_built);
        // Calling user action here
        self.user_grammar.statement(&statement_3_built)?;
        self.push(ASTType::Statement(statement_3_built), context);
        Ok(())
    }

    /// Semantic action for production 672:
    ///
    /// `Statement: BreakStatement;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_4(&mut self, _break_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let break_statement = pop_item!(self, break_statement, BreakStatement, context);
        let statement_4_built = StatementBreakStatement {
            break_statement: Box::new(break_statement),
        };
        let statement_4_built = Statement::BreakStatement(statement_4_built);
        // Calling user action here
        self.user_grammar.statement(&statement_4_built)?;
        self.push(ASTType::Statement(statement_4_built), context);
        Ok(())
    }

    /// Semantic action for production 673:
    ///
    /// `Statement: ForStatement;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_5(&mut self, _for_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let for_statement = pop_item!(self, for_statement, ForStatement, context);
        let statement_5_built = StatementForStatement {
            for_statement: Box::new(for_statement),
        };
        let statement_5_built = Statement::ForStatement(statement_5_built);
        // Calling user action here
        self.user_grammar.statement(&statement_5_built)?;
        self.push(ASTType::Statement(statement_5_built), context);
        Ok(())
    }

    /// Semantic action for production 674:
    ///
    /// `Statement: CaseStatement;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_6(&mut self, _case_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_statement = pop_item!(self, case_statement, CaseStatement, context);
        let statement_6_built = StatementCaseStatement {
            case_statement: Box::new(case_statement),
        };
        let statement_6_built = Statement::CaseStatement(statement_6_built);
        // Calling user action here
        self.user_grammar.statement(&statement_6_built)?;
        self.push(ASTType::Statement(statement_6_built), context);
        Ok(())
    }

    /// Semantic action for production 675:
    ///
    /// `Statement: SwitchStatement;`
    ///
    #[parol_runtime::function_name::named]
    fn statement_7(&mut self, _switch_statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let switch_statement = pop_item!(self, switch_statement, SwitchStatement, context);
        let statement_7_built = StatementSwitchStatement {
            switch_statement: Box::new(switch_statement),
        };
        let statement_7_built = Statement::SwitchStatement(statement_7_built);
        // Calling user action here
        self.user_grammar.statement(&statement_7_built)?;
        self.push(ASTType::Statement(statement_7_built), context);
        Ok(())
    }

    /// Semantic action for production 676:
    ///
    /// `LetStatement: Let Identifier Colon LetStatementOpt /* Option */ ArrayType Equ Expression Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn let_statement(
        &mut self,
        _let: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _let_statement_opt: &ParseTreeType<'t>,
        _array_type: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let array_type = pop_item!(self, array_type, ArrayType, context);
        let let_statement_opt = pop_item!(self, let_statement_opt, LetStatementOpt, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let r#let = pop_item!(self, r#let, Let, context);
        let let_statement_built = LetStatement {
            r#let: Box::new(r#let),
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            let_statement_opt,
            array_type: Box::new(array_type),
            equ: Box::new(equ),
            expression: Box::new(expression),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar.let_statement(&let_statement_built)?;
        self.push(ASTType::LetStatement(let_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 677:
    ///
    /// `LetStatementOpt /* Option<T>::Some */: ClockDomain;`
    ///
    #[parol_runtime::function_name::named]
    fn let_statement_opt_0(&mut self, _clock_domain: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let clock_domain = pop_item!(self, clock_domain, ClockDomain, context);
        let let_statement_opt_0_built = LetStatementOpt {
            clock_domain: Box::new(clock_domain),
        };
        self.push(
            ASTType::LetStatementOpt(Some(let_statement_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 678:
    ///
    /// `LetStatementOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn let_statement_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::LetStatementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 679:
    ///
    /// `IdentifierStatement: ExpressionIdentifier IdentifierStatementGroup Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn identifier_statement(
        &mut self,
        _expression_identifier: &ParseTreeType<'t>,
        _identifier_statement_group: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let identifier_statement_group = pop_item!(
            self,
            identifier_statement_group,
            IdentifierStatementGroup,
            context
        );
        let expression_identifier =
            pop_item!(self, expression_identifier, ExpressionIdentifier, context);
        let identifier_statement_built = IdentifierStatement {
            expression_identifier: Box::new(expression_identifier),
            identifier_statement_group: Box::new(identifier_statement_group),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .identifier_statement(&identifier_statement_built)?;
        self.push(
            ASTType::IdentifierStatement(identifier_statement_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 680:
    ///
    /// `IdentifierStatementGroup: FunctionCall;`
    ///
    #[parol_runtime::function_name::named]
    fn identifier_statement_group_0(&mut self, _function_call: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_call = pop_item!(self, function_call, FunctionCall, context);
        let identifier_statement_group_0_built = IdentifierStatementGroupFunctionCall {
            function_call: Box::new(function_call),
        };
        let identifier_statement_group_0_built =
            IdentifierStatementGroup::FunctionCall(identifier_statement_group_0_built);
        self.push(
            ASTType::IdentifierStatementGroup(identifier_statement_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 681:
    ///
    /// `IdentifierStatementGroup: Assignment;`
    ///
    #[parol_runtime::function_name::named]
    fn identifier_statement_group_1(&mut self, _assignment: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment = pop_item!(self, assignment, Assignment, context);
        let identifier_statement_group_1_built = IdentifierStatementGroupAssignment {
            assignment: Box::new(assignment),
        };
        let identifier_statement_group_1_built =
            IdentifierStatementGroup::Assignment(identifier_statement_group_1_built);
        self.push(
            ASTType::IdentifierStatementGroup(identifier_statement_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 682:
    ///
    /// `Assignment: AssignmentGroup Expression;`
    ///
    #[parol_runtime::function_name::named]
    fn assignment(
        &mut self,
        _assignment_group: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let assignment_group = pop_item!(self, assignment_group, AssignmentGroup, context);
        let assignment_built = Assignment {
            assignment_group: Box::new(assignment_group),
            expression: Box::new(expression),
        };
        // Calling user action here
        self.user_grammar.assignment(&assignment_built)?;
        self.push(ASTType::Assignment(assignment_built), context);
        Ok(())
    }

    /// Semantic action for production 683:
    ///
    /// `AssignmentGroup: Equ;`
    ///
    #[parol_runtime::function_name::named]
    fn assignment_group_0(&mut self, _equ: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let equ = pop_item!(self, equ, Equ, context);
        let assignment_group_0_built = AssignmentGroupEqu { equ: Box::new(equ) };
        let assignment_group_0_built = AssignmentGroup::Equ(assignment_group_0_built);
        self.push(ASTType::AssignmentGroup(assignment_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 684:
    ///
    /// `AssignmentGroup: AssignmentOperator;`
    ///
    #[parol_runtime::function_name::named]
    fn assignment_group_1(&mut self, _assignment_operator: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assignment_operator = pop_item!(self, assignment_operator, AssignmentOperator, context);
        let assignment_group_1_built = AssignmentGroupAssignmentOperator {
            assignment_operator: Box::new(assignment_operator),
        };
        let assignment_group_1_built =
            AssignmentGroup::AssignmentOperator(assignment_group_1_built);
        self.push(ASTType::AssignmentGroup(assignment_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 685:
    ///
    /// `AssignmentGroup: DiamondOperator;`
    ///
    #[parol_runtime::function_name::named]
    fn assignment_group_2(&mut self, _diamond_operator: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let diamond_operator = pop_item!(self, diamond_operator, DiamondOperator, context);
        let assignment_group_2_built = AssignmentGroupDiamondOperator {
            diamond_operator: Box::new(diamond_operator),
        };
        let assignment_group_2_built = AssignmentGroup::DiamondOperator(assignment_group_2_built);
        self.push(ASTType::AssignmentGroup(assignment_group_2_built), context);
        Ok(())
    }

    /// Semantic action for production 686:
    ///
    /// `IfStatement: If Expression StatementBlock IfStatementList /* Vec */ IfStatementOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn if_statement(
        &mut self,
        _if: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _statement_block: &ParseTreeType<'t>,
        _if_statement_list: &ParseTreeType<'t>,
        _if_statement_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_opt = pop_item!(self, if_statement_opt, IfStatementOpt, context);
        let if_statement_list =
            pop_and_reverse_item!(self, if_statement_list, IfStatementList, context);
        let statement_block = pop_item!(self, statement_block, StatementBlock, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let if_statement_built = IfStatement {
            r#if: Box::new(r#if),
            expression: Box::new(expression),
            statement_block: Box::new(statement_block),
            if_statement_list,
            if_statement_opt,
        };
        // Calling user action here
        self.user_grammar.if_statement(&if_statement_built)?;
        self.push(ASTType::IfStatement(if_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 687:
    ///
    /// `IfStatementList /* Vec<T>::Push */: Else If Expression StatementBlock IfStatementList;`
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list_0(
        &mut self,
        _else: &ParseTreeType<'t>,
        _if: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _statement_block: &ParseTreeType<'t>,
        _if_statement_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_statement_list = pop_item!(self, if_statement_list, IfStatementList, context);
        let statement_block = pop_item!(self, statement_block, StatementBlock, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let if_statement_list_0_built = IfStatementList {
            statement_block: Box::new(statement_block),
            expression: Box::new(expression),
            r#if: Box::new(r#if),
            r#else: Box::new(r#else),
        };
        // Add an element to the vector
        if_statement_list.push(if_statement_list_0_built);
        self.push(ASTType::IfStatementList(if_statement_list), context);
        Ok(())
    }

    /// Semantic action for production 688:
    ///
    /// `IfStatementList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_statement_list_1_built = Vec::new();
        self.push(ASTType::IfStatementList(if_statement_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 689:
    ///
    /// `IfStatementOpt /* Option<T>::Some */: Else StatementBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_opt_0(
        &mut self,
        _else: &ParseTreeType<'t>,
        _statement_block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block = pop_item!(self, statement_block, StatementBlock, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let if_statement_opt_0_built = IfStatementOpt {
            r#else: Box::new(r#else),
            statement_block: Box::new(statement_block),
        };
        self.push(
            ASTType::IfStatementOpt(Some(if_statement_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 690:
    ///
    /// `IfStatementOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn if_statement_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::IfStatementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 691:
    ///
    /// `IfResetStatement: IfReset StatementBlock IfResetStatementList /* Vec */ IfResetStatementOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement(
        &mut self,
        _if_reset: &ParseTreeType<'t>,
        _statement_block: &ParseTreeType<'t>,
        _if_reset_statement_list: &ParseTreeType<'t>,
        _if_reset_statement_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_statement_opt =
            pop_item!(self, if_reset_statement_opt, IfResetStatementOpt, context);
        let if_reset_statement_list =
            pop_and_reverse_item!(self, if_reset_statement_list, IfResetStatementList, context);
        let statement_block = pop_item!(self, statement_block, StatementBlock, context);
        let if_reset = pop_item!(self, if_reset, IfReset, context);
        let if_reset_statement_built = IfResetStatement {
            if_reset: Box::new(if_reset),
            statement_block: Box::new(statement_block),
            if_reset_statement_list,
            if_reset_statement_opt,
        };
        // Calling user action here
        self.user_grammar
            .if_reset_statement(&if_reset_statement_built)?;
        self.push(ASTType::IfResetStatement(if_reset_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 692:
    ///
    /// `IfResetStatementList /* Vec<T>::Push */: Else If Expression StatementBlock IfResetStatementList;`
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_list_0(
        &mut self,
        _else: &ParseTreeType<'t>,
        _if: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _statement_block: &ParseTreeType<'t>,
        _if_reset_statement_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut if_reset_statement_list =
            pop_item!(self, if_reset_statement_list, IfResetStatementList, context);
        let statement_block = pop_item!(self, statement_block, StatementBlock, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let if_reset_statement_list_0_built = IfResetStatementList {
            statement_block: Box::new(statement_block),
            expression: Box::new(expression),
            r#if: Box::new(r#if),
            r#else: Box::new(r#else),
        };
        // Add an element to the vector
        if_reset_statement_list.push(if_reset_statement_list_0_built);
        self.push(
            ASTType::IfResetStatementList(if_reset_statement_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 693:
    ///
    /// `IfResetStatementList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let if_reset_statement_list_1_built = Vec::new();
        self.push(
            ASTType::IfResetStatementList(if_reset_statement_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 694:
    ///
    /// `IfResetStatementOpt /* Option<T>::Some */: Else StatementBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_opt_0(
        &mut self,
        _else: &ParseTreeType<'t>,
        _statement_block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block = pop_item!(self, statement_block, StatementBlock, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let if_reset_statement_opt_0_built = IfResetStatementOpt {
            r#else: Box::new(r#else),
            statement_block: Box::new(statement_block),
        };
        self.push(
            ASTType::IfResetStatementOpt(Some(if_reset_statement_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 695:
    ///
    /// `IfResetStatementOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn if_reset_statement_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::IfResetStatementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 696:
    ///
    /// `ReturnStatement: Return Expression Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn return_statement(
        &mut self,
        _return: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#return = pop_item!(self, r#return, Return, context);
        let return_statement_built = ReturnStatement {
            r#return: Box::new(r#return),
            expression: Box::new(expression),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .return_statement(&return_statement_built)?;
        self.push(ASTType::ReturnStatement(return_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 697:
    ///
    /// `BreakStatement: Break Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn break_statement(
        &mut self,
        _break: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let r#break = pop_item!(self, r#break, Break, context);
        let break_statement_built = BreakStatement {
            r#break: Box::new(r#break),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar.break_statement(&break_statement_built)?;
        self.push(ASTType::BreakStatement(break_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 698:
    ///
    /// `ForStatement: For Identifier Colon ScalarType In ForStatementOpt /* Option */ Range ForStatementOpt0 /* Option */ StatementBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn for_statement(
        &mut self,
        _for: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _scalar_type: &ParseTreeType<'t>,
        _in: &ParseTreeType<'t>,
        _for_statement_opt: &ParseTreeType<'t>,
        _range: &ParseTreeType<'t>,
        _for_statement_opt0: &ParseTreeType<'t>,
        _statement_block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block = pop_item!(self, statement_block, StatementBlock, context);
        let for_statement_opt0 = pop_item!(self, for_statement_opt0, ForStatementOpt0, context);
        let range = pop_item!(self, range, Range, context);
        let for_statement_opt = pop_item!(self, for_statement_opt, ForStatementOpt, context);
        let r#in = pop_item!(self, r#in, In, context);
        let scalar_type = pop_item!(self, scalar_type, ScalarType, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let r#for = pop_item!(self, r#for, For, context);
        let for_statement_built = ForStatement {
            r#for: Box::new(r#for),
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            scalar_type: Box::new(scalar_type),
            r#in: Box::new(r#in),
            for_statement_opt,
            range: Box::new(range),
            for_statement_opt0,
            statement_block: Box::new(statement_block),
        };
        // Calling user action here
        self.user_grammar.for_statement(&for_statement_built)?;
        self.push(ASTType::ForStatement(for_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 699:
    ///
    /// `ForStatementOpt0 /* Option<T>::Some */: Step AssignmentOperator Expression;`
    ///
    #[parol_runtime::function_name::named]
    fn for_statement_opt0_0(
        &mut self,
        _step: &ParseTreeType<'t>,
        _assignment_operator: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let assignment_operator = pop_item!(self, assignment_operator, AssignmentOperator, context);
        let step = pop_item!(self, step, Step, context);
        let for_statement_opt0_0_built = ForStatementOpt0 {
            step: Box::new(step),
            assignment_operator: Box::new(assignment_operator),
            expression: Box::new(expression),
        };
        self.push(
            ASTType::ForStatementOpt0(Some(for_statement_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 700:
    ///
    /// `ForStatementOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn for_statement_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ForStatementOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 701:
    ///
    /// `ForStatementOpt /* Option<T>::Some */: Rev;`
    ///
    #[parol_runtime::function_name::named]
    fn for_statement_opt_0(&mut self, _rev: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let rev = pop_item!(self, rev, Rev, context);
        let for_statement_opt_0_built = ForStatementOpt { rev: Box::new(rev) };
        self.push(
            ASTType::ForStatementOpt(Some(for_statement_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 702:
    ///
    /// `ForStatementOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn for_statement_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ForStatementOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 703:
    ///
    /// `CaseStatement: Case Expression LBrace CaseStatementList /* Vec */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn case_statement(
        &mut self,
        _case: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _case_statement_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let case_statement_list =
            pop_and_reverse_item!(self, case_statement_list, CaseStatementList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let expression = pop_item!(self, expression, Expression, context);
        let case = pop_item!(self, case, Case, context);
        let case_statement_built = CaseStatement {
            case: Box::new(case),
            expression: Box::new(expression),
            l_brace: Box::new(l_brace),
            case_statement_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar.case_statement(&case_statement_built)?;
        self.push(ASTType::CaseStatement(case_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 704:
    ///
    /// `CaseStatementList /* Vec<T>::Push */: CaseItem CaseStatementList;`
    ///
    #[parol_runtime::function_name::named]
    fn case_statement_list_0(
        &mut self,
        _case_item: &ParseTreeType<'t>,
        _case_statement_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut case_statement_list =
            pop_item!(self, case_statement_list, CaseStatementList, context);
        let case_item = pop_item!(self, case_item, CaseItem, context);
        let case_statement_list_0_built = CaseStatementList {
            case_item: Box::new(case_item),
        };
        // Add an element to the vector
        case_statement_list.push(case_statement_list_0_built);
        self.push(ASTType::CaseStatementList(case_statement_list), context);
        Ok(())
    }

    /// Semantic action for production 705:
    ///
    /// `CaseStatementList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn case_statement_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_statement_list_1_built = Vec::new();
        self.push(
            ASTType::CaseStatementList(case_statement_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 706:
    ///
    /// `CaseItem: CaseItemGroup Colon CaseItemGroup0;`
    ///
    #[parol_runtime::function_name::named]
    fn case_item(
        &mut self,
        _case_item_group: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _case_item_group0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_item_group0 = pop_item!(self, case_item_group0, CaseItemGroup0, context);
        let colon = pop_item!(self, colon, Colon, context);
        let case_item_group = pop_item!(self, case_item_group, CaseItemGroup, context);
        let case_item_built = CaseItem {
            case_item_group: Box::new(case_item_group),
            colon: Box::new(colon),
            case_item_group0: Box::new(case_item_group0),
        };
        // Calling user action here
        self.user_grammar.case_item(&case_item_built)?;
        self.push(ASTType::CaseItem(case_item_built), context);
        Ok(())
    }

    /// Semantic action for production 707:
    ///
    /// `CaseItemGroup0: Statement;`
    ///
    #[parol_runtime::function_name::named]
    fn case_item_group0_0(&mut self, _statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement = pop_item!(self, statement, Statement, context);
        let case_item_group0_0_built = CaseItemGroup0Statement {
            statement: Box::new(statement),
        };
        let case_item_group0_0_built = CaseItemGroup0::Statement(case_item_group0_0_built);
        self.push(ASTType::CaseItemGroup0(case_item_group0_0_built), context);
        Ok(())
    }

    /// Semantic action for production 708:
    ///
    /// `CaseItemGroup0: StatementBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn case_item_group0_1(&mut self, _statement_block: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block = pop_item!(self, statement_block, StatementBlock, context);
        let case_item_group0_1_built = CaseItemGroup0StatementBlock {
            statement_block: Box::new(statement_block),
        };
        let case_item_group0_1_built = CaseItemGroup0::StatementBlock(case_item_group0_1_built);
        self.push(ASTType::CaseItemGroup0(case_item_group0_1_built), context);
        Ok(())
    }

    /// Semantic action for production 709:
    ///
    /// `CaseItemGroup: CaseCondition;`
    ///
    #[parol_runtime::function_name::named]
    fn case_item_group_0(&mut self, _case_condition: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_condition = pop_item!(self, case_condition, CaseCondition, context);
        let case_item_group_0_built = CaseItemGroupCaseCondition {
            case_condition: Box::new(case_condition),
        };
        let case_item_group_0_built = CaseItemGroup::CaseCondition(case_item_group_0_built);
        self.push(ASTType::CaseItemGroup(case_item_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 710:
    ///
    /// `CaseItemGroup: Defaul;`
    ///
    #[parol_runtime::function_name::named]
    fn case_item_group_1(&mut self, _defaul: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let defaul = pop_item!(self, defaul, Defaul, context);
        let case_item_group_1_built = CaseItemGroupDefaul {
            defaul: Box::new(defaul),
        };
        let case_item_group_1_built = CaseItemGroup::Defaul(case_item_group_1_built);
        self.push(ASTType::CaseItemGroup(case_item_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 711:
    ///
    /// `CaseCondition: RangeItem CaseConditionList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn case_condition(
        &mut self,
        _range_item: &ParseTreeType<'t>,
        _case_condition_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_condition_list =
            pop_and_reverse_item!(self, case_condition_list, CaseConditionList, context);
        let range_item = pop_item!(self, range_item, RangeItem, context);
        let case_condition_built = CaseCondition {
            range_item: Box::new(range_item),
            case_condition_list,
        };
        // Calling user action here
        self.user_grammar.case_condition(&case_condition_built)?;
        self.push(ASTType::CaseCondition(case_condition_built), context);
        Ok(())
    }

    /// Semantic action for production 712:
    ///
    /// `CaseConditionList /* Vec<T>::Push */: Comma RangeItem CaseConditionList;`
    ///
    #[parol_runtime::function_name::named]
    fn case_condition_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _range_item: &ParseTreeType<'t>,
        _case_condition_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut case_condition_list =
            pop_item!(self, case_condition_list, CaseConditionList, context);
        let range_item = pop_item!(self, range_item, RangeItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let case_condition_list_0_built = CaseConditionList {
            range_item: Box::new(range_item),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        case_condition_list.push(case_condition_list_0_built);
        self.push(ASTType::CaseConditionList(case_condition_list), context);
        Ok(())
    }

    /// Semantic action for production 713:
    ///
    /// `CaseConditionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn case_condition_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let case_condition_list_1_built = Vec::new();
        self.push(
            ASTType::CaseConditionList(case_condition_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 714:
    ///
    /// `SwitchStatement: Switch LBrace SwitchStatementList /* Vec */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn switch_statement(
        &mut self,
        _switch: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _switch_statement_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let switch_statement_list =
            pop_and_reverse_item!(self, switch_statement_list, SwitchStatementList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let switch = pop_item!(self, switch, Switch, context);
        let switch_statement_built = SwitchStatement {
            switch: Box::new(switch),
            l_brace: Box::new(l_brace),
            switch_statement_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .switch_statement(&switch_statement_built)?;
        self.push(ASTType::SwitchStatement(switch_statement_built), context);
        Ok(())
    }

    /// Semantic action for production 715:
    ///
    /// `SwitchStatementList /* Vec<T>::Push */: SwitchItem SwitchStatementList;`
    ///
    #[parol_runtime::function_name::named]
    fn switch_statement_list_0(
        &mut self,
        _switch_item: &ParseTreeType<'t>,
        _switch_statement_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut switch_statement_list =
            pop_item!(self, switch_statement_list, SwitchStatementList, context);
        let switch_item = pop_item!(self, switch_item, SwitchItem, context);
        let switch_statement_list_0_built = SwitchStatementList {
            switch_item: Box::new(switch_item),
        };
        // Add an element to the vector
        switch_statement_list.push(switch_statement_list_0_built);
        self.push(ASTType::SwitchStatementList(switch_statement_list), context);
        Ok(())
    }

    /// Semantic action for production 716:
    ///
    /// `SwitchStatementList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn switch_statement_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let switch_statement_list_1_built = Vec::new();
        self.push(
            ASTType::SwitchStatementList(switch_statement_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 717:
    ///
    /// `SwitchItem: SwitchItemGroup Colon SwitchItemGroup0;`
    ///
    #[parol_runtime::function_name::named]
    fn switch_item(
        &mut self,
        _switch_item_group: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _switch_item_group0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let switch_item_group0 = pop_item!(self, switch_item_group0, SwitchItemGroup0, context);
        let colon = pop_item!(self, colon, Colon, context);
        let switch_item_group = pop_item!(self, switch_item_group, SwitchItemGroup, context);
        let switch_item_built = SwitchItem {
            switch_item_group: Box::new(switch_item_group),
            colon: Box::new(colon),
            switch_item_group0: Box::new(switch_item_group0),
        };
        // Calling user action here
        self.user_grammar.switch_item(&switch_item_built)?;
        self.push(ASTType::SwitchItem(switch_item_built), context);
        Ok(())
    }

    /// Semantic action for production 718:
    ///
    /// `SwitchItemGroup0: Statement;`
    ///
    #[parol_runtime::function_name::named]
    fn switch_item_group0_0(&mut self, _statement: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement = pop_item!(self, statement, Statement, context);
        let switch_item_group0_0_built = SwitchItemGroup0Statement {
            statement: Box::new(statement),
        };
        let switch_item_group0_0_built = SwitchItemGroup0::Statement(switch_item_group0_0_built);
        self.push(
            ASTType::SwitchItemGroup0(switch_item_group0_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 719:
    ///
    /// `SwitchItemGroup0: StatementBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn switch_item_group0_1(&mut self, _statement_block: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block = pop_item!(self, statement_block, StatementBlock, context);
        let switch_item_group0_1_built = SwitchItemGroup0StatementBlock {
            statement_block: Box::new(statement_block),
        };
        let switch_item_group0_1_built =
            SwitchItemGroup0::StatementBlock(switch_item_group0_1_built);
        self.push(
            ASTType::SwitchItemGroup0(switch_item_group0_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 720:
    ///
    /// `SwitchItemGroup: SwitchCondition;`
    ///
    #[parol_runtime::function_name::named]
    fn switch_item_group_0(&mut self, _switch_condition: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let switch_condition = pop_item!(self, switch_condition, SwitchCondition, context);
        let switch_item_group_0_built = SwitchItemGroupSwitchCondition {
            switch_condition: Box::new(switch_condition),
        };
        let switch_item_group_0_built = SwitchItemGroup::SwitchCondition(switch_item_group_0_built);
        self.push(ASTType::SwitchItemGroup(switch_item_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 721:
    ///
    /// `SwitchItemGroup: Defaul;`
    ///
    #[parol_runtime::function_name::named]
    fn switch_item_group_1(&mut self, _defaul: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let defaul = pop_item!(self, defaul, Defaul, context);
        let switch_item_group_1_built = SwitchItemGroupDefaul {
            defaul: Box::new(defaul),
        };
        let switch_item_group_1_built = SwitchItemGroup::Defaul(switch_item_group_1_built);
        self.push(ASTType::SwitchItemGroup(switch_item_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 722:
    ///
    /// `SwitchCondition: Expression SwitchConditionList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn switch_condition(
        &mut self,
        _expression: &ParseTreeType<'t>,
        _switch_condition_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let switch_condition_list =
            pop_and_reverse_item!(self, switch_condition_list, SwitchConditionList, context);
        let expression = pop_item!(self, expression, Expression, context);
        let switch_condition_built = SwitchCondition {
            expression: Box::new(expression),
            switch_condition_list,
        };
        // Calling user action here
        self.user_grammar
            .switch_condition(&switch_condition_built)?;
        self.push(ASTType::SwitchCondition(switch_condition_built), context);
        Ok(())
    }

    /// Semantic action for production 723:
    ///
    /// `SwitchConditionList /* Vec<T>::Push */: Comma Expression SwitchConditionList;`
    ///
    #[parol_runtime::function_name::named]
    fn switch_condition_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _switch_condition_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut switch_condition_list =
            pop_item!(self, switch_condition_list, SwitchConditionList, context);
        let expression = pop_item!(self, expression, Expression, context);
        let comma = pop_item!(self, comma, Comma, context);
        let switch_condition_list_0_built = SwitchConditionList {
            expression: Box::new(expression),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        switch_condition_list.push(switch_condition_list_0_built);
        self.push(ASTType::SwitchConditionList(switch_condition_list), context);
        Ok(())
    }

    /// Semantic action for production 724:
    ///
    /// `SwitchConditionList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn switch_condition_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let switch_condition_list_1_built = Vec::new();
        self.push(
            ASTType::SwitchConditionList(switch_condition_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 725:
    ///
    /// `Attribute: HashLBracket Identifier AttributeOpt /* Option */ RBracket;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute(
        &mut self,
        _hash_l_bracket: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _attribute_opt: &ParseTreeType<'t>,
        _r_bracket: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_bracket = pop_item!(self, r_bracket, RBracket, context);
        let attribute_opt = pop_item!(self, attribute_opt, AttributeOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let hash_l_bracket = pop_item!(self, hash_l_bracket, HashLBracket, context);
        let attribute_built = Attribute {
            hash_l_bracket: Box::new(hash_l_bracket),
            identifier: Box::new(identifier),
            attribute_opt,
            r_bracket: Box::new(r_bracket),
        };
        // Calling user action here
        self.user_grammar.attribute(&attribute_built)?;
        self.push(ASTType::Attribute(attribute_built), context);
        Ok(())
    }

    /// Semantic action for production 726:
    ///
    /// `AttributeOpt /* Option<T>::Some */: LParen AttributeList RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_opt_0(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _attribute_list: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let attribute_list = pop_item!(self, attribute_list, AttributeList, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let attribute_opt_0_built = AttributeOpt {
            l_paren: Box::new(l_paren),
            attribute_list: Box::new(attribute_list),
            r_paren: Box::new(r_paren),
        };
        self.push(ASTType::AttributeOpt(Some(attribute_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 727:
    ///
    /// `AttributeOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AttributeOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 728:
    ///
    /// `AttributeList: AttributeItem AttributeListList /* Vec */ AttributeListOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_list(
        &mut self,
        _attribute_item: &ParseTreeType<'t>,
        _attribute_list_list: &ParseTreeType<'t>,
        _attribute_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let attribute_list_opt = pop_item!(self, attribute_list_opt, AttributeListOpt, context);
        let attribute_list_list =
            pop_and_reverse_item!(self, attribute_list_list, AttributeListList, context);
        let attribute_item = pop_item!(self, attribute_item, AttributeItem, context);
        let attribute_list_built = AttributeList {
            attribute_item: Box::new(attribute_item),
            attribute_list_list,
            attribute_list_opt,
        };
        // Calling user action here
        self.user_grammar.attribute_list(&attribute_list_built)?;
        self.push(ASTType::AttributeList(attribute_list_built), context);
        Ok(())
    }

    /// Semantic action for production 729:
    ///
    /// `AttributeListList /* Vec<T>::Push */: Comma AttributeItem AttributeListList;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _attribute_item: &ParseTreeType<'t>,
        _attribute_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut attribute_list_list =
            pop_item!(self, attribute_list_list, AttributeListList, context);
        let attribute_item = pop_item!(self, attribute_item, AttributeItem, context);
        let comma = pop_item!(self, comma, Comma, context);
        let attribute_list_list_0_built = AttributeListList {
            attribute_item: Box::new(attribute_item),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        attribute_list_list.push(attribute_list_list_0_built);
        self.push(ASTType::AttributeListList(attribute_list_list), context);
        Ok(())
    }

    /// Semantic action for production 730:
    ///
    /// `AttributeListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let attribute_list_list_1_built = Vec::new();
        self.push(
            ASTType::AttributeListList(attribute_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 731:
    ///
    /// `AttributeListOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let attribute_list_opt_0_built = AttributeListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::AttributeListOpt(Some(attribute_list_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 732:
    ///
    /// `AttributeListOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AttributeListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 733:
    ///
    /// `AttributeItem: Identifier;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_item_0(&mut self, _identifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let attribute_item_0_built = AttributeItemIdentifier {
            identifier: Box::new(identifier),
        };
        let attribute_item_0_built = AttributeItem::Identifier(attribute_item_0_built);
        // Calling user action here
        self.user_grammar.attribute_item(&attribute_item_0_built)?;
        self.push(ASTType::AttributeItem(attribute_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 734:
    ///
    /// `AttributeItem: StringLiteral;`
    ///
    #[parol_runtime::function_name::named]
    fn attribute_item_1(&mut self, _string_literal: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let string_literal = pop_item!(self, string_literal, StringLiteral, context);
        let attribute_item_1_built = AttributeItemStringLiteral {
            string_literal: Box::new(string_literal),
        };
        let attribute_item_1_built = AttributeItem::StringLiteral(attribute_item_1_built);
        // Calling user action here
        self.user_grammar.attribute_item(&attribute_item_1_built)?;
        self.push(ASTType::AttributeItem(attribute_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 735:
    ///
    /// `LetDeclaration: Let Identifier Colon LetDeclarationOpt /* Option */ ArrayType Equ Expression Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn let_declaration(
        &mut self,
        _let: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _let_declaration_opt: &ParseTreeType<'t>,
        _array_type: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let array_type = pop_item!(self, array_type, ArrayType, context);
        let let_declaration_opt = pop_item!(self, let_declaration_opt, LetDeclarationOpt, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let r#let = pop_item!(self, r#let, Let, context);
        let let_declaration_built = LetDeclaration {
            r#let: Box::new(r#let),
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            let_declaration_opt,
            array_type: Box::new(array_type),
            equ: Box::new(equ),
            expression: Box::new(expression),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar.let_declaration(&let_declaration_built)?;
        self.push(ASTType::LetDeclaration(let_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 736:
    ///
    /// `LetDeclarationOpt /* Option<T>::Some */: ClockDomain;`
    ///
    #[parol_runtime::function_name::named]
    fn let_declaration_opt_0(&mut self, _clock_domain: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let clock_domain = pop_item!(self, clock_domain, ClockDomain, context);
        let let_declaration_opt_0_built = LetDeclarationOpt {
            clock_domain: Box::new(clock_domain),
        };
        self.push(
            ASTType::LetDeclarationOpt(Some(let_declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 737:
    ///
    /// `LetDeclarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn let_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::LetDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 738:
    ///
    /// `VarDeclaration: Var Identifier Colon VarDeclarationOpt /* Option */ ArrayType Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn var_declaration(
        &mut self,
        _var: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _var_declaration_opt: &ParseTreeType<'t>,
        _array_type: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let array_type = pop_item!(self, array_type, ArrayType, context);
        let var_declaration_opt = pop_item!(self, var_declaration_opt, VarDeclarationOpt, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let var = pop_item!(self, var, Var, context);
        let var_declaration_built = VarDeclaration {
            var: Box::new(var),
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            var_declaration_opt,
            array_type: Box::new(array_type),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar.var_declaration(&var_declaration_built)?;
        self.push(ASTType::VarDeclaration(var_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 739:
    ///
    /// `VarDeclarationOpt /* Option<T>::Some */: ClockDomain;`
    ///
    #[parol_runtime::function_name::named]
    fn var_declaration_opt_0(&mut self, _clock_domain: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let clock_domain = pop_item!(self, clock_domain, ClockDomain, context);
        let var_declaration_opt_0_built = VarDeclarationOpt {
            clock_domain: Box::new(clock_domain),
        };
        self.push(
            ASTType::VarDeclarationOpt(Some(var_declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 740:
    ///
    /// `VarDeclarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn var_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::VarDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 741:
    ///
    /// `ConstDeclaration: Const Identifier Colon ConstDeclarationGroup Equ Expression Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn const_declaration(
        &mut self,
        _const: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _const_declaration_group: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let const_declaration_group = pop_item!(
            self,
            const_declaration_group,
            ConstDeclarationGroup,
            context
        );
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let r#const = pop_item!(self, r#const, Const, context);
        let const_declaration_built = ConstDeclaration {
            r#const: Box::new(r#const),
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            const_declaration_group: Box::new(const_declaration_group),
            equ: Box::new(equ),
            expression: Box::new(expression),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .const_declaration(&const_declaration_built)?;
        self.push(ASTType::ConstDeclaration(const_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 742:
    ///
    /// `ConstDeclarationGroup: ArrayType;`
    ///
    #[parol_runtime::function_name::named]
    fn const_declaration_group_0(&mut self, _array_type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_type = pop_item!(self, array_type, ArrayType, context);
        let const_declaration_group_0_built = ConstDeclarationGroupArrayType {
            array_type: Box::new(array_type),
        };
        let const_declaration_group_0_built =
            ConstDeclarationGroup::ArrayType(const_declaration_group_0_built);
        self.push(
            ASTType::ConstDeclarationGroup(const_declaration_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 743:
    ///
    /// `ConstDeclarationGroup: Type;`
    ///
    #[parol_runtime::function_name::named]
    fn const_declaration_group_1(&mut self, _type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#type = pop_item!(self, r#type, Type, context);
        let const_declaration_group_1_built = ConstDeclarationGroupType {
            r#type: Box::new(r#type),
        };
        let const_declaration_group_1_built =
            ConstDeclarationGroup::Type(const_declaration_group_1_built);
        self.push(
            ASTType::ConstDeclarationGroup(const_declaration_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 744:
    ///
    /// `TypeDefDeclaration: Type Identifier Equ ArrayType Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn type_def_declaration(
        &mut self,
        _type: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _array_type: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let array_type = pop_item!(self, array_type, ArrayType, context);
        let equ = pop_item!(self, equ, Equ, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let type_def_declaration_built = TypeDefDeclaration {
            r#type: Box::new(r#type),
            identifier: Box::new(identifier),
            equ: Box::new(equ),
            array_type: Box::new(array_type),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .type_def_declaration(&type_def_declaration_built)?;
        self.push(
            ASTType::TypeDefDeclaration(type_def_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 745:
    ///
    /// `AlwaysFfDeclaration: AlwaysFf AlwaysFfDeclarationOpt /* Option */ StatementBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_declaration(
        &mut self,
        _always_ff: &ParseTreeType<'t>,
        _always_ff_declaration_opt: &ParseTreeType<'t>,
        _statement_block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block = pop_item!(self, statement_block, StatementBlock, context);
        let always_ff_declaration_opt = pop_item!(
            self,
            always_ff_declaration_opt,
            AlwaysFfDeclarationOpt,
            context
        );
        let always_ff = pop_item!(self, always_ff, AlwaysFf, context);
        let always_ff_declaration_built = AlwaysFfDeclaration {
            always_ff: Box::new(always_ff),
            always_ff_declaration_opt,
            statement_block: Box::new(statement_block),
        };
        // Calling user action here
        self.user_grammar
            .always_ff_declaration(&always_ff_declaration_built)?;
        self.push(
            ASTType::AlwaysFfDeclaration(always_ff_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 746:
    ///
    /// `AlwaysFfDeclarationOpt /* Option<T>::Some */: AlwaysFfEventList;`
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_declaration_opt_0(
        &mut self,
        _always_ff_event_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_event_list =
            pop_item!(self, always_ff_event_list, AlwaysFfEventList, context);
        let always_ff_declaration_opt_0_built = AlwaysFfDeclarationOpt {
            always_ff_event_list: Box::new(always_ff_event_list),
        };
        self.push(
            ASTType::AlwaysFfDeclarationOpt(Some(always_ff_declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 747:
    ///
    /// `AlwaysFfDeclarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AlwaysFfDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 748:
    ///
    /// `AlwaysFfEventList: LParen AlwaysFfClock AlwaysFfEventListOpt /* Option */ RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_event_list(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _always_ff_clock: &ParseTreeType<'t>,
        _always_ff_event_list_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let always_ff_event_list_opt = pop_item!(
            self,
            always_ff_event_list_opt,
            AlwaysFfEventListOpt,
            context
        );
        let always_ff_clock = pop_item!(self, always_ff_clock, AlwaysFfClock, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let always_ff_event_list_built = AlwaysFfEventList {
            l_paren: Box::new(l_paren),
            always_ff_clock: Box::new(always_ff_clock),
            always_ff_event_list_opt,
            r_paren: Box::new(r_paren),
        };
        // Calling user action here
        self.user_grammar
            .always_ff_event_list(&always_ff_event_list_built)?;
        self.push(
            ASTType::AlwaysFfEventList(always_ff_event_list_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 749:
    ///
    /// `AlwaysFfEventListOpt /* Option<T>::Some */: Comma AlwaysFfReset;`
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_event_list_opt_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _always_ff_reset: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_reset = pop_item!(self, always_ff_reset, AlwaysFfReset, context);
        let comma = pop_item!(self, comma, Comma, context);
        let always_ff_event_list_opt_0_built = AlwaysFfEventListOpt {
            comma: Box::new(comma),
            always_ff_reset: Box::new(always_ff_reset),
        };
        self.push(
            ASTType::AlwaysFfEventListOpt(Some(always_ff_event_list_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 750:
    ///
    /// `AlwaysFfEventListOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_event_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AlwaysFfEventListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 751:
    ///
    /// `AlwaysFfClock: HierarchicalIdentifier;`
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_clock(&mut self, _hierarchical_identifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hierarchical_identifier = pop_item!(
            self,
            hierarchical_identifier,
            HierarchicalIdentifier,
            context
        );
        let always_ff_clock_built = AlwaysFfClock {
            hierarchical_identifier: Box::new(hierarchical_identifier),
        };
        // Calling user action here
        self.user_grammar.always_ff_clock(&always_ff_clock_built)?;
        self.push(ASTType::AlwaysFfClock(always_ff_clock_built), context);
        Ok(())
    }

    /// Semantic action for production 752:
    ///
    /// `AlwaysFfReset: HierarchicalIdentifier;`
    ///
    #[parol_runtime::function_name::named]
    fn always_ff_reset(&mut self, _hierarchical_identifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hierarchical_identifier = pop_item!(
            self,
            hierarchical_identifier,
            HierarchicalIdentifier,
            context
        );
        let always_ff_reset_built = AlwaysFfReset {
            hierarchical_identifier: Box::new(hierarchical_identifier),
        };
        // Calling user action here
        self.user_grammar.always_ff_reset(&always_ff_reset_built)?;
        self.push(ASTType::AlwaysFfReset(always_ff_reset_built), context);
        Ok(())
    }

    /// Semantic action for production 753:
    ///
    /// `AlwaysCombDeclaration: AlwaysComb StatementBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn always_comb_declaration(
        &mut self,
        _always_comb: &ParseTreeType<'t>,
        _statement_block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block = pop_item!(self, statement_block, StatementBlock, context);
        let always_comb = pop_item!(self, always_comb, AlwaysComb, context);
        let always_comb_declaration_built = AlwaysCombDeclaration {
            always_comb: Box::new(always_comb),
            statement_block: Box::new(statement_block),
        };
        // Calling user action here
        self.user_grammar
            .always_comb_declaration(&always_comb_declaration_built)?;
        self.push(
            ASTType::AlwaysCombDeclaration(always_comb_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 754:
    ///
    /// `AssignDeclaration: Assign AssignDestination Equ Expression Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn assign_declaration(
        &mut self,
        _assign: &ParseTreeType<'t>,
        _assign_destination: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let assign_destination = pop_item!(self, assign_destination, AssignDestination, context);
        let assign = pop_item!(self, assign, Assign, context);
        let assign_declaration_built = AssignDeclaration {
            assign: Box::new(assign),
            assign_destination: Box::new(assign_destination),
            equ: Box::new(equ),
            expression: Box::new(expression),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .assign_declaration(&assign_declaration_built)?;
        self.push(
            ASTType::AssignDeclaration(assign_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 755:
    ///
    /// `AssignDestination: HierarchicalIdentifier;`
    ///
    #[parol_runtime::function_name::named]
    fn assign_destination_0(&mut self, _hierarchical_identifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hierarchical_identifier = pop_item!(
            self,
            hierarchical_identifier,
            HierarchicalIdentifier,
            context
        );
        let assign_destination_0_built = AssignDestinationHierarchicalIdentifier {
            hierarchical_identifier: Box::new(hierarchical_identifier),
        };
        let assign_destination_0_built =
            AssignDestination::HierarchicalIdentifier(assign_destination_0_built);
        // Calling user action here
        self.user_grammar
            .assign_destination(&assign_destination_0_built)?;
        self.push(
            ASTType::AssignDestination(assign_destination_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 756:
    ///
    /// `AssignDestination: LBrace AssignConcatenationList RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn assign_destination_1(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _assign_concatenation_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let assign_concatenation_list = pop_item!(
            self,
            assign_concatenation_list,
            AssignConcatenationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let assign_destination_1_built = AssignDestinationLBraceAssignConcatenationListRBrace {
            l_brace: Box::new(l_brace),
            assign_concatenation_list: Box::new(assign_concatenation_list),
            r_brace: Box::new(r_brace),
        };
        let assign_destination_1_built =
            AssignDestination::LBraceAssignConcatenationListRBrace(assign_destination_1_built);
        // Calling user action here
        self.user_grammar
            .assign_destination(&assign_destination_1_built)?;
        self.push(
            ASTType::AssignDestination(assign_destination_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 757:
    ///
    /// `AssignConcatenationList: AssignConcatenationItem AssignConcatenationListList /* Vec */ AssignConcatenationListOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn assign_concatenation_list(
        &mut self,
        _assign_concatenation_item: &ParseTreeType<'t>,
        _assign_concatenation_list_list: &ParseTreeType<'t>,
        _assign_concatenation_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign_concatenation_list_opt = pop_item!(
            self,
            assign_concatenation_list_opt,
            AssignConcatenationListOpt,
            context
        );
        let assign_concatenation_list_list = pop_and_reverse_item!(
            self,
            assign_concatenation_list_list,
            AssignConcatenationListList,
            context
        );
        let assign_concatenation_item = pop_item!(
            self,
            assign_concatenation_item,
            AssignConcatenationItem,
            context
        );
        let assign_concatenation_list_built = AssignConcatenationList {
            assign_concatenation_item: Box::new(assign_concatenation_item),
            assign_concatenation_list_list,
            assign_concatenation_list_opt,
        };
        // Calling user action here
        self.user_grammar
            .assign_concatenation_list(&assign_concatenation_list_built)?;
        self.push(
            ASTType::AssignConcatenationList(assign_concatenation_list_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 758:
    ///
    /// `AssignConcatenationListList /* Vec<T>::Push */: Comma AssignConcatenationItem AssignConcatenationListList;`
    ///
    #[parol_runtime::function_name::named]
    fn assign_concatenation_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _assign_concatenation_item: &ParseTreeType<'t>,
        _assign_concatenation_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut assign_concatenation_list_list = pop_item!(
            self,
            assign_concatenation_list_list,
            AssignConcatenationListList,
            context
        );
        let assign_concatenation_item = pop_item!(
            self,
            assign_concatenation_item,
            AssignConcatenationItem,
            context
        );
        let comma = pop_item!(self, comma, Comma, context);
        let assign_concatenation_list_list_0_built = AssignConcatenationListList {
            assign_concatenation_item: Box::new(assign_concatenation_item),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        assign_concatenation_list_list.push(assign_concatenation_list_list_0_built);
        self.push(
            ASTType::AssignConcatenationListList(assign_concatenation_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 759:
    ///
    /// `AssignConcatenationListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn assign_concatenation_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign_concatenation_list_list_1_built = Vec::new();
        self.push(
            ASTType::AssignConcatenationListList(assign_concatenation_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 760:
    ///
    /// `AssignConcatenationListOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn assign_concatenation_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let assign_concatenation_list_opt_0_built = AssignConcatenationListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::AssignConcatenationListOpt(Some(assign_concatenation_list_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 761:
    ///
    /// `AssignConcatenationListOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn assign_concatenation_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::AssignConcatenationListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 762:
    ///
    /// `AssignConcatenationItem: HierarchicalIdentifier;`
    ///
    #[parol_runtime::function_name::named]
    fn assign_concatenation_item(
        &mut self,
        _hierarchical_identifier: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let hierarchical_identifier = pop_item!(
            self,
            hierarchical_identifier,
            HierarchicalIdentifier,
            context
        );
        let assign_concatenation_item_built = AssignConcatenationItem {
            hierarchical_identifier: Box::new(hierarchical_identifier),
        };
        // Calling user action here
        self.user_grammar
            .assign_concatenation_item(&assign_concatenation_item_built)?;
        self.push(
            ASTType::AssignConcatenationItem(assign_concatenation_item_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 763:
    ///
    /// `ConnectDeclaration: Connect HierarchicalIdentifier DiamondOperator Expression Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn connect_declaration(
        &mut self,
        _connect: &ParseTreeType<'t>,
        _hierarchical_identifier: &ParseTreeType<'t>,
        _diamond_operator: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let expression = pop_item!(self, expression, Expression, context);
        let diamond_operator = pop_item!(self, diamond_operator, DiamondOperator, context);
        let hierarchical_identifier = pop_item!(
            self,
            hierarchical_identifier,
            HierarchicalIdentifier,
            context
        );
        let connect = pop_item!(self, connect, Connect, context);
        let connect_declaration_built = ConnectDeclaration {
            connect: Box::new(connect),
            hierarchical_identifier: Box::new(hierarchical_identifier),
            diamond_operator: Box::new(diamond_operator),
            expression: Box::new(expression),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .connect_declaration(&connect_declaration_built)?;
        self.push(
            ASTType::ConnectDeclaration(connect_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 764:
    ///
    /// `ModportDeclaration: Modport Identifier LBrace ModportDeclarationOpt /* Option */ ModportDeclarationOpt0 /* Option */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_declaration(
        &mut self,
        _modport: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _modport_declaration_opt: &ParseTreeType<'t>,
        _modport_declaration_opt0: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let modport_declaration_opt0 = pop_item!(
            self,
            modport_declaration_opt0,
            ModportDeclarationOpt0,
            context
        );
        let modport_declaration_opt = pop_item!(
            self,
            modport_declaration_opt,
            ModportDeclarationOpt,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let modport = pop_item!(self, modport, Modport, context);
        let modport_declaration_built = ModportDeclaration {
            modport: Box::new(modport),
            identifier: Box::new(identifier),
            l_brace: Box::new(l_brace),
            modport_declaration_opt,
            modport_declaration_opt0,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .modport_declaration(&modport_declaration_built)?;
        self.push(
            ASTType::ModportDeclaration(modport_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 765:
    ///
    /// `ModportDeclarationOpt0 /* Option<T>::Some */: DotDot ModportDefault;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_declaration_opt0_0(
        &mut self,
        _dot_dot: &ParseTreeType<'t>,
        _modport_default: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_default = pop_item!(self, modport_default, ModportDefault, context);
        let dot_dot = pop_item!(self, dot_dot, DotDot, context);
        let modport_declaration_opt0_0_built = ModportDeclarationOpt0 {
            dot_dot: Box::new(dot_dot),
            modport_default: Box::new(modport_default),
        };
        self.push(
            ASTType::ModportDeclarationOpt0(Some(modport_declaration_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 766:
    ///
    /// `ModportDeclarationOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_declaration_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModportDeclarationOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 767:
    ///
    /// `ModportDeclarationOpt /* Option<T>::Some */: ModportList;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_declaration_opt_0(&mut self, _modport_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_list = pop_item!(self, modport_list, ModportList, context);
        let modport_declaration_opt_0_built = ModportDeclarationOpt {
            modport_list: Box::new(modport_list),
        };
        self.push(
            ASTType::ModportDeclarationOpt(Some(modport_declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 768:
    ///
    /// `ModportDeclarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModportDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 769:
    ///
    /// `ModportList: ModportGroup ModportListList /* Vec */ ModportListOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_list(
        &mut self,
        _modport_group: &ParseTreeType<'t>,
        _modport_list_list: &ParseTreeType<'t>,
        _modport_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_list_opt = pop_item!(self, modport_list_opt, ModportListOpt, context);
        let modport_list_list =
            pop_and_reverse_item!(self, modport_list_list, ModportListList, context);
        let modport_group = pop_item!(self, modport_group, ModportGroup, context);
        let modport_list_built = ModportList {
            modport_group: Box::new(modport_group),
            modport_list_list,
            modport_list_opt,
        };
        // Calling user action here
        self.user_grammar.modport_list(&modport_list_built)?;
        self.push(ASTType::ModportList(modport_list_built), context);
        Ok(())
    }

    /// Semantic action for production 770:
    ///
    /// `ModportListList /* Vec<T>::Push */: Comma ModportGroup ModportListList;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _modport_group: &ParseTreeType<'t>,
        _modport_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut modport_list_list = pop_item!(self, modport_list_list, ModportListList, context);
        let modport_group = pop_item!(self, modport_group, ModportGroup, context);
        let comma = pop_item!(self, comma, Comma, context);
        let modport_list_list_0_built = ModportListList {
            modport_group: Box::new(modport_group),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        modport_list_list.push(modport_list_list_0_built);
        self.push(ASTType::ModportListList(modport_list_list), context);
        Ok(())
    }

    /// Semantic action for production 771:
    ///
    /// `ModportListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_list_list_1_built = Vec::new();
        self.push(ASTType::ModportListList(modport_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 772:
    ///
    /// `ModportListOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let modport_list_opt_0_built = ModportListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::ModportListOpt(Some(modport_list_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 773:
    ///
    /// `ModportListOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModportListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 774:
    ///
    /// `ModportGroup: ModportGroupList /* Vec */ ModportGroupGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_group(
        &mut self,
        _modport_group_list: &ParseTreeType<'t>,
        _modport_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_group_group = pop_item!(self, modport_group_group, ModportGroupGroup, context);
        let modport_group_list =
            pop_and_reverse_item!(self, modport_group_list, ModportGroupList, context);
        let modport_group_built = ModportGroup {
            modport_group_list,
            modport_group_group: Box::new(modport_group_group),
        };
        // Calling user action here
        self.user_grammar.modport_group(&modport_group_built)?;
        self.push(ASTType::ModportGroup(modport_group_built), context);
        Ok(())
    }

    /// Semantic action for production 775:
    ///
    /// `ModportGroupGroup: LBrace ModportList RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _modport_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let modport_list = pop_item!(self, modport_list, ModportList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let modport_group_group_0_built = ModportGroupGroupLBraceModportListRBrace {
            l_brace: Box::new(l_brace),
            modport_list: Box::new(modport_list),
            r_brace: Box::new(r_brace),
        };
        let modport_group_group_0_built =
            ModportGroupGroup::LBraceModportListRBrace(modport_group_group_0_built);
        self.push(
            ASTType::ModportGroupGroup(modport_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 776:
    ///
    /// `ModportGroupGroup: ModportItem;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_group_group_1(&mut self, _modport_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_item = pop_item!(self, modport_item, ModportItem, context);
        let modport_group_group_1_built = ModportGroupGroupModportItem {
            modport_item: Box::new(modport_item),
        };
        let modport_group_group_1_built =
            ModportGroupGroup::ModportItem(modport_group_group_1_built);
        self.push(
            ASTType::ModportGroupGroup(modport_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 777:
    ///
    /// `ModportGroupList /* Vec<T>::Push */: Attribute ModportGroupList;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _modport_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut modport_group_list = pop_item!(self, modport_group_list, ModportGroupList, context);
        let attribute = pop_item!(self, attribute, Attribute, context);
        let modport_group_list_0_built = ModportGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        modport_group_list.push(modport_group_list_0_built);
        self.push(ASTType::ModportGroupList(modport_group_list), context);
        Ok(())
    }

    /// Semantic action for production 778:
    ///
    /// `ModportGroupList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_group_list_1_built = Vec::new();
        self.push(
            ASTType::ModportGroupList(modport_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 779:
    ///
    /// `ModportItem: Identifier Colon Direction;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_item(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _direction: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let direction = pop_item!(self, direction, Direction, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let modport_item_built = ModportItem {
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            direction: Box::new(direction),
        };
        // Calling user action here
        self.user_grammar.modport_item(&modport_item_built)?;
        self.push(ASTType::ModportItem(modport_item_built), context);
        Ok(())
    }

    /// Semantic action for production 780:
    ///
    /// `ModportDefault: Input;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_default_0(&mut self, _input: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input = pop_item!(self, input, Input, context);
        let modport_default_0_built = ModportDefaultInput {
            input: Box::new(input),
        };
        let modport_default_0_built = ModportDefault::Input(modport_default_0_built);
        // Calling user action here
        self.user_grammar
            .modport_default(&modport_default_0_built)?;
        self.push(ASTType::ModportDefault(modport_default_0_built), context);
        Ok(())
    }

    /// Semantic action for production 781:
    ///
    /// `ModportDefault: Output;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_default_1(&mut self, _output: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output = pop_item!(self, output, Output, context);
        let modport_default_1_built = ModportDefaultOutput {
            output: Box::new(output),
        };
        let modport_default_1_built = ModportDefault::Output(modport_default_1_built);
        // Calling user action here
        self.user_grammar
            .modport_default(&modport_default_1_built)?;
        self.push(ASTType::ModportDefault(modport_default_1_built), context);
        Ok(())
    }

    /// Semantic action for production 782:
    ///
    /// `ModportDefault: Same LParen Identifier RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_default_2(
        &mut self,
        _same: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let same = pop_item!(self, same, Same, context);
        let modport_default_2_built = ModportDefaultSameLParenIdentifierRParen {
            same: Box::new(same),
            l_paren: Box::new(l_paren),
            identifier: Box::new(identifier),
            r_paren: Box::new(r_paren),
        };
        let modport_default_2_built =
            ModportDefault::SameLParenIdentifierRParen(modport_default_2_built);
        // Calling user action here
        self.user_grammar
            .modport_default(&modport_default_2_built)?;
        self.push(ASTType::ModportDefault(modport_default_2_built), context);
        Ok(())
    }

    /// Semantic action for production 783:
    ///
    /// `ModportDefault: Converse LParen Identifier RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn modport_default_3(
        &mut self,
        _converse: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let converse = pop_item!(self, converse, Converse, context);
        let modport_default_3_built = ModportDefaultConverseLParenIdentifierRParen {
            converse: Box::new(converse),
            l_paren: Box::new(l_paren),
            identifier: Box::new(identifier),
            r_paren: Box::new(r_paren),
        };
        let modport_default_3_built =
            ModportDefault::ConverseLParenIdentifierRParen(modport_default_3_built);
        // Calling user action here
        self.user_grammar
            .modport_default(&modport_default_3_built)?;
        self.push(ASTType::ModportDefault(modport_default_3_built), context);
        Ok(())
    }

    /// Semantic action for production 784:
    ///
    /// `EnumDeclaration: Enum Identifier EnumDeclarationOpt /* Option */ LBrace EnumList RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_declaration(
        &mut self,
        _enum: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _enum_declaration_opt: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _enum_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let enum_list = pop_item!(self, enum_list, EnumList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let enum_declaration_opt =
            pop_item!(self, enum_declaration_opt, EnumDeclarationOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let r#enum = pop_item!(self, r#enum, Enum, context);
        let enum_declaration_built = EnumDeclaration {
            r#enum: Box::new(r#enum),
            identifier: Box::new(identifier),
            enum_declaration_opt,
            l_brace: Box::new(l_brace),
            enum_list: Box::new(enum_list),
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .enum_declaration(&enum_declaration_built)?;
        self.push(ASTType::EnumDeclaration(enum_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 785:
    ///
    /// `EnumDeclarationOpt /* Option<T>::Some */: Colon ScalarType;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_declaration_opt_0(
        &mut self,
        _colon: &ParseTreeType<'t>,
        _scalar_type: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scalar_type = pop_item!(self, scalar_type, ScalarType, context);
        let colon = pop_item!(self, colon, Colon, context);
        let enum_declaration_opt_0_built = EnumDeclarationOpt {
            colon: Box::new(colon),
            scalar_type: Box::new(scalar_type),
        };
        self.push(
            ASTType::EnumDeclarationOpt(Some(enum_declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 786:
    ///
    /// `EnumDeclarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::EnumDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 787:
    ///
    /// `EnumList: EnumGroup EnumListList /* Vec */ EnumListOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_list(
        &mut self,
        _enum_group: &ParseTreeType<'t>,
        _enum_list_list: &ParseTreeType<'t>,
        _enum_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_list_opt = pop_item!(self, enum_list_opt, EnumListOpt, context);
        let enum_list_list = pop_and_reverse_item!(self, enum_list_list, EnumListList, context);
        let enum_group = pop_item!(self, enum_group, EnumGroup, context);
        let enum_list_built = EnumList {
            enum_group: Box::new(enum_group),
            enum_list_list,
            enum_list_opt,
        };
        // Calling user action here
        self.user_grammar.enum_list(&enum_list_built)?;
        self.push(ASTType::EnumList(enum_list_built), context);
        Ok(())
    }

    /// Semantic action for production 788:
    ///
    /// `EnumListList /* Vec<T>::Push */: Comma EnumGroup EnumListList;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _enum_group: &ParseTreeType<'t>,
        _enum_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut enum_list_list = pop_item!(self, enum_list_list, EnumListList, context);
        let enum_group = pop_item!(self, enum_group, EnumGroup, context);
        let comma = pop_item!(self, comma, Comma, context);
        let enum_list_list_0_built = EnumListList {
            enum_group: Box::new(enum_group),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        enum_list_list.push(enum_list_list_0_built);
        self.push(ASTType::EnumListList(enum_list_list), context);
        Ok(())
    }

    /// Semantic action for production 789:
    ///
    /// `EnumListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_list_list_1_built = Vec::new();
        self.push(ASTType::EnumListList(enum_list_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 790:
    ///
    /// `EnumListOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let enum_list_opt_0_built = EnumListOpt {
            comma: Box::new(comma),
        };
        self.push(ASTType::EnumListOpt(Some(enum_list_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 791:
    ///
    /// `EnumListOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::EnumListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 792:
    ///
    /// `EnumGroup: EnumGroupList /* Vec */ EnumGroupGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_group(
        &mut self,
        _enum_group_list: &ParseTreeType<'t>,
        _enum_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_group_group = pop_item!(self, enum_group_group, EnumGroupGroup, context);
        let enum_group_list = pop_and_reverse_item!(self, enum_group_list, EnumGroupList, context);
        let enum_group_built = EnumGroup {
            enum_group_list,
            enum_group_group: Box::new(enum_group_group),
        };
        // Calling user action here
        self.user_grammar.enum_group(&enum_group_built)?;
        self.push(ASTType::EnumGroup(enum_group_built), context);
        Ok(())
    }

    /// Semantic action for production 793:
    ///
    /// `EnumGroupGroup: LBrace EnumList RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _enum_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let enum_list = pop_item!(self, enum_list, EnumList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let enum_group_group_0_built = EnumGroupGroupLBraceEnumListRBrace {
            l_brace: Box::new(l_brace),
            enum_list: Box::new(enum_list),
            r_brace: Box::new(r_brace),
        };
        let enum_group_group_0_built =
            EnumGroupGroup::LBraceEnumListRBrace(enum_group_group_0_built);
        self.push(ASTType::EnumGroupGroup(enum_group_group_0_built), context);
        Ok(())
    }

    /// Semantic action for production 794:
    ///
    /// `EnumGroupGroup: EnumItem;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_group_group_1(&mut self, _enum_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_item = pop_item!(self, enum_item, EnumItem, context);
        let enum_group_group_1_built = EnumGroupGroupEnumItem {
            enum_item: Box::new(enum_item),
        };
        let enum_group_group_1_built = EnumGroupGroup::EnumItem(enum_group_group_1_built);
        self.push(ASTType::EnumGroupGroup(enum_group_group_1_built), context);
        Ok(())
    }

    /// Semantic action for production 795:
    ///
    /// `EnumGroupList /* Vec<T>::Push */: Attribute EnumGroupList;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _enum_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut enum_group_list = pop_item!(self, enum_group_list, EnumGroupList, context);
        let attribute = pop_item!(self, attribute, Attribute, context);
        let enum_group_list_0_built = EnumGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        enum_group_list.push(enum_group_list_0_built);
        self.push(ASTType::EnumGroupList(enum_group_list), context);
        Ok(())
    }

    /// Semantic action for production 796:
    ///
    /// `EnumGroupList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_group_list_1_built = Vec::new();
        self.push(ASTType::EnumGroupList(enum_group_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 797:
    ///
    /// `EnumItem: Identifier EnumItemOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_item(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _enum_item_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_item_opt = pop_item!(self, enum_item_opt, EnumItemOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let enum_item_built = EnumItem {
            identifier: Box::new(identifier),
            enum_item_opt,
        };
        // Calling user action here
        self.user_grammar.enum_item(&enum_item_built)?;
        self.push(ASTType::EnumItem(enum_item_built), context);
        Ok(())
    }

    /// Semantic action for production 798:
    ///
    /// `EnumItemOpt /* Option<T>::Some */: Equ Expression;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_item_opt_0(
        &mut self,
        _equ: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let enum_item_opt_0_built = EnumItemOpt {
            equ: Box::new(equ),
            expression: Box::new(expression),
        };
        self.push(ASTType::EnumItemOpt(Some(enum_item_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 799:
    ///
    /// `EnumItemOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn enum_item_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::EnumItemOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 800:
    ///
    /// `StructUnion: Struct;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_union_0(&mut self, _struct: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#struct = pop_item!(self, r#struct, Struct, context);
        let struct_union_0_built = StructUnionStruct {
            r#struct: Box::new(r#struct),
        };
        let struct_union_0_built = StructUnion::Struct(struct_union_0_built);
        // Calling user action here
        self.user_grammar.struct_union(&struct_union_0_built)?;
        self.push(ASTType::StructUnion(struct_union_0_built), context);
        Ok(())
    }

    /// Semantic action for production 801:
    ///
    /// `StructUnion: Union;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_union_1(&mut self, _union: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#union = pop_item!(self, r#union, Union, context);
        let struct_union_1_built = StructUnionUnion {
            r#union: Box::new(r#union),
        };
        let struct_union_1_built = StructUnion::Union(struct_union_1_built);
        // Calling user action here
        self.user_grammar.struct_union(&struct_union_1_built)?;
        self.push(ASTType::StructUnion(struct_union_1_built), context);
        Ok(())
    }

    /// Semantic action for production 802:
    ///
    /// `StructUnionDeclaration: StructUnion Identifier StructUnionDeclarationOpt /* Option */ LBrace StructUnionList RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_union_declaration(
        &mut self,
        _struct_union: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _struct_union_declaration_opt: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _struct_union_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let struct_union_list = pop_item!(self, struct_union_list, StructUnionList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let struct_union_declaration_opt = pop_item!(
            self,
            struct_union_declaration_opt,
            StructUnionDeclarationOpt,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let struct_union = pop_item!(self, struct_union, StructUnion, context);
        let struct_union_declaration_built = StructUnionDeclaration {
            struct_union: Box::new(struct_union),
            identifier: Box::new(identifier),
            struct_union_declaration_opt,
            l_brace: Box::new(l_brace),
            struct_union_list: Box::new(struct_union_list),
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .struct_union_declaration(&struct_union_declaration_built)?;
        self.push(
            ASTType::StructUnionDeclaration(struct_union_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 803:
    ///
    /// `StructUnionDeclarationOpt /* Option<T>::Some */: WithGenericParameter;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_union_declaration_opt_0(
        &mut self,
        _with_generic_parameter: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_generic_parameter =
            pop_item!(self, with_generic_parameter, WithGenericParameter, context);
        let struct_union_declaration_opt_0_built = StructUnionDeclarationOpt {
            with_generic_parameter: Box::new(with_generic_parameter),
        };
        self.push(
            ASTType::StructUnionDeclarationOpt(Some(struct_union_declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 804:
    ///
    /// `StructUnionDeclarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_union_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StructUnionDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 805:
    ///
    /// `StructUnionList: StructUnionGroup StructUnionListList /* Vec */ StructUnionListOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_union_list(
        &mut self,
        _struct_union_group: &ParseTreeType<'t>,
        _struct_union_list_list: &ParseTreeType<'t>,
        _struct_union_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_union_list_opt =
            pop_item!(self, struct_union_list_opt, StructUnionListOpt, context);
        let struct_union_list_list =
            pop_and_reverse_item!(self, struct_union_list_list, StructUnionListList, context);
        let struct_union_group = pop_item!(self, struct_union_group, StructUnionGroup, context);
        let struct_union_list_built = StructUnionList {
            struct_union_group: Box::new(struct_union_group),
            struct_union_list_list,
            struct_union_list_opt,
        };
        // Calling user action here
        self.user_grammar
            .struct_union_list(&struct_union_list_built)?;
        self.push(ASTType::StructUnionList(struct_union_list_built), context);
        Ok(())
    }

    /// Semantic action for production 806:
    ///
    /// `StructUnionListList /* Vec<T>::Push */: Comma StructUnionGroup StructUnionListList;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_union_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _struct_union_group: &ParseTreeType<'t>,
        _struct_union_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut struct_union_list_list =
            pop_item!(self, struct_union_list_list, StructUnionListList, context);
        let struct_union_group = pop_item!(self, struct_union_group, StructUnionGroup, context);
        let comma = pop_item!(self, comma, Comma, context);
        let struct_union_list_list_0_built = StructUnionListList {
            struct_union_group: Box::new(struct_union_group),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        struct_union_list_list.push(struct_union_list_list_0_built);
        self.push(
            ASTType::StructUnionListList(struct_union_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 807:
    ///
    /// `StructUnionListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_union_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_union_list_list_1_built = Vec::new();
        self.push(
            ASTType::StructUnionListList(struct_union_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 808:
    ///
    /// `StructUnionListOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_union_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let struct_union_list_opt_0_built = StructUnionListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::StructUnionListOpt(Some(struct_union_list_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 809:
    ///
    /// `StructUnionListOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_union_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::StructUnionListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 810:
    ///
    /// `StructUnionGroup: StructUnionGroupList /* Vec */ StructUnionGroupGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_union_group(
        &mut self,
        _struct_union_group_list: &ParseTreeType<'t>,
        _struct_union_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_union_group_group = pop_item!(
            self,
            struct_union_group_group,
            StructUnionGroupGroup,
            context
        );
        let struct_union_group_list =
            pop_and_reverse_item!(self, struct_union_group_list, StructUnionGroupList, context);
        let struct_union_group_built = StructUnionGroup {
            struct_union_group_list,
            struct_union_group_group: Box::new(struct_union_group_group),
        };
        // Calling user action here
        self.user_grammar
            .struct_union_group(&struct_union_group_built)?;
        self.push(ASTType::StructUnionGroup(struct_union_group_built), context);
        Ok(())
    }

    /// Semantic action for production 811:
    ///
    /// `StructUnionGroupGroup: LBrace StructUnionList RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_union_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _struct_union_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let struct_union_list = pop_item!(self, struct_union_list, StructUnionList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let struct_union_group_group_0_built = StructUnionGroupGroupLBraceStructUnionListRBrace {
            l_brace: Box::new(l_brace),
            struct_union_list: Box::new(struct_union_list),
            r_brace: Box::new(r_brace),
        };
        let struct_union_group_group_0_built =
            StructUnionGroupGroup::LBraceStructUnionListRBrace(struct_union_group_group_0_built);
        self.push(
            ASTType::StructUnionGroupGroup(struct_union_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 812:
    ///
    /// `StructUnionGroupGroup: StructUnionItem;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_union_group_group_1(&mut self, _struct_union_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_union_item = pop_item!(self, struct_union_item, StructUnionItem, context);
        let struct_union_group_group_1_built = StructUnionGroupGroupStructUnionItem {
            struct_union_item: Box::new(struct_union_item),
        };
        let struct_union_group_group_1_built =
            StructUnionGroupGroup::StructUnionItem(struct_union_group_group_1_built);
        self.push(
            ASTType::StructUnionGroupGroup(struct_union_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 813:
    ///
    /// `StructUnionGroupList /* Vec<T>::Push */: Attribute StructUnionGroupList;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_union_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _struct_union_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut struct_union_group_list =
            pop_item!(self, struct_union_group_list, StructUnionGroupList, context);
        let attribute = pop_item!(self, attribute, Attribute, context);
        let struct_union_group_list_0_built = StructUnionGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        struct_union_group_list.push(struct_union_group_list_0_built);
        self.push(
            ASTType::StructUnionGroupList(struct_union_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 814:
    ///
    /// `StructUnionGroupList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_union_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_union_group_list_1_built = Vec::new();
        self.push(
            ASTType::StructUnionGroupList(struct_union_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 815:
    ///
    /// `StructUnionItem: Identifier Colon ScalarType;`
    ///
    #[parol_runtime::function_name::named]
    fn struct_union_item(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _scalar_type: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scalar_type = pop_item!(self, scalar_type, ScalarType, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let struct_union_item_built = StructUnionItem {
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            scalar_type: Box::new(scalar_type),
        };
        // Calling user action here
        self.user_grammar
            .struct_union_item(&struct_union_item_built)?;
        self.push(ASTType::StructUnionItem(struct_union_item_built), context);
        Ok(())
    }

    /// Semantic action for production 816:
    ///
    /// `InitialDeclaration: Initial StatementBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn initial_declaration(
        &mut self,
        _initial: &ParseTreeType<'t>,
        _statement_block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block = pop_item!(self, statement_block, StatementBlock, context);
        let initial = pop_item!(self, initial, Initial, context);
        let initial_declaration_built = InitialDeclaration {
            initial: Box::new(initial),
            statement_block: Box::new(statement_block),
        };
        // Calling user action here
        self.user_grammar
            .initial_declaration(&initial_declaration_built)?;
        self.push(
            ASTType::InitialDeclaration(initial_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 817:
    ///
    /// `FinalDeclaration: Final StatementBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn final_declaration(
        &mut self,
        _final: &ParseTreeType<'t>,
        _statement_block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block = pop_item!(self, statement_block, StatementBlock, context);
        let r#final = pop_item!(self, r#final, Final, context);
        let final_declaration_built = FinalDeclaration {
            r#final: Box::new(r#final),
            statement_block: Box::new(statement_block),
        };
        // Calling user action here
        self.user_grammar
            .final_declaration(&final_declaration_built)?;
        self.push(ASTType::FinalDeclaration(final_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 818:
    ///
    /// `InstDeclaration: Inst ComponentInstantiation Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_declaration(
        &mut self,
        _inst: &ParseTreeType<'t>,
        _component_instantiation: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let component_instantiation = pop_item!(
            self,
            component_instantiation,
            ComponentInstantiation,
            context
        );
        let inst = pop_item!(self, inst, Inst, context);
        let inst_declaration_built = InstDeclaration {
            inst: Box::new(inst),
            component_instantiation: Box::new(component_instantiation),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .inst_declaration(&inst_declaration_built)?;
        self.push(ASTType::InstDeclaration(inst_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 819:
    ///
    /// `BindDeclaration: Bind ScopedIdentifier LTMinus ComponentInstantiation Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn bind_declaration(
        &mut self,
        _bind: &ParseTreeType<'t>,
        _scoped_identifier: &ParseTreeType<'t>,
        _l_t_minus: &ParseTreeType<'t>,
        _component_instantiation: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let component_instantiation = pop_item!(
            self,
            component_instantiation,
            ComponentInstantiation,
            context
        );
        let l_t_minus = pop_item!(self, l_t_minus, LTMinus, context);
        let scoped_identifier = pop_item!(self, scoped_identifier, ScopedIdentifier, context);
        let bind = pop_item!(self, bind, Bind, context);
        let bind_declaration_built = BindDeclaration {
            bind: Box::new(bind),
            scoped_identifier: Box::new(scoped_identifier),
            l_t_minus: Box::new(l_t_minus),
            component_instantiation: Box::new(component_instantiation),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .bind_declaration(&bind_declaration_built)?;
        self.push(ASTType::BindDeclaration(bind_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 820:
    ///
    /// `ComponentInstantiation: Identifier Colon ComponentInstantiationOpt /* Option */ ScopedIdentifier ComponentInstantiationOpt0 /* Option */ ComponentInstantiationOpt1 /* Option */ ComponentInstantiationOpt2 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn component_instantiation(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _component_instantiation_opt: &ParseTreeType<'t>,
        _scoped_identifier: &ParseTreeType<'t>,
        _component_instantiation_opt0: &ParseTreeType<'t>,
        _component_instantiation_opt1: &ParseTreeType<'t>,
        _component_instantiation_opt2: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let component_instantiation_opt2 = pop_item!(
            self,
            component_instantiation_opt2,
            ComponentInstantiationOpt2,
            context
        );
        let component_instantiation_opt1 = pop_item!(
            self,
            component_instantiation_opt1,
            ComponentInstantiationOpt1,
            context
        );
        let component_instantiation_opt0 = pop_item!(
            self,
            component_instantiation_opt0,
            ComponentInstantiationOpt0,
            context
        );
        let scoped_identifier = pop_item!(self, scoped_identifier, ScopedIdentifier, context);
        let component_instantiation_opt = pop_item!(
            self,
            component_instantiation_opt,
            ComponentInstantiationOpt,
            context
        );
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let component_instantiation_built = ComponentInstantiation {
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            component_instantiation_opt,
            scoped_identifier: Box::new(scoped_identifier),
            component_instantiation_opt0,
            component_instantiation_opt1,
            component_instantiation_opt2,
        };
        // Calling user action here
        self.user_grammar
            .component_instantiation(&component_instantiation_built)?;
        self.push(
            ASTType::ComponentInstantiation(component_instantiation_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 821:
    ///
    /// `ComponentInstantiationOpt2 /* Option<T>::Some */: InstPort;`
    ///
    #[parol_runtime::function_name::named]
    fn component_instantiation_opt2_0(&mut self, _inst_port: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_port = pop_item!(self, inst_port, InstPort, context);
        let component_instantiation_opt2_0_built = ComponentInstantiationOpt2 {
            inst_port: Box::new(inst_port),
        };
        self.push(
            ASTType::ComponentInstantiationOpt2(Some(component_instantiation_opt2_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 822:
    ///
    /// `ComponentInstantiationOpt2 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn component_instantiation_opt2_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ComponentInstantiationOpt2(None), context);
        Ok(())
    }

    /// Semantic action for production 823:
    ///
    /// `ComponentInstantiationOpt1 /* Option<T>::Some */: InstParameter;`
    ///
    #[parol_runtime::function_name::named]
    fn component_instantiation_opt1_0(
        &mut self,
        _inst_parameter: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter = pop_item!(self, inst_parameter, InstParameter, context);
        let component_instantiation_opt1_0_built = ComponentInstantiationOpt1 {
            inst_parameter: Box::new(inst_parameter),
        };
        self.push(
            ASTType::ComponentInstantiationOpt1(Some(component_instantiation_opt1_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 824:
    ///
    /// `ComponentInstantiationOpt1 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn component_instantiation_opt1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ComponentInstantiationOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 825:
    ///
    /// `ComponentInstantiationOpt0 /* Option<T>::Some */: Array;`
    ///
    #[parol_runtime::function_name::named]
    fn component_instantiation_opt0_0(&mut self, _array: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array = pop_item!(self, array, Array, context);
        let component_instantiation_opt0_0_built = ComponentInstantiationOpt0 {
            array: Box::new(array),
        };
        self.push(
            ASTType::ComponentInstantiationOpt0(Some(component_instantiation_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 826:
    ///
    /// `ComponentInstantiationOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn component_instantiation_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ComponentInstantiationOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 827:
    ///
    /// `ComponentInstantiationOpt /* Option<T>::Some */: ClockDomain;`
    ///
    #[parol_runtime::function_name::named]
    fn component_instantiation_opt_0(&mut self, _clock_domain: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let clock_domain = pop_item!(self, clock_domain, ClockDomain, context);
        let component_instantiation_opt_0_built = ComponentInstantiationOpt {
            clock_domain: Box::new(clock_domain),
        };
        self.push(
            ASTType::ComponentInstantiationOpt(Some(component_instantiation_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 828:
    ///
    /// `ComponentInstantiationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn component_instantiation_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ComponentInstantiationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 829:
    ///
    /// `InstParameter: Hash LParen InstParameterOpt /* Option */ RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter(
        &mut self,
        _hash: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _inst_parameter_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let inst_parameter_opt = pop_item!(self, inst_parameter_opt, InstParameterOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let hash = pop_item!(self, hash, Hash, context);
        let inst_parameter_built = InstParameter {
            hash: Box::new(hash),
            l_paren: Box::new(l_paren),
            inst_parameter_opt,
            r_paren: Box::new(r_paren),
        };
        // Calling user action here
        self.user_grammar.inst_parameter(&inst_parameter_built)?;
        self.push(ASTType::InstParameter(inst_parameter_built), context);
        Ok(())
    }

    /// Semantic action for production 830:
    ///
    /// `InstParameterOpt /* Option<T>::Some */: InstParameterList;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_opt_0(&mut self, _inst_parameter_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter_list = pop_item!(self, inst_parameter_list, InstParameterList, context);
        let inst_parameter_opt_0_built = InstParameterOpt {
            inst_parameter_list: Box::new(inst_parameter_list),
        };
        self.push(
            ASTType::InstParameterOpt(Some(inst_parameter_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 831:
    ///
    /// `InstParameterOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstParameterOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 832:
    ///
    /// `InstParameterList: InstParameterGroup InstParameterListList /* Vec */ InstParameterListOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_list(
        &mut self,
        _inst_parameter_group: &ParseTreeType<'t>,
        _inst_parameter_list_list: &ParseTreeType<'t>,
        _inst_parameter_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter_list_opt =
            pop_item!(self, inst_parameter_list_opt, InstParameterListOpt, context);
        let inst_parameter_list_list = pop_and_reverse_item!(
            self,
            inst_parameter_list_list,
            InstParameterListList,
            context
        );
        let inst_parameter_group =
            pop_item!(self, inst_parameter_group, InstParameterGroup, context);
        let inst_parameter_list_built = InstParameterList {
            inst_parameter_group: Box::new(inst_parameter_group),
            inst_parameter_list_list,
            inst_parameter_list_opt,
        };
        // Calling user action here
        self.user_grammar
            .inst_parameter_list(&inst_parameter_list_built)?;
        self.push(
            ASTType::InstParameterList(inst_parameter_list_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 833:
    ///
    /// `InstParameterListList /* Vec<T>::Push */: Comma InstParameterGroup InstParameterListList;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _inst_parameter_group: &ParseTreeType<'t>,
        _inst_parameter_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut inst_parameter_list_list = pop_item!(
            self,
            inst_parameter_list_list,
            InstParameterListList,
            context
        );
        let inst_parameter_group =
            pop_item!(self, inst_parameter_group, InstParameterGroup, context);
        let comma = pop_item!(self, comma, Comma, context);
        let inst_parameter_list_list_0_built = InstParameterListList {
            inst_parameter_group: Box::new(inst_parameter_group),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        inst_parameter_list_list.push(inst_parameter_list_list_0_built);
        self.push(
            ASTType::InstParameterListList(inst_parameter_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 834:
    ///
    /// `InstParameterListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter_list_list_1_built = Vec::new();
        self.push(
            ASTType::InstParameterListList(inst_parameter_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 835:
    ///
    /// `InstParameterListOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let inst_parameter_list_opt_0_built = InstParameterListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::InstParameterListOpt(Some(inst_parameter_list_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 836:
    ///
    /// `InstParameterListOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstParameterListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 837:
    ///
    /// `InstParameterGroup: InstParameterGroupList /* Vec */ InstParameterGroupGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_group(
        &mut self,
        _inst_parameter_group_list: &ParseTreeType<'t>,
        _inst_parameter_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter_group_group = pop_item!(
            self,
            inst_parameter_group_group,
            InstParameterGroupGroup,
            context
        );
        let inst_parameter_group_list = pop_and_reverse_item!(
            self,
            inst_parameter_group_list,
            InstParameterGroupList,
            context
        );
        let inst_parameter_group_built = InstParameterGroup {
            inst_parameter_group_list,
            inst_parameter_group_group: Box::new(inst_parameter_group_group),
        };
        // Calling user action here
        self.user_grammar
            .inst_parameter_group(&inst_parameter_group_built)?;
        self.push(
            ASTType::InstParameterGroup(inst_parameter_group_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 838:
    ///
    /// `InstParameterGroupGroup: LBrace InstParameterList RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _inst_parameter_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let inst_parameter_list = pop_item!(self, inst_parameter_list, InstParameterList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let inst_parameter_group_group_0_built =
            InstParameterGroupGroupLBraceInstParameterListRBrace {
                l_brace: Box::new(l_brace),
                inst_parameter_list: Box::new(inst_parameter_list),
                r_brace: Box::new(r_brace),
            };
        let inst_parameter_group_group_0_built =
            InstParameterGroupGroup::LBraceInstParameterListRBrace(
                inst_parameter_group_group_0_built,
            );
        self.push(
            ASTType::InstParameterGroupGroup(inst_parameter_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 839:
    ///
    /// `InstParameterGroupGroup: InstParameterItem;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_group_group_1(
        &mut self,
        _inst_parameter_item: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter_item = pop_item!(self, inst_parameter_item, InstParameterItem, context);
        let inst_parameter_group_group_1_built = InstParameterGroupGroupInstParameterItem {
            inst_parameter_item: Box::new(inst_parameter_item),
        };
        let inst_parameter_group_group_1_built =
            InstParameterGroupGroup::InstParameterItem(inst_parameter_group_group_1_built);
        self.push(
            ASTType::InstParameterGroupGroup(inst_parameter_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 840:
    ///
    /// `InstParameterGroupList /* Vec<T>::Push */: Attribute InstParameterGroupList;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _inst_parameter_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut inst_parameter_group_list = pop_item!(
            self,
            inst_parameter_group_list,
            InstParameterGroupList,
            context
        );
        let attribute = pop_item!(self, attribute, Attribute, context);
        let inst_parameter_group_list_0_built = InstParameterGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        inst_parameter_group_list.push(inst_parameter_group_list_0_built);
        self.push(
            ASTType::InstParameterGroupList(inst_parameter_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 841:
    ///
    /// `InstParameterGroupList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter_group_list_1_built = Vec::new();
        self.push(
            ASTType::InstParameterGroupList(inst_parameter_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 842:
    ///
    /// `InstParameterItem: Identifier InstParameterItemOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_item(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _inst_parameter_item_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_parameter_item_opt =
            pop_item!(self, inst_parameter_item_opt, InstParameterItemOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let inst_parameter_item_built = InstParameterItem {
            identifier: Box::new(identifier),
            inst_parameter_item_opt,
        };
        // Calling user action here
        self.user_grammar
            .inst_parameter_item(&inst_parameter_item_built)?;
        self.push(
            ASTType::InstParameterItem(inst_parameter_item_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 843:
    ///
    /// `InstParameterItemOpt /* Option<T>::Some */: Colon Expression;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_item_opt_0(
        &mut self,
        _colon: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let colon = pop_item!(self, colon, Colon, context);
        let inst_parameter_item_opt_0_built = InstParameterItemOpt {
            colon: Box::new(colon),
            expression: Box::new(expression),
        };
        self.push(
            ASTType::InstParameterItemOpt(Some(inst_parameter_item_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 844:
    ///
    /// `InstParameterItemOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_parameter_item_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstParameterItemOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 845:
    ///
    /// `InstPort: LParen InstPortOpt /* Option */ RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_port(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _inst_port_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let inst_port_opt = pop_item!(self, inst_port_opt, InstPortOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let inst_port_built = InstPort {
            l_paren: Box::new(l_paren),
            inst_port_opt,
            r_paren: Box::new(r_paren),
        };
        // Calling user action here
        self.user_grammar.inst_port(&inst_port_built)?;
        self.push(ASTType::InstPort(inst_port_built), context);
        Ok(())
    }

    /// Semantic action for production 846:
    ///
    /// `InstPortOpt /* Option<T>::Some */: InstPortList;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_opt_0(&mut self, _inst_port_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_port_list = pop_item!(self, inst_port_list, InstPortList, context);
        let inst_port_opt_0_built = InstPortOpt {
            inst_port_list: Box::new(inst_port_list),
        };
        self.push(ASTType::InstPortOpt(Some(inst_port_opt_0_built)), context);
        Ok(())
    }

    /// Semantic action for production 847:
    ///
    /// `InstPortOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstPortOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 848:
    ///
    /// `InstPortList: InstPortGroup InstPortListList /* Vec */ InstPortListOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_list(
        &mut self,
        _inst_port_group: &ParseTreeType<'t>,
        _inst_port_list_list: &ParseTreeType<'t>,
        _inst_port_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_port_list_opt = pop_item!(self, inst_port_list_opt, InstPortListOpt, context);
        let inst_port_list_list =
            pop_and_reverse_item!(self, inst_port_list_list, InstPortListList, context);
        let inst_port_group = pop_item!(self, inst_port_group, InstPortGroup, context);
        let inst_port_list_built = InstPortList {
            inst_port_group: Box::new(inst_port_group),
            inst_port_list_list,
            inst_port_list_opt,
        };
        // Calling user action here
        self.user_grammar.inst_port_list(&inst_port_list_built)?;
        self.push(ASTType::InstPortList(inst_port_list_built), context);
        Ok(())
    }

    /// Semantic action for production 849:
    ///
    /// `InstPortListList /* Vec<T>::Push */: Comma InstPortGroup InstPortListList;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _inst_port_group: &ParseTreeType<'t>,
        _inst_port_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut inst_port_list_list =
            pop_item!(self, inst_port_list_list, InstPortListList, context);
        let inst_port_group = pop_item!(self, inst_port_group, InstPortGroup, context);
        let comma = pop_item!(self, comma, Comma, context);
        let inst_port_list_list_0_built = InstPortListList {
            inst_port_group: Box::new(inst_port_group),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        inst_port_list_list.push(inst_port_list_list_0_built);
        self.push(ASTType::InstPortListList(inst_port_list_list), context);
        Ok(())
    }

    /// Semantic action for production 850:
    ///
    /// `InstPortListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_port_list_list_1_built = Vec::new();
        self.push(
            ASTType::InstPortListList(inst_port_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 851:
    ///
    /// `InstPortListOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let inst_port_list_opt_0_built = InstPortListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::InstPortListOpt(Some(inst_port_list_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 852:
    ///
    /// `InstPortListOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstPortListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 853:
    ///
    /// `InstPortGroup: InstPortGroupList /* Vec */ InstPortGroupGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_group(
        &mut self,
        _inst_port_group_list: &ParseTreeType<'t>,
        _inst_port_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_port_group_group =
            pop_item!(self, inst_port_group_group, InstPortGroupGroup, context);
        let inst_port_group_list =
            pop_and_reverse_item!(self, inst_port_group_list, InstPortGroupList, context);
        let inst_port_group_built = InstPortGroup {
            inst_port_group_list,
            inst_port_group_group: Box::new(inst_port_group_group),
        };
        // Calling user action here
        self.user_grammar.inst_port_group(&inst_port_group_built)?;
        self.push(ASTType::InstPortGroup(inst_port_group_built), context);
        Ok(())
    }

    /// Semantic action for production 854:
    ///
    /// `InstPortGroupGroup: LBrace InstPortList RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _inst_port_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let inst_port_list = pop_item!(self, inst_port_list, InstPortList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let inst_port_group_group_0_built = InstPortGroupGroupLBraceInstPortListRBrace {
            l_brace: Box::new(l_brace),
            inst_port_list: Box::new(inst_port_list),
            r_brace: Box::new(r_brace),
        };
        let inst_port_group_group_0_built =
            InstPortGroupGroup::LBraceInstPortListRBrace(inst_port_group_group_0_built);
        self.push(
            ASTType::InstPortGroupGroup(inst_port_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 855:
    ///
    /// `InstPortGroupGroup: InstPortItem;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_group_group_1(&mut self, _inst_port_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_port_item = pop_item!(self, inst_port_item, InstPortItem, context);
        let inst_port_group_group_1_built = InstPortGroupGroupInstPortItem {
            inst_port_item: Box::new(inst_port_item),
        };
        let inst_port_group_group_1_built =
            InstPortGroupGroup::InstPortItem(inst_port_group_group_1_built);
        self.push(
            ASTType::InstPortGroupGroup(inst_port_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 856:
    ///
    /// `InstPortGroupList /* Vec<T>::Push */: Attribute InstPortGroupList;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _inst_port_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut inst_port_group_list =
            pop_item!(self, inst_port_group_list, InstPortGroupList, context);
        let attribute = pop_item!(self, attribute, Attribute, context);
        let inst_port_group_list_0_built = InstPortGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        inst_port_group_list.push(inst_port_group_list_0_built);
        self.push(ASTType::InstPortGroupList(inst_port_group_list), context);
        Ok(())
    }

    /// Semantic action for production 857:
    ///
    /// `InstPortGroupList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_port_group_list_1_built = Vec::new();
        self.push(
            ASTType::InstPortGroupList(inst_port_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 858:
    ///
    /// `InstPortItem: Identifier InstPortItemOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_item(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _inst_port_item_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_port_item_opt = pop_item!(self, inst_port_item_opt, InstPortItemOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let inst_port_item_built = InstPortItem {
            identifier: Box::new(identifier),
            inst_port_item_opt,
        };
        // Calling user action here
        self.user_grammar.inst_port_item(&inst_port_item_built)?;
        self.push(ASTType::InstPortItem(inst_port_item_built), context);
        Ok(())
    }

    /// Semantic action for production 859:
    ///
    /// `InstPortItemOpt /* Option<T>::Some */: Colon Expression;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_item_opt_0(
        &mut self,
        _colon: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let colon = pop_item!(self, colon, Colon, context);
        let inst_port_item_opt_0_built = InstPortItemOpt {
            colon: Box::new(colon),
            expression: Box::new(expression),
        };
        self.push(
            ASTType::InstPortItemOpt(Some(inst_port_item_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 860:
    ///
    /// `InstPortItemOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn inst_port_item_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InstPortItemOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 861:
    ///
    /// `WithParameter: Hash LParen WithParameterOpt /* Option */ RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter(
        &mut self,
        _hash: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _with_parameter_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let with_parameter_opt = pop_item!(self, with_parameter_opt, WithParameterOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let hash = pop_item!(self, hash, Hash, context);
        let with_parameter_built = WithParameter {
            hash: Box::new(hash),
            l_paren: Box::new(l_paren),
            with_parameter_opt,
            r_paren: Box::new(r_paren),
        };
        // Calling user action here
        self.user_grammar.with_parameter(&with_parameter_built)?;
        self.push(ASTType::WithParameter(with_parameter_built), context);
        Ok(())
    }

    /// Semantic action for production 862:
    ///
    /// `WithParameterOpt /* Option<T>::Some */: WithParameterList;`
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_opt_0(&mut self, _with_parameter_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_list = pop_item!(self, with_parameter_list, WithParameterList, context);
        let with_parameter_opt_0_built = WithParameterOpt {
            with_parameter_list: Box::new(with_parameter_list),
        };
        self.push(
            ASTType::WithParameterOpt(Some(with_parameter_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 863:
    ///
    /// `WithParameterOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::WithParameterOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 864:
    ///
    /// `WithParameterList: WithParameterGroup WithParameterListList /* Vec */ WithParameterListOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list(
        &mut self,
        _with_parameter_group: &ParseTreeType<'t>,
        _with_parameter_list_list: &ParseTreeType<'t>,
        _with_parameter_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_list_opt =
            pop_item!(self, with_parameter_list_opt, WithParameterListOpt, context);
        let with_parameter_list_list = pop_and_reverse_item!(
            self,
            with_parameter_list_list,
            WithParameterListList,
            context
        );
        let with_parameter_group =
            pop_item!(self, with_parameter_group, WithParameterGroup, context);
        let with_parameter_list_built = WithParameterList {
            with_parameter_group: Box::new(with_parameter_group),
            with_parameter_list_list,
            with_parameter_list_opt,
        };
        // Calling user action here
        self.user_grammar
            .with_parameter_list(&with_parameter_list_built)?;
        self.push(
            ASTType::WithParameterList(with_parameter_list_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 865:
    ///
    /// `WithParameterListList /* Vec<T>::Push */: Comma WithParameterGroup WithParameterListList;`
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _with_parameter_group: &ParseTreeType<'t>,
        _with_parameter_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut with_parameter_list_list = pop_item!(
            self,
            with_parameter_list_list,
            WithParameterListList,
            context
        );
        let with_parameter_group =
            pop_item!(self, with_parameter_group, WithParameterGroup, context);
        let comma = pop_item!(self, comma, Comma, context);
        let with_parameter_list_list_0_built = WithParameterListList {
            with_parameter_group: Box::new(with_parameter_group),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        with_parameter_list_list.push(with_parameter_list_list_0_built);
        self.push(
            ASTType::WithParameterListList(with_parameter_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 866:
    ///
    /// `WithParameterListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_list_list_1_built = Vec::new();
        self.push(
            ASTType::WithParameterListList(with_parameter_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 867:
    ///
    /// `WithParameterListOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let with_parameter_list_opt_0_built = WithParameterListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::WithParameterListOpt(Some(with_parameter_list_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 868:
    ///
    /// `WithParameterListOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::WithParameterListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 869:
    ///
    /// `WithParameterGroup: WithParameterGroupList /* Vec */ WithParameterGroupGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_group(
        &mut self,
        _with_parameter_group_list: &ParseTreeType<'t>,
        _with_parameter_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_group_group = pop_item!(
            self,
            with_parameter_group_group,
            WithParameterGroupGroup,
            context
        );
        let with_parameter_group_list = pop_and_reverse_item!(
            self,
            with_parameter_group_list,
            WithParameterGroupList,
            context
        );
        let with_parameter_group_built = WithParameterGroup {
            with_parameter_group_list,
            with_parameter_group_group: Box::new(with_parameter_group_group),
        };
        // Calling user action here
        self.user_grammar
            .with_parameter_group(&with_parameter_group_built)?;
        self.push(
            ASTType::WithParameterGroup(with_parameter_group_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 870:
    ///
    /// `WithParameterGroupGroup: LBrace WithParameterList RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _with_parameter_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let with_parameter_list = pop_item!(self, with_parameter_list, WithParameterList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let with_parameter_group_group_0_built =
            WithParameterGroupGroupLBraceWithParameterListRBrace {
                l_brace: Box::new(l_brace),
                with_parameter_list: Box::new(with_parameter_list),
                r_brace: Box::new(r_brace),
            };
        let with_parameter_group_group_0_built =
            WithParameterGroupGroup::LBraceWithParameterListRBrace(
                with_parameter_group_group_0_built,
            );
        self.push(
            ASTType::WithParameterGroupGroup(with_parameter_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 871:
    ///
    /// `WithParameterGroupGroup: WithParameterItem;`
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_group_group_1(
        &mut self,
        _with_parameter_item: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_item = pop_item!(self, with_parameter_item, WithParameterItem, context);
        let with_parameter_group_group_1_built = WithParameterGroupGroupWithParameterItem {
            with_parameter_item: Box::new(with_parameter_item),
        };
        let with_parameter_group_group_1_built =
            WithParameterGroupGroup::WithParameterItem(with_parameter_group_group_1_built);
        self.push(
            ASTType::WithParameterGroupGroup(with_parameter_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 872:
    ///
    /// `WithParameterGroupList /* Vec<T>::Push */: Attribute WithParameterGroupList;`
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _with_parameter_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut with_parameter_group_list = pop_item!(
            self,
            with_parameter_group_list,
            WithParameterGroupList,
            context
        );
        let attribute = pop_item!(self, attribute, Attribute, context);
        let with_parameter_group_list_0_built = WithParameterGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        with_parameter_group_list.push(with_parameter_group_list_0_built);
        self.push(
            ASTType::WithParameterGroupList(with_parameter_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 873:
    ///
    /// `WithParameterGroupList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_group_list_1_built = Vec::new();
        self.push(
            ASTType::WithParameterGroupList(with_parameter_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 874:
    ///
    /// `WithParameterItem: WithParameterItemGroup Identifier Colon WithParameterItemGroup0 WithParameterItemOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item(
        &mut self,
        _with_parameter_item_group: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _with_parameter_item_group0: &ParseTreeType<'t>,
        _with_parameter_item_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter_item_opt =
            pop_item!(self, with_parameter_item_opt, WithParameterItemOpt, context);
        let with_parameter_item_group0 = pop_item!(
            self,
            with_parameter_item_group0,
            WithParameterItemGroup0,
            context
        );
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let with_parameter_item_group = pop_item!(
            self,
            with_parameter_item_group,
            WithParameterItemGroup,
            context
        );
        let with_parameter_item_built = WithParameterItem {
            with_parameter_item_group: Box::new(with_parameter_item_group),
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            with_parameter_item_group0: Box::new(with_parameter_item_group0),
            with_parameter_item_opt,
        };
        // Calling user action here
        self.user_grammar
            .with_parameter_item(&with_parameter_item_built)?;
        self.push(
            ASTType::WithParameterItem(with_parameter_item_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 875:
    ///
    /// `WithParameterItemGroup0: ArrayType;`
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item_group0_0(&mut self, _array_type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_type = pop_item!(self, array_type, ArrayType, context);
        let with_parameter_item_group0_0_built = WithParameterItemGroup0ArrayType {
            array_type: Box::new(array_type),
        };
        let with_parameter_item_group0_0_built =
            WithParameterItemGroup0::ArrayType(with_parameter_item_group0_0_built);
        self.push(
            ASTType::WithParameterItemGroup0(with_parameter_item_group0_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 876:
    ///
    /// `WithParameterItemGroup0: Type;`
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item_group0_1(&mut self, _type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#type = pop_item!(self, r#type, Type, context);
        let with_parameter_item_group0_1_built = WithParameterItemGroup0Type {
            r#type: Box::new(r#type),
        };
        let with_parameter_item_group0_1_built =
            WithParameterItemGroup0::Type(with_parameter_item_group0_1_built);
        self.push(
            ASTType::WithParameterItemGroup0(with_parameter_item_group0_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 877:
    ///
    /// `WithParameterItemGroup: Param;`
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item_group_0(&mut self, _param: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let param = pop_item!(self, param, Param, context);
        let with_parameter_item_group_0_built = WithParameterItemGroupParam {
            param: Box::new(param),
        };
        let with_parameter_item_group_0_built =
            WithParameterItemGroup::Param(with_parameter_item_group_0_built);
        self.push(
            ASTType::WithParameterItemGroup(with_parameter_item_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 878:
    ///
    /// `WithParameterItemGroup: Const;`
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item_group_1(&mut self, _const: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#const = pop_item!(self, r#const, Const, context);
        let with_parameter_item_group_1_built = WithParameterItemGroupConst {
            r#const: Box::new(r#const),
        };
        let with_parameter_item_group_1_built =
            WithParameterItemGroup::Const(with_parameter_item_group_1_built);
        self.push(
            ASTType::WithParameterItemGroup(with_parameter_item_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 879:
    ///
    /// `WithParameterItemOpt /* Option<T>::Some */: Equ Expression;`
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item_opt_0(
        &mut self,
        _equ: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let equ = pop_item!(self, equ, Equ, context);
        let with_parameter_item_opt_0_built = WithParameterItemOpt {
            equ: Box::new(equ),
            expression: Box::new(expression),
        };
        self.push(
            ASTType::WithParameterItemOpt(Some(with_parameter_item_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 880:
    ///
    /// `WithParameterItemOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn with_parameter_item_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::WithParameterItemOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 881:
    ///
    /// `GenericBound: Type;`
    ///
    #[parol_runtime::function_name::named]
    fn generic_bound_0(&mut self, _type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#type = pop_item!(self, r#type, Type, context);
        let generic_bound_0_built = GenericBoundType {
            r#type: Box::new(r#type),
        };
        let generic_bound_0_built = GenericBound::Type(generic_bound_0_built);
        // Calling user action here
        self.user_grammar.generic_bound(&generic_bound_0_built)?;
        self.push(ASTType::GenericBound(generic_bound_0_built), context);
        Ok(())
    }

    /// Semantic action for production 882:
    ///
    /// `GenericBound: Inst ScopedIdentifier;`
    ///
    #[parol_runtime::function_name::named]
    fn generic_bound_1(
        &mut self,
        _inst: &ParseTreeType<'t>,
        _scoped_identifier: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_identifier = pop_item!(self, scoped_identifier, ScopedIdentifier, context);
        let inst = pop_item!(self, inst, Inst, context);
        let generic_bound_1_built = GenericBoundInstScopedIdentifier {
            inst: Box::new(inst),
            scoped_identifier: Box::new(scoped_identifier),
        };
        let generic_bound_1_built = GenericBound::InstScopedIdentifier(generic_bound_1_built);
        // Calling user action here
        self.user_grammar.generic_bound(&generic_bound_1_built)?;
        self.push(ASTType::GenericBound(generic_bound_1_built), context);
        Ok(())
    }

    /// Semantic action for production 883:
    ///
    /// `GenericBound: GenericProtoBound;`
    ///
    #[parol_runtime::function_name::named]
    fn generic_bound_2(&mut self, _generic_proto_bound: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let generic_proto_bound = pop_item!(self, generic_proto_bound, GenericProtoBound, context);
        let generic_bound_2_built = GenericBoundGenericProtoBound {
            generic_proto_bound: Box::new(generic_proto_bound),
        };
        let generic_bound_2_built = GenericBound::GenericProtoBound(generic_bound_2_built);
        // Calling user action here
        self.user_grammar.generic_bound(&generic_bound_2_built)?;
        self.push(ASTType::GenericBound(generic_bound_2_built), context);
        Ok(())
    }

    /// Semantic action for production 884:
    ///
    /// `WithGenericParameter: ColonColonLAngle WithGenericParameterList RAngle;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_parameter(
        &mut self,
        _colon_colon_l_angle: &ParseTreeType<'t>,
        _with_generic_parameter_list: &ParseTreeType<'t>,
        _r_angle: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_angle = pop_item!(self, r_angle, RAngle, context);
        let with_generic_parameter_list = pop_item!(
            self,
            with_generic_parameter_list,
            WithGenericParameterList,
            context
        );
        let colon_colon_l_angle = pop_item!(self, colon_colon_l_angle, ColonColonLAngle, context);
        let with_generic_parameter_built = WithGenericParameter {
            colon_colon_l_angle: Box::new(colon_colon_l_angle),
            with_generic_parameter_list: Box::new(with_generic_parameter_list),
            r_angle: Box::new(r_angle),
        };
        // Calling user action here
        self.user_grammar
            .with_generic_parameter(&with_generic_parameter_built)?;
        self.push(
            ASTType::WithGenericParameter(with_generic_parameter_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 885:
    ///
    /// `WithGenericParameterList: WithGenericParameterItem WithGenericParameterListList /* Vec */ WithGenericParameterListOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_parameter_list(
        &mut self,
        _with_generic_parameter_item: &ParseTreeType<'t>,
        _with_generic_parameter_list_list: &ParseTreeType<'t>,
        _with_generic_parameter_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_generic_parameter_list_opt = pop_item!(
            self,
            with_generic_parameter_list_opt,
            WithGenericParameterListOpt,
            context
        );
        let with_generic_parameter_list_list = pop_and_reverse_item!(
            self,
            with_generic_parameter_list_list,
            WithGenericParameterListList,
            context
        );
        let with_generic_parameter_item = pop_item!(
            self,
            with_generic_parameter_item,
            WithGenericParameterItem,
            context
        );
        let with_generic_parameter_list_built = WithGenericParameterList {
            with_generic_parameter_item: Box::new(with_generic_parameter_item),
            with_generic_parameter_list_list,
            with_generic_parameter_list_opt,
        };
        // Calling user action here
        self.user_grammar
            .with_generic_parameter_list(&with_generic_parameter_list_built)?;
        self.push(
            ASTType::WithGenericParameterList(with_generic_parameter_list_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 886:
    ///
    /// `WithGenericParameterListList /* Vec<T>::Push */: Comma WithGenericParameterItem WithGenericParameterListList;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_parameter_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _with_generic_parameter_item: &ParseTreeType<'t>,
        _with_generic_parameter_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut with_generic_parameter_list_list = pop_item!(
            self,
            with_generic_parameter_list_list,
            WithGenericParameterListList,
            context
        );
        let with_generic_parameter_item = pop_item!(
            self,
            with_generic_parameter_item,
            WithGenericParameterItem,
            context
        );
        let comma = pop_item!(self, comma, Comma, context);
        let with_generic_parameter_list_list_0_built = WithGenericParameterListList {
            with_generic_parameter_item: Box::new(with_generic_parameter_item),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        with_generic_parameter_list_list.push(with_generic_parameter_list_list_0_built);
        self.push(
            ASTType::WithGenericParameterListList(with_generic_parameter_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 887:
    ///
    /// `WithGenericParameterListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_parameter_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_generic_parameter_list_list_1_built = Vec::new();
        self.push(
            ASTType::WithGenericParameterListList(with_generic_parameter_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 888:
    ///
    /// `WithGenericParameterListOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_parameter_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let with_generic_parameter_list_opt_0_built = WithGenericParameterListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::WithGenericParameterListOpt(Some(with_generic_parameter_list_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 889:
    ///
    /// `WithGenericParameterListOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_parameter_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::WithGenericParameterListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 890:
    ///
    /// `WithGenericParameterItem: Identifier Colon GenericBound WithGenericParameterItemOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_parameter_item(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _generic_bound: &ParseTreeType<'t>,
        _with_generic_parameter_item_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_generic_parameter_item_opt = pop_item!(
            self,
            with_generic_parameter_item_opt,
            WithGenericParameterItemOpt,
            context
        );
        let generic_bound = pop_item!(self, generic_bound, GenericBound, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let with_generic_parameter_item_built = WithGenericParameterItem {
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            generic_bound: Box::new(generic_bound),
            with_generic_parameter_item_opt,
        };
        // Calling user action here
        self.user_grammar
            .with_generic_parameter_item(&with_generic_parameter_item_built)?;
        self.push(
            ASTType::WithGenericParameterItem(with_generic_parameter_item_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 891:
    ///
    /// `WithGenericParameterItemOpt /* Option<T>::Some */: Equ WithGenericArgumentItem;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_parameter_item_opt_0(
        &mut self,
        _equ: &ParseTreeType<'t>,
        _with_generic_argument_item: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_generic_argument_item = pop_item!(
            self,
            with_generic_argument_item,
            WithGenericArgumentItem,
            context
        );
        let equ = pop_item!(self, equ, Equ, context);
        let with_generic_parameter_item_opt_0_built = WithGenericParameterItemOpt {
            equ: Box::new(equ),
            with_generic_argument_item: Box::new(with_generic_argument_item),
        };
        self.push(
            ASTType::WithGenericParameterItemOpt(Some(with_generic_parameter_item_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 892:
    ///
    /// `WithGenericParameterItemOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_parameter_item_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::WithGenericParameterItemOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 893:
    ///
    /// `GenericProtoBound: ScopedIdentifier;`
    ///
    #[parol_runtime::function_name::named]
    fn generic_proto_bound_0(&mut self, _scoped_identifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_identifier = pop_item!(self, scoped_identifier, ScopedIdentifier, context);
        let generic_proto_bound_0_built = GenericProtoBoundScopedIdentifier {
            scoped_identifier: Box::new(scoped_identifier),
        };
        let generic_proto_bound_0_built =
            GenericProtoBound::ScopedIdentifier(generic_proto_bound_0_built);
        // Calling user action here
        self.user_grammar
            .generic_proto_bound(&generic_proto_bound_0_built)?;
        self.push(
            ASTType::GenericProtoBound(generic_proto_bound_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 894:
    ///
    /// `GenericProtoBound: FixedType;`
    ///
    #[parol_runtime::function_name::named]
    fn generic_proto_bound_1(&mut self, _fixed_type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fixed_type = pop_item!(self, fixed_type, FixedType, context);
        let generic_proto_bound_1_built = GenericProtoBoundFixedType {
            fixed_type: Box::new(fixed_type),
        };
        let generic_proto_bound_1_built = GenericProtoBound::FixedType(generic_proto_bound_1_built);
        // Calling user action here
        self.user_grammar
            .generic_proto_bound(&generic_proto_bound_1_built)?;
        self.push(
            ASTType::GenericProtoBound(generic_proto_bound_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 895:
    ///
    /// `WithGenericArgument: ColonColonLAngle WithGenericArgumentOpt /* Option */ RAngle;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_argument(
        &mut self,
        _colon_colon_l_angle: &ParseTreeType<'t>,
        _with_generic_argument_opt: &ParseTreeType<'t>,
        _r_angle: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_angle = pop_item!(self, r_angle, RAngle, context);
        let with_generic_argument_opt = pop_item!(
            self,
            with_generic_argument_opt,
            WithGenericArgumentOpt,
            context
        );
        let colon_colon_l_angle = pop_item!(self, colon_colon_l_angle, ColonColonLAngle, context);
        let with_generic_argument_built = WithGenericArgument {
            colon_colon_l_angle: Box::new(colon_colon_l_angle),
            with_generic_argument_opt,
            r_angle: Box::new(r_angle),
        };
        // Calling user action here
        self.user_grammar
            .with_generic_argument(&with_generic_argument_built)?;
        self.push(
            ASTType::WithGenericArgument(with_generic_argument_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 896:
    ///
    /// `WithGenericArgumentOpt /* Option<T>::Some */: WithGenericArgumentList;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_argument_opt_0(
        &mut self,
        _with_generic_argument_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_generic_argument_list = pop_item!(
            self,
            with_generic_argument_list,
            WithGenericArgumentList,
            context
        );
        let with_generic_argument_opt_0_built = WithGenericArgumentOpt {
            with_generic_argument_list: Box::new(with_generic_argument_list),
        };
        self.push(
            ASTType::WithGenericArgumentOpt(Some(with_generic_argument_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 897:
    ///
    /// `WithGenericArgumentOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_argument_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::WithGenericArgumentOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 898:
    ///
    /// `WithGenericArgumentList: WithGenericArgumentItem WithGenericArgumentListList /* Vec */ WithGenericArgumentListOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_argument_list(
        &mut self,
        _with_generic_argument_item: &ParseTreeType<'t>,
        _with_generic_argument_list_list: &ParseTreeType<'t>,
        _with_generic_argument_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_generic_argument_list_opt = pop_item!(
            self,
            with_generic_argument_list_opt,
            WithGenericArgumentListOpt,
            context
        );
        let with_generic_argument_list_list = pop_and_reverse_item!(
            self,
            with_generic_argument_list_list,
            WithGenericArgumentListList,
            context
        );
        let with_generic_argument_item = pop_item!(
            self,
            with_generic_argument_item,
            WithGenericArgumentItem,
            context
        );
        let with_generic_argument_list_built = WithGenericArgumentList {
            with_generic_argument_item: Box::new(with_generic_argument_item),
            with_generic_argument_list_list,
            with_generic_argument_list_opt,
        };
        // Calling user action here
        self.user_grammar
            .with_generic_argument_list(&with_generic_argument_list_built)?;
        self.push(
            ASTType::WithGenericArgumentList(with_generic_argument_list_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 899:
    ///
    /// `WithGenericArgumentListList /* Vec<T>::Push */: Comma WithGenericArgumentItem WithGenericArgumentListList;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_argument_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _with_generic_argument_item: &ParseTreeType<'t>,
        _with_generic_argument_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut with_generic_argument_list_list = pop_item!(
            self,
            with_generic_argument_list_list,
            WithGenericArgumentListList,
            context
        );
        let with_generic_argument_item = pop_item!(
            self,
            with_generic_argument_item,
            WithGenericArgumentItem,
            context
        );
        let comma = pop_item!(self, comma, Comma, context);
        let with_generic_argument_list_list_0_built = WithGenericArgumentListList {
            with_generic_argument_item: Box::new(with_generic_argument_item),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        with_generic_argument_list_list.push(with_generic_argument_list_list_0_built);
        self.push(
            ASTType::WithGenericArgumentListList(with_generic_argument_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 900:
    ///
    /// `WithGenericArgumentListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_argument_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_generic_argument_list_list_1_built = Vec::new();
        self.push(
            ASTType::WithGenericArgumentListList(with_generic_argument_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 901:
    ///
    /// `WithGenericArgumentListOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_argument_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let with_generic_argument_list_opt_0_built = WithGenericArgumentListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::WithGenericArgumentListOpt(Some(with_generic_argument_list_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 902:
    ///
    /// `WithGenericArgumentListOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_argument_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::WithGenericArgumentListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 903:
    ///
    /// `WithGenericArgumentItem: GenericArgIdentifier;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_argument_item_0(
        &mut self,
        _generic_arg_identifier: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let generic_arg_identifier =
            pop_item!(self, generic_arg_identifier, GenericArgIdentifier, context);
        let with_generic_argument_item_0_built = WithGenericArgumentItemGenericArgIdentifier {
            generic_arg_identifier: Box::new(generic_arg_identifier),
        };
        let with_generic_argument_item_0_built =
            WithGenericArgumentItem::GenericArgIdentifier(with_generic_argument_item_0_built);
        // Calling user action here
        self.user_grammar
            .with_generic_argument_item(&with_generic_argument_item_0_built)?;
        self.push(
            ASTType::WithGenericArgumentItem(with_generic_argument_item_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 904:
    ///
    /// `WithGenericArgumentItem: FixedType;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_argument_item_1(&mut self, _fixed_type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let fixed_type = pop_item!(self, fixed_type, FixedType, context);
        let with_generic_argument_item_1_built = WithGenericArgumentItemFixedType {
            fixed_type: Box::new(fixed_type),
        };
        let with_generic_argument_item_1_built =
            WithGenericArgumentItem::FixedType(with_generic_argument_item_1_built);
        // Calling user action here
        self.user_grammar
            .with_generic_argument_item(&with_generic_argument_item_1_built)?;
        self.push(
            ASTType::WithGenericArgumentItem(with_generic_argument_item_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 905:
    ///
    /// `WithGenericArgumentItem: Number;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_argument_item_2(&mut self, _number: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let number = pop_item!(self, number, Number, context);
        let with_generic_argument_item_2_built = WithGenericArgumentItemNumber {
            number: Box::new(number),
        };
        let with_generic_argument_item_2_built =
            WithGenericArgumentItem::Number(with_generic_argument_item_2_built);
        // Calling user action here
        self.user_grammar
            .with_generic_argument_item(&with_generic_argument_item_2_built)?;
        self.push(
            ASTType::WithGenericArgumentItem(with_generic_argument_item_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 906:
    ///
    /// `WithGenericArgumentItem: BooleanLiteral;`
    ///
    #[parol_runtime::function_name::named]
    fn with_generic_argument_item_3(&mut self, _boolean_literal: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let boolean_literal = pop_item!(self, boolean_literal, BooleanLiteral, context);
        let with_generic_argument_item_3_built = WithGenericArgumentItemBooleanLiteral {
            boolean_literal: Box::new(boolean_literal),
        };
        let with_generic_argument_item_3_built =
            WithGenericArgumentItem::BooleanLiteral(with_generic_argument_item_3_built);
        // Calling user action here
        self.user_grammar
            .with_generic_argument_item(&with_generic_argument_item_3_built)?;
        self.push(
            ASTType::WithGenericArgumentItem(with_generic_argument_item_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 907:
    ///
    /// `PortDeclaration: LParen PortDeclarationOpt /* Option */ RParen;`
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration(
        &mut self,
        _l_paren: &ParseTreeType<'t>,
        _port_declaration_opt: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let port_declaration_opt =
            pop_item!(self, port_declaration_opt, PortDeclarationOpt, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let port_declaration_built = PortDeclaration {
            l_paren: Box::new(l_paren),
            port_declaration_opt,
            r_paren: Box::new(r_paren),
        };
        // Calling user action here
        self.user_grammar
            .port_declaration(&port_declaration_built)?;
        self.push(ASTType::PortDeclaration(port_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 908:
    ///
    /// `PortDeclarationOpt /* Option<T>::Some */: PortDeclarationList;`
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_opt_0(&mut self, _port_declaration_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration_list =
            pop_item!(self, port_declaration_list, PortDeclarationList, context);
        let port_declaration_opt_0_built = PortDeclarationOpt {
            port_declaration_list: Box::new(port_declaration_list),
        };
        self.push(
            ASTType::PortDeclarationOpt(Some(port_declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 909:
    ///
    /// `PortDeclarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::PortDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 910:
    ///
    /// `PortDeclarationList: PortDeclarationGroup PortDeclarationListList /* Vec */ PortDeclarationListOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_list(
        &mut self,
        _port_declaration_group: &ParseTreeType<'t>,
        _port_declaration_list_list: &ParseTreeType<'t>,
        _port_declaration_list_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration_list_opt = pop_item!(
            self,
            port_declaration_list_opt,
            PortDeclarationListOpt,
            context
        );
        let port_declaration_list_list = pop_and_reverse_item!(
            self,
            port_declaration_list_list,
            PortDeclarationListList,
            context
        );
        let port_declaration_group =
            pop_item!(self, port_declaration_group, PortDeclarationGroup, context);
        let port_declaration_list_built = PortDeclarationList {
            port_declaration_group: Box::new(port_declaration_group),
            port_declaration_list_list,
            port_declaration_list_opt,
        };
        // Calling user action here
        self.user_grammar
            .port_declaration_list(&port_declaration_list_built)?;
        self.push(
            ASTType::PortDeclarationList(port_declaration_list_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 911:
    ///
    /// `PortDeclarationListList /* Vec<T>::Push */: Comma PortDeclarationGroup PortDeclarationListList;`
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_list_list_0(
        &mut self,
        _comma: &ParseTreeType<'t>,
        _port_declaration_group: &ParseTreeType<'t>,
        _port_declaration_list_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut port_declaration_list_list = pop_item!(
            self,
            port_declaration_list_list,
            PortDeclarationListList,
            context
        );
        let port_declaration_group =
            pop_item!(self, port_declaration_group, PortDeclarationGroup, context);
        let comma = pop_item!(self, comma, Comma, context);
        let port_declaration_list_list_0_built = PortDeclarationListList {
            port_declaration_group: Box::new(port_declaration_group),
            comma: Box::new(comma),
        };
        // Add an element to the vector
        port_declaration_list_list.push(port_declaration_list_list_0_built);
        self.push(
            ASTType::PortDeclarationListList(port_declaration_list_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 912:
    ///
    /// `PortDeclarationListList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_list_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration_list_list_1_built = Vec::new();
        self.push(
            ASTType::PortDeclarationListList(port_declaration_list_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 913:
    ///
    /// `PortDeclarationListOpt /* Option<T>::Some */: Comma;`
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_list_opt_0(&mut self, _comma: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let comma = pop_item!(self, comma, Comma, context);
        let port_declaration_list_opt_0_built = PortDeclarationListOpt {
            comma: Box::new(comma),
        };
        self.push(
            ASTType::PortDeclarationListOpt(Some(port_declaration_list_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 914:
    ///
    /// `PortDeclarationListOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_list_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::PortDeclarationListOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 915:
    ///
    /// `PortDeclarationGroup: PortDeclarationGroupList /* Vec */ PortDeclarationGroupGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_group(
        &mut self,
        _port_declaration_group_list: &ParseTreeType<'t>,
        _port_declaration_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration_group_group = pop_item!(
            self,
            port_declaration_group_group,
            PortDeclarationGroupGroup,
            context
        );
        let port_declaration_group_list = pop_and_reverse_item!(
            self,
            port_declaration_group_list,
            PortDeclarationGroupList,
            context
        );
        let port_declaration_group_built = PortDeclarationGroup {
            port_declaration_group_list,
            port_declaration_group_group: Box::new(port_declaration_group_group),
        };
        // Calling user action here
        self.user_grammar
            .port_declaration_group(&port_declaration_group_built)?;
        self.push(
            ASTType::PortDeclarationGroup(port_declaration_group_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 916:
    ///
    /// `PortDeclarationGroupGroup: LBrace PortDeclarationList RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _port_declaration_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let port_declaration_list =
            pop_item!(self, port_declaration_list, PortDeclarationList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let port_declaration_group_group_0_built =
            PortDeclarationGroupGroupLBracePortDeclarationListRBrace {
                l_brace: Box::new(l_brace),
                port_declaration_list: Box::new(port_declaration_list),
                r_brace: Box::new(r_brace),
            };
        let port_declaration_group_group_0_built =
            PortDeclarationGroupGroup::LBracePortDeclarationListRBrace(
                port_declaration_group_group_0_built,
            );
        self.push(
            ASTType::PortDeclarationGroupGroup(port_declaration_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 917:
    ///
    /// `PortDeclarationGroupGroup: PortDeclarationItem;`
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_group_group_1(
        &mut self,
        _port_declaration_item: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration_item =
            pop_item!(self, port_declaration_item, PortDeclarationItem, context);
        let port_declaration_group_group_1_built = PortDeclarationGroupGroupPortDeclarationItem {
            port_declaration_item: Box::new(port_declaration_item),
        };
        let port_declaration_group_group_1_built =
            PortDeclarationGroupGroup::PortDeclarationItem(port_declaration_group_group_1_built);
        self.push(
            ASTType::PortDeclarationGroupGroup(port_declaration_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 918:
    ///
    /// `PortDeclarationGroupList /* Vec<T>::Push */: Attribute PortDeclarationGroupList;`
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _port_declaration_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut port_declaration_group_list = pop_item!(
            self,
            port_declaration_group_list,
            PortDeclarationGroupList,
            context
        );
        let attribute = pop_item!(self, attribute, Attribute, context);
        let port_declaration_group_list_0_built = PortDeclarationGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        port_declaration_group_list.push(port_declaration_group_list_0_built);
        self.push(
            ASTType::PortDeclarationGroupList(port_declaration_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 919:
    ///
    /// `PortDeclarationGroupList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration_group_list_1_built = Vec::new();
        self.push(
            ASTType::PortDeclarationGroupList(port_declaration_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 920:
    ///
    /// `PortDeclarationItem: Identifier Colon PortDeclarationItemGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_item(
        &mut self,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _port_declaration_item_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration_item_group = pop_item!(
            self,
            port_declaration_item_group,
            PortDeclarationItemGroup,
            context
        );
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let port_declaration_item_built = PortDeclarationItem {
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            port_declaration_item_group: Box::new(port_declaration_item_group),
        };
        // Calling user action here
        self.user_grammar
            .port_declaration_item(&port_declaration_item_built)?;
        self.push(
            ASTType::PortDeclarationItem(port_declaration_item_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 921:
    ///
    /// `PortDeclarationItemGroup: PortTypeConcrete;`
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_item_group_0(
        &mut self,
        _port_type_concrete: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_type_concrete = pop_item!(self, port_type_concrete, PortTypeConcrete, context);
        let port_declaration_item_group_0_built = PortDeclarationItemGroupPortTypeConcrete {
            port_type_concrete: Box::new(port_type_concrete),
        };
        let port_declaration_item_group_0_built =
            PortDeclarationItemGroup::PortTypeConcrete(port_declaration_item_group_0_built);
        self.push(
            ASTType::PortDeclarationItemGroup(port_declaration_item_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 922:
    ///
    /// `PortDeclarationItemGroup: PortTypeAbstract;`
    ///
    #[parol_runtime::function_name::named]
    fn port_declaration_item_group_1(
        &mut self,
        _port_type_abstract: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_type_abstract = pop_item!(self, port_type_abstract, PortTypeAbstract, context);
        let port_declaration_item_group_1_built = PortDeclarationItemGroupPortTypeAbstract {
            port_type_abstract: Box::new(port_type_abstract),
        };
        let port_declaration_item_group_1_built =
            PortDeclarationItemGroup::PortTypeAbstract(port_declaration_item_group_1_built);
        self.push(
            ASTType::PortDeclarationItemGroup(port_declaration_item_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 923:
    ///
    /// `PortTypeConcrete: Direction PortTypeConcreteOpt /* Option */ ArrayType PortTypeConcreteOpt0 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn port_type_concrete(
        &mut self,
        _direction: &ParseTreeType<'t>,
        _port_type_concrete_opt: &ParseTreeType<'t>,
        _array_type: &ParseTreeType<'t>,
        _port_type_concrete_opt0: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_type_concrete_opt0 =
            pop_item!(self, port_type_concrete_opt0, PortTypeConcreteOpt0, context);
        let array_type = pop_item!(self, array_type, ArrayType, context);
        let port_type_concrete_opt =
            pop_item!(self, port_type_concrete_opt, PortTypeConcreteOpt, context);
        let direction = pop_item!(self, direction, Direction, context);
        let port_type_concrete_built = PortTypeConcrete {
            direction: Box::new(direction),
            port_type_concrete_opt,
            array_type: Box::new(array_type),
            port_type_concrete_opt0,
        };
        // Calling user action here
        self.user_grammar
            .port_type_concrete(&port_type_concrete_built)?;
        self.push(ASTType::PortTypeConcrete(port_type_concrete_built), context);
        Ok(())
    }

    /// Semantic action for production 924:
    ///
    /// `PortTypeConcreteOpt0 /* Option<T>::Some */: Equ PortDefaultValue;`
    ///
    #[parol_runtime::function_name::named]
    fn port_type_concrete_opt0_0(
        &mut self,
        _equ: &ParseTreeType<'t>,
        _port_default_value: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_default_value = pop_item!(self, port_default_value, PortDefaultValue, context);
        let equ = pop_item!(self, equ, Equ, context);
        let port_type_concrete_opt0_0_built = PortTypeConcreteOpt0 {
            equ: Box::new(equ),
            port_default_value: Box::new(port_default_value),
        };
        self.push(
            ASTType::PortTypeConcreteOpt0(Some(port_type_concrete_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 925:
    ///
    /// `PortTypeConcreteOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn port_type_concrete_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::PortTypeConcreteOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 926:
    ///
    /// `PortTypeConcreteOpt /* Option<T>::Some */: ClockDomain;`
    ///
    #[parol_runtime::function_name::named]
    fn port_type_concrete_opt_0(&mut self, _clock_domain: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let clock_domain = pop_item!(self, clock_domain, ClockDomain, context);
        let port_type_concrete_opt_0_built = PortTypeConcreteOpt {
            clock_domain: Box::new(clock_domain),
        };
        self.push(
            ASTType::PortTypeConcreteOpt(Some(port_type_concrete_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 927:
    ///
    /// `PortTypeConcreteOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn port_type_concrete_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::PortTypeConcreteOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 928:
    ///
    /// `PortDefaultValue: Expression;`
    ///
    #[parol_runtime::function_name::named]
    fn port_default_value(&mut self, _expression: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let port_default_value_built = PortDefaultValue {
            expression: Box::new(expression),
        };
        // Calling user action here
        self.user_grammar
            .port_default_value(&port_default_value_built)?;
        self.push(ASTType::PortDefaultValue(port_default_value_built), context);
        Ok(())
    }

    /// Semantic action for production 929:
    ///
    /// `PortTypeAbstract: PortTypeAbstractOpt /* Option */ Interface PortTypeAbstractOpt0 /* Option */ PortTypeAbstractOpt1 /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn port_type_abstract(
        &mut self,
        _port_type_abstract_opt: &ParseTreeType<'t>,
        _interface: &ParseTreeType<'t>,
        _port_type_abstract_opt0: &ParseTreeType<'t>,
        _port_type_abstract_opt1: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_type_abstract_opt1 =
            pop_item!(self, port_type_abstract_opt1, PortTypeAbstractOpt1, context);
        let port_type_abstract_opt0 =
            pop_item!(self, port_type_abstract_opt0, PortTypeAbstractOpt0, context);
        let interface = pop_item!(self, interface, Interface, context);
        let port_type_abstract_opt =
            pop_item!(self, port_type_abstract_opt, PortTypeAbstractOpt, context);
        let port_type_abstract_built = PortTypeAbstract {
            port_type_abstract_opt,
            interface: Box::new(interface),
            port_type_abstract_opt0,
            port_type_abstract_opt1,
        };
        // Calling user action here
        self.user_grammar
            .port_type_abstract(&port_type_abstract_built)?;
        self.push(ASTType::PortTypeAbstract(port_type_abstract_built), context);
        Ok(())
    }

    /// Semantic action for production 930:
    ///
    /// `PortTypeAbstractOpt1 /* Option<T>::Some */: Array;`
    ///
    #[parol_runtime::function_name::named]
    fn port_type_abstract_opt1_0(&mut self, _array: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array = pop_item!(self, array, Array, context);
        let port_type_abstract_opt1_0_built = PortTypeAbstractOpt1 {
            array: Box::new(array),
        };
        self.push(
            ASTType::PortTypeAbstractOpt1(Some(port_type_abstract_opt1_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 931:
    ///
    /// `PortTypeAbstractOpt1 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn port_type_abstract_opt1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::PortTypeAbstractOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 932:
    ///
    /// `PortTypeAbstractOpt0 /* Option<T>::Some */: ColonColon Identifier;`
    ///
    #[parol_runtime::function_name::named]
    fn port_type_abstract_opt0_0(
        &mut self,
        _colon_colon: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let colon_colon = pop_item!(self, colon_colon, ColonColon, context);
        let port_type_abstract_opt0_0_built = PortTypeAbstractOpt0 {
            colon_colon: Box::new(colon_colon),
            identifier: Box::new(identifier),
        };
        self.push(
            ASTType::PortTypeAbstractOpt0(Some(port_type_abstract_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 933:
    ///
    /// `PortTypeAbstractOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn port_type_abstract_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::PortTypeAbstractOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 934:
    ///
    /// `PortTypeAbstractOpt /* Option<T>::Some */: ClockDomain;`
    ///
    #[parol_runtime::function_name::named]
    fn port_type_abstract_opt_0(&mut self, _clock_domain: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let clock_domain = pop_item!(self, clock_domain, ClockDomain, context);
        let port_type_abstract_opt_0_built = PortTypeAbstractOpt {
            clock_domain: Box::new(clock_domain),
        };
        self.push(
            ASTType::PortTypeAbstractOpt(Some(port_type_abstract_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 935:
    ///
    /// `PortTypeAbstractOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn port_type_abstract_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::PortTypeAbstractOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 936:
    ///
    /// `Direction: Input;`
    ///
    #[parol_runtime::function_name::named]
    fn direction_0(&mut self, _input: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let input = pop_item!(self, input, Input, context);
        let direction_0_built = DirectionInput {
            input: Box::new(input),
        };
        let direction_0_built = Direction::Input(direction_0_built);
        // Calling user action here
        self.user_grammar.direction(&direction_0_built)?;
        self.push(ASTType::Direction(direction_0_built), context);
        Ok(())
    }

    /// Semantic action for production 937:
    ///
    /// `Direction: Output;`
    ///
    #[parol_runtime::function_name::named]
    fn direction_1(&mut self, _output: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let output = pop_item!(self, output, Output, context);
        let direction_1_built = DirectionOutput {
            output: Box::new(output),
        };
        let direction_1_built = Direction::Output(direction_1_built);
        // Calling user action here
        self.user_grammar.direction(&direction_1_built)?;
        self.push(ASTType::Direction(direction_1_built), context);
        Ok(())
    }

    /// Semantic action for production 938:
    ///
    /// `Direction: Inout;`
    ///
    #[parol_runtime::function_name::named]
    fn direction_2(&mut self, _inout: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inout = pop_item!(self, inout, Inout, context);
        let direction_2_built = DirectionInout {
            inout: Box::new(inout),
        };
        let direction_2_built = Direction::Inout(direction_2_built);
        // Calling user action here
        self.user_grammar.direction(&direction_2_built)?;
        self.push(ASTType::Direction(direction_2_built), context);
        Ok(())
    }

    /// Semantic action for production 939:
    ///
    /// `Direction: Modport;`
    ///
    #[parol_runtime::function_name::named]
    fn direction_3(&mut self, _modport: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport = pop_item!(self, modport, Modport, context);
        let direction_3_built = DirectionModport {
            modport: Box::new(modport),
        };
        let direction_3_built = Direction::Modport(direction_3_built);
        // Calling user action here
        self.user_grammar.direction(&direction_3_built)?;
        self.push(ASTType::Direction(direction_3_built), context);
        Ok(())
    }

    /// Semantic action for production 940:
    ///
    /// `Direction: Import;`
    ///
    #[parol_runtime::function_name::named]
    fn direction_4(&mut self, _import: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import = pop_item!(self, import, Import, context);
        let direction_4_built = DirectionImport {
            import: Box::new(import),
        };
        let direction_4_built = Direction::Import(direction_4_built);
        // Calling user action here
        self.user_grammar.direction(&direction_4_built)?;
        self.push(ASTType::Direction(direction_4_built), context);
        Ok(())
    }

    /// Semantic action for production 941:
    ///
    /// `FunctionDeclaration: Function Identifier FunctionDeclarationOpt /* Option */ FunctionDeclarationOpt0 /* Option */ FunctionDeclarationOpt1 /* Option */ StatementBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration(
        &mut self,
        _function: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _function_declaration_opt: &ParseTreeType<'t>,
        _function_declaration_opt0: &ParseTreeType<'t>,
        _function_declaration_opt1: &ParseTreeType<'t>,
        _statement_block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let statement_block = pop_item!(self, statement_block, StatementBlock, context);
        let function_declaration_opt1 = pop_item!(
            self,
            function_declaration_opt1,
            FunctionDeclarationOpt1,
            context
        );
        let function_declaration_opt0 = pop_item!(
            self,
            function_declaration_opt0,
            FunctionDeclarationOpt0,
            context
        );
        let function_declaration_opt = pop_item!(
            self,
            function_declaration_opt,
            FunctionDeclarationOpt,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let function = pop_item!(self, function, Function, context);
        let function_declaration_built = FunctionDeclaration {
            function: Box::new(function),
            identifier: Box::new(identifier),
            function_declaration_opt,
            function_declaration_opt0,
            function_declaration_opt1,
            statement_block: Box::new(statement_block),
        };
        // Calling user action here
        self.user_grammar
            .function_declaration(&function_declaration_built)?;
        self.push(
            ASTType::FunctionDeclaration(function_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 942:
    ///
    /// `FunctionDeclarationOpt1 /* Option<T>::Some */: MinusGT ScalarType;`
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration_opt1_0(
        &mut self,
        _minus_g_t: &ParseTreeType<'t>,
        _scalar_type: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scalar_type = pop_item!(self, scalar_type, ScalarType, context);
        let minus_g_t = pop_item!(self, minus_g_t, MinusGT, context);
        let function_declaration_opt1_0_built = FunctionDeclarationOpt1 {
            minus_g_t: Box::new(minus_g_t),
            scalar_type: Box::new(scalar_type),
        };
        self.push(
            ASTType::FunctionDeclarationOpt1(Some(function_declaration_opt1_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 943:
    ///
    /// `FunctionDeclarationOpt1 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration_opt1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FunctionDeclarationOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 944:
    ///
    /// `FunctionDeclarationOpt0 /* Option<T>::Some */: PortDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration_opt0_0(&mut self, _port_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration = pop_item!(self, port_declaration, PortDeclaration, context);
        let function_declaration_opt0_0_built = FunctionDeclarationOpt0 {
            port_declaration: Box::new(port_declaration),
        };
        self.push(
            ASTType::FunctionDeclarationOpt0(Some(function_declaration_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 945:
    ///
    /// `FunctionDeclarationOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FunctionDeclarationOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 946:
    ///
    /// `FunctionDeclarationOpt /* Option<T>::Some */: WithGenericParameter;`
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration_opt_0(
        &mut self,
        _with_generic_parameter: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_generic_parameter =
            pop_item!(self, with_generic_parameter, WithGenericParameter, context);
        let function_declaration_opt_0_built = FunctionDeclarationOpt {
            with_generic_parameter: Box::new(with_generic_parameter),
        };
        self.push(
            ASTType::FunctionDeclarationOpt(Some(function_declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 947:
    ///
    /// `FunctionDeclarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn function_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::FunctionDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 948:
    ///
    /// `ImportDeclaration: Import ScopedIdentifier ImportDeclarationOpt /* Option */ Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn import_declaration(
        &mut self,
        _import: &ParseTreeType<'t>,
        _scoped_identifier: &ParseTreeType<'t>,
        _import_declaration_opt: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let import_declaration_opt =
            pop_item!(self, import_declaration_opt, ImportDeclarationOpt, context);
        let scoped_identifier = pop_item!(self, scoped_identifier, ScopedIdentifier, context);
        let import = pop_item!(self, import, Import, context);
        let import_declaration_built = ImportDeclaration {
            import: Box::new(import),
            scoped_identifier: Box::new(scoped_identifier),
            import_declaration_opt,
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .import_declaration(&import_declaration_built)?;
        self.push(
            ASTType::ImportDeclaration(import_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 949:
    ///
    /// `ImportDeclarationOpt /* Option<T>::Some */: ColonColon Star;`
    ///
    #[parol_runtime::function_name::named]
    fn import_declaration_opt_0(
        &mut self,
        _colon_colon: &ParseTreeType<'t>,
        _star: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let star = pop_item!(self, star, Star, context);
        let colon_colon = pop_item!(self, colon_colon, ColonColon, context);
        let import_declaration_opt_0_built = ImportDeclarationOpt {
            colon_colon: Box::new(colon_colon),
            star: Box::new(star),
        };
        self.push(
            ASTType::ImportDeclarationOpt(Some(import_declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 950:
    ///
    /// `ImportDeclarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn import_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ImportDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 951:
    ///
    /// `UnsafeBlock: Unsafe LParen Identifier RParen LBrace UnsafeBlockList /* Vec */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn unsafe_block(
        &mut self,
        _unsafe: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _unsafe_block_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let unsafe_block_list =
            pop_and_reverse_item!(self, unsafe_block_list, UnsafeBlockList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let r#unsafe = pop_item!(self, r#unsafe, Unsafe, context);
        let unsafe_block_built = UnsafeBlock {
            r#unsafe: Box::new(r#unsafe),
            l_paren: Box::new(l_paren),
            identifier: Box::new(identifier),
            r_paren: Box::new(r_paren),
            l_brace: Box::new(l_brace),
            unsafe_block_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar.unsafe_block(&unsafe_block_built)?;
        self.push(ASTType::UnsafeBlock(unsafe_block_built), context);
        Ok(())
    }

    /// Semantic action for production 952:
    ///
    /// `UnsafeBlockList /* Vec<T>::Push */: GenerateGroup UnsafeBlockList;`
    ///
    #[parol_runtime::function_name::named]
    fn unsafe_block_list_0(
        &mut self,
        _generate_group: &ParseTreeType<'t>,
        _unsafe_block_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut unsafe_block_list = pop_item!(self, unsafe_block_list, UnsafeBlockList, context);
        let generate_group = pop_item!(self, generate_group, GenerateGroup, context);
        let unsafe_block_list_0_built = UnsafeBlockList {
            generate_group: Box::new(generate_group),
        };
        // Add an element to the vector
        unsafe_block_list.push(unsafe_block_list_0_built);
        self.push(ASTType::UnsafeBlockList(unsafe_block_list), context);
        Ok(())
    }

    /// Semantic action for production 953:
    ///
    /// `UnsafeBlockList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn unsafe_block_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unsafe_block_list_1_built = Vec::new();
        self.push(ASTType::UnsafeBlockList(unsafe_block_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 954:
    ///
    /// `ModuleDeclaration: Module Identifier ModuleDeclarationOpt /* Option */ ModuleDeclarationOpt0 /* Option */ ModuleDeclarationOpt1 /* Option */ ModuleDeclarationOpt2 /* Option */ LBrace ModuleDeclarationList /* Vec */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration(
        &mut self,
        _module: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _module_declaration_opt: &ParseTreeType<'t>,
        _module_declaration_opt0: &ParseTreeType<'t>,
        _module_declaration_opt1: &ParseTreeType<'t>,
        _module_declaration_opt2: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _module_declaration_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let module_declaration_list = pop_and_reverse_item!(
            self,
            module_declaration_list,
            ModuleDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let module_declaration_opt2 = pop_item!(
            self,
            module_declaration_opt2,
            ModuleDeclarationOpt2,
            context
        );
        let module_declaration_opt1 = pop_item!(
            self,
            module_declaration_opt1,
            ModuleDeclarationOpt1,
            context
        );
        let module_declaration_opt0 = pop_item!(
            self,
            module_declaration_opt0,
            ModuleDeclarationOpt0,
            context
        );
        let module_declaration_opt =
            pop_item!(self, module_declaration_opt, ModuleDeclarationOpt, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let module = pop_item!(self, module, Module, context);
        let module_declaration_built = ModuleDeclaration {
            module: Box::new(module),
            identifier: Box::new(identifier),
            module_declaration_opt,
            module_declaration_opt0,
            module_declaration_opt1,
            module_declaration_opt2,
            l_brace: Box::new(l_brace),
            module_declaration_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .module_declaration(&module_declaration_built)?;
        self.push(
            ASTType::ModuleDeclaration(module_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 955:
    ///
    /// `ModuleDeclarationList /* Vec<T>::Push */: ModuleGroup ModuleDeclarationList;`
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_list_0(
        &mut self,
        _module_group: &ParseTreeType<'t>,
        _module_declaration_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut module_declaration_list = pop_item!(
            self,
            module_declaration_list,
            ModuleDeclarationList,
            context
        );
        let module_group = pop_item!(self, module_group, ModuleGroup, context);
        let module_declaration_list_0_built = ModuleDeclarationList {
            module_group: Box::new(module_group),
        };
        // Add an element to the vector
        module_declaration_list.push(module_declaration_list_0_built);
        self.push(
            ASTType::ModuleDeclarationList(module_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 956:
    ///
    /// `ModuleDeclarationList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::ModuleDeclarationList(module_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 957:
    ///
    /// `ModuleDeclarationOpt2 /* Option<T>::Some */: PortDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt2_0(&mut self, _port_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration = pop_item!(self, port_declaration, PortDeclaration, context);
        let module_declaration_opt2_0_built = ModuleDeclarationOpt2 {
            port_declaration: Box::new(port_declaration),
        };
        self.push(
            ASTType::ModuleDeclarationOpt2(Some(module_declaration_opt2_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 958:
    ///
    /// `ModuleDeclarationOpt2 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt2_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModuleDeclarationOpt2(None), context);
        Ok(())
    }

    /// Semantic action for production 959:
    ///
    /// `ModuleDeclarationOpt1 /* Option<T>::Some */: WithParameter;`
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt1_0(&mut self, _with_parameter: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter = pop_item!(self, with_parameter, WithParameter, context);
        let module_declaration_opt1_0_built = ModuleDeclarationOpt1 {
            with_parameter: Box::new(with_parameter),
        };
        self.push(
            ASTType::ModuleDeclarationOpt1(Some(module_declaration_opt1_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 960:
    ///
    /// `ModuleDeclarationOpt1 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModuleDeclarationOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 961:
    ///
    /// `ModuleDeclarationOpt0 /* Option<T>::Some */: For ScopedIdentifier;`
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt0_0(
        &mut self,
        _for: &ParseTreeType<'t>,
        _scoped_identifier: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_identifier = pop_item!(self, scoped_identifier, ScopedIdentifier, context);
        let r#for = pop_item!(self, r#for, For, context);
        let module_declaration_opt0_0_built = ModuleDeclarationOpt0 {
            r#for: Box::new(r#for),
            scoped_identifier: Box::new(scoped_identifier),
        };
        self.push(
            ASTType::ModuleDeclarationOpt0(Some(module_declaration_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 962:
    ///
    /// `ModuleDeclarationOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModuleDeclarationOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 963:
    ///
    /// `ModuleDeclarationOpt /* Option<T>::Some */: WithGenericParameter;`
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt_0(
        &mut self,
        _with_generic_parameter: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_generic_parameter =
            pop_item!(self, with_generic_parameter, WithGenericParameter, context);
        let module_declaration_opt_0_built = ModuleDeclarationOpt {
            with_generic_parameter: Box::new(with_generic_parameter),
        };
        self.push(
            ASTType::ModuleDeclarationOpt(Some(module_declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 964:
    ///
    /// `ModuleDeclarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn module_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ModuleDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 965:
    ///
    /// `ModuleGroup: ModuleGroupList /* Vec */ ModuleGroupGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn module_group(
        &mut self,
        _module_group_list: &ParseTreeType<'t>,
        _module_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_group_group = pop_item!(self, module_group_group, ModuleGroupGroup, context);
        let module_group_list =
            pop_and_reverse_item!(self, module_group_list, ModuleGroupList, context);
        let module_group_built = ModuleGroup {
            module_group_list,
            module_group_group: Box::new(module_group_group),
        };
        // Calling user action here
        self.user_grammar.module_group(&module_group_built)?;
        self.push(ASTType::ModuleGroup(module_group_built), context);
        Ok(())
    }

    /// Semantic action for production 966:
    ///
    /// `ModuleGroupGroup: LBrace ModuleGroupGroupList /* Vec */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn module_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _module_group_group_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let module_group_group_list =
            pop_and_reverse_item!(self, module_group_group_list, ModuleGroupGroupList, context);
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let module_group_group_0_built = ModuleGroupGroupLBraceModuleGroupGroupListRBrace {
            l_brace: Box::new(l_brace),
            module_group_group_list,
            r_brace: Box::new(r_brace),
        };
        let module_group_group_0_built =
            ModuleGroupGroup::LBraceModuleGroupGroupListRBrace(module_group_group_0_built);
        self.push(
            ASTType::ModuleGroupGroup(module_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 967:
    ///
    /// `ModuleGroupGroupList /* Vec<T>::Push */: ModuleGroup ModuleGroupGroupList;`
    ///
    #[parol_runtime::function_name::named]
    fn module_group_group_list_0(
        &mut self,
        _module_group: &ParseTreeType<'t>,
        _module_group_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut module_group_group_list =
            pop_item!(self, module_group_group_list, ModuleGroupGroupList, context);
        let module_group = pop_item!(self, module_group, ModuleGroup, context);
        let module_group_group_list_0_built = ModuleGroupGroupList {
            module_group: Box::new(module_group),
        };
        // Add an element to the vector
        module_group_group_list.push(module_group_group_list_0_built);
        self.push(
            ASTType::ModuleGroupGroupList(module_group_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 968:
    ///
    /// `ModuleGroupGroupList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn module_group_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_group_group_list_1_built = Vec::new();
        self.push(
            ASTType::ModuleGroupGroupList(module_group_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 969:
    ///
    /// `ModuleGroupGroup: ModuleItem;`
    ///
    #[parol_runtime::function_name::named]
    fn module_group_group_1(&mut self, _module_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_item = pop_item!(self, module_item, ModuleItem, context);
        let module_group_group_1_built = ModuleGroupGroupModuleItem {
            module_item: Box::new(module_item),
        };
        let module_group_group_1_built = ModuleGroupGroup::ModuleItem(module_group_group_1_built);
        self.push(
            ASTType::ModuleGroupGroup(module_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 970:
    ///
    /// `ModuleGroupList /* Vec<T>::Push */: Attribute ModuleGroupList;`
    ///
    #[parol_runtime::function_name::named]
    fn module_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _module_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut module_group_list = pop_item!(self, module_group_list, ModuleGroupList, context);
        let attribute = pop_item!(self, attribute, Attribute, context);
        let module_group_list_0_built = ModuleGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        module_group_list.push(module_group_list_0_built);
        self.push(ASTType::ModuleGroupList(module_group_list), context);
        Ok(())
    }

    /// Semantic action for production 971:
    ///
    /// `ModuleGroupList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn module_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_group_list_1_built = Vec::new();
        self.push(ASTType::ModuleGroupList(module_group_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 972:
    ///
    /// `ModuleItem: GenerateItem;`
    ///
    #[parol_runtime::function_name::named]
    fn module_item(&mut self, _generate_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let generate_item = pop_item!(self, generate_item, GenerateItem, context);
        let module_item_built = ModuleItem {
            generate_item: Box::new(generate_item),
        };
        // Calling user action here
        self.user_grammar.module_item(&module_item_built)?;
        self.push(ASTType::ModuleItem(module_item_built), context);
        Ok(())
    }

    /// Semantic action for production 973:
    ///
    /// `InterfaceDeclaration: Interface Identifier InterfaceDeclarationOpt /* Option */ InterfaceDeclarationOpt0 /* Option */ InterfaceDeclarationOpt1 /* Option */ LBrace InterfaceDeclarationList /* Vec */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration(
        &mut self,
        _interface: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _interface_declaration_opt: &ParseTreeType<'t>,
        _interface_declaration_opt0: &ParseTreeType<'t>,
        _interface_declaration_opt1: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _interface_declaration_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let interface_declaration_list = pop_and_reverse_item!(
            self,
            interface_declaration_list,
            InterfaceDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let interface_declaration_opt1 = pop_item!(
            self,
            interface_declaration_opt1,
            InterfaceDeclarationOpt1,
            context
        );
        let interface_declaration_opt0 = pop_item!(
            self,
            interface_declaration_opt0,
            InterfaceDeclarationOpt0,
            context
        );
        let interface_declaration_opt = pop_item!(
            self,
            interface_declaration_opt,
            InterfaceDeclarationOpt,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let interface = pop_item!(self, interface, Interface, context);
        let interface_declaration_built = InterfaceDeclaration {
            interface: Box::new(interface),
            identifier: Box::new(identifier),
            interface_declaration_opt,
            interface_declaration_opt0,
            interface_declaration_opt1,
            l_brace: Box::new(l_brace),
            interface_declaration_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .interface_declaration(&interface_declaration_built)?;
        self.push(
            ASTType::InterfaceDeclaration(interface_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 974:
    ///
    /// `InterfaceDeclarationList /* Vec<T>::Push */: InterfaceGroup InterfaceDeclarationList;`
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_list_0(
        &mut self,
        _interface_group: &ParseTreeType<'t>,
        _interface_declaration_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut interface_declaration_list = pop_item!(
            self,
            interface_declaration_list,
            InterfaceDeclarationList,
            context
        );
        let interface_group = pop_item!(self, interface_group, InterfaceGroup, context);
        let interface_declaration_list_0_built = InterfaceDeclarationList {
            interface_group: Box::new(interface_group),
        };
        // Add an element to the vector
        interface_declaration_list.push(interface_declaration_list_0_built);
        self.push(
            ASTType::InterfaceDeclarationList(interface_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 975:
    ///
    /// `InterfaceDeclarationList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::InterfaceDeclarationList(interface_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 976:
    ///
    /// `InterfaceDeclarationOpt1 /* Option<T>::Some */: WithParameter;`
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_opt1_0(&mut self, _with_parameter: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter = pop_item!(self, with_parameter, WithParameter, context);
        let interface_declaration_opt1_0_built = InterfaceDeclarationOpt1 {
            with_parameter: Box::new(with_parameter),
        };
        self.push(
            ASTType::InterfaceDeclarationOpt1(Some(interface_declaration_opt1_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 977:
    ///
    /// `InterfaceDeclarationOpt1 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_opt1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InterfaceDeclarationOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 978:
    ///
    /// `InterfaceDeclarationOpt0 /* Option<T>::Some */: For ScopedIdentifier;`
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_opt0_0(
        &mut self,
        _for: &ParseTreeType<'t>,
        _scoped_identifier: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_identifier = pop_item!(self, scoped_identifier, ScopedIdentifier, context);
        let r#for = pop_item!(self, r#for, For, context);
        let interface_declaration_opt0_0_built = InterfaceDeclarationOpt0 {
            r#for: Box::new(r#for),
            scoped_identifier: Box::new(scoped_identifier),
        };
        self.push(
            ASTType::InterfaceDeclarationOpt0(Some(interface_declaration_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 979:
    ///
    /// `InterfaceDeclarationOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InterfaceDeclarationOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 980:
    ///
    /// `InterfaceDeclarationOpt /* Option<T>::Some */: WithGenericParameter;`
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_opt_0(
        &mut self,
        _with_generic_parameter: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_generic_parameter =
            pop_item!(self, with_generic_parameter, WithGenericParameter, context);
        let interface_declaration_opt_0_built = InterfaceDeclarationOpt {
            with_generic_parameter: Box::new(with_generic_parameter),
        };
        self.push(
            ASTType::InterfaceDeclarationOpt(Some(interface_declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 981:
    ///
    /// `InterfaceDeclarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn interface_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::InterfaceDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 982:
    ///
    /// `InterfaceGroup: InterfaceGroupList /* Vec */ InterfaceGroupGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn interface_group(
        &mut self,
        _interface_group_list: &ParseTreeType<'t>,
        _interface_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_group_group =
            pop_item!(self, interface_group_group, InterfaceGroupGroup, context);
        let interface_group_list =
            pop_and_reverse_item!(self, interface_group_list, InterfaceGroupList, context);
        let interface_group_built = InterfaceGroup {
            interface_group_list,
            interface_group_group: Box::new(interface_group_group),
        };
        // Calling user action here
        self.user_grammar.interface_group(&interface_group_built)?;
        self.push(ASTType::InterfaceGroup(interface_group_built), context);
        Ok(())
    }

    /// Semantic action for production 983:
    ///
    /// `InterfaceGroupGroup: LBrace InterfaceGroupGroupList /* Vec */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn interface_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _interface_group_group_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let interface_group_group_list = pop_and_reverse_item!(
            self,
            interface_group_group_list,
            InterfaceGroupGroupList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let interface_group_group_0_built =
            InterfaceGroupGroupLBraceInterfaceGroupGroupListRBrace {
                l_brace: Box::new(l_brace),
                interface_group_group_list,
                r_brace: Box::new(r_brace),
            };
        let interface_group_group_0_built =
            InterfaceGroupGroup::LBraceInterfaceGroupGroupListRBrace(interface_group_group_0_built);
        self.push(
            ASTType::InterfaceGroupGroup(interface_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 984:
    ///
    /// `InterfaceGroupGroupList /* Vec<T>::Push */: InterfaceGroup InterfaceGroupGroupList;`
    ///
    #[parol_runtime::function_name::named]
    fn interface_group_group_list_0(
        &mut self,
        _interface_group: &ParseTreeType<'t>,
        _interface_group_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut interface_group_group_list = pop_item!(
            self,
            interface_group_group_list,
            InterfaceGroupGroupList,
            context
        );
        let interface_group = pop_item!(self, interface_group, InterfaceGroup, context);
        let interface_group_group_list_0_built = InterfaceGroupGroupList {
            interface_group: Box::new(interface_group),
        };
        // Add an element to the vector
        interface_group_group_list.push(interface_group_group_list_0_built);
        self.push(
            ASTType::InterfaceGroupGroupList(interface_group_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 985:
    ///
    /// `InterfaceGroupGroupList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn interface_group_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_group_group_list_1_built = Vec::new();
        self.push(
            ASTType::InterfaceGroupGroupList(interface_group_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 986:
    ///
    /// `InterfaceGroupGroup: InterfaceItem;`
    ///
    #[parol_runtime::function_name::named]
    fn interface_group_group_1(&mut self, _interface_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_item = pop_item!(self, interface_item, InterfaceItem, context);
        let interface_group_group_1_built = InterfaceGroupGroupInterfaceItem {
            interface_item: Box::new(interface_item),
        };
        let interface_group_group_1_built =
            InterfaceGroupGroup::InterfaceItem(interface_group_group_1_built);
        self.push(
            ASTType::InterfaceGroupGroup(interface_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 987:
    ///
    /// `InterfaceGroupList /* Vec<T>::Push */: Attribute InterfaceGroupList;`
    ///
    #[parol_runtime::function_name::named]
    fn interface_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _interface_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut interface_group_list =
            pop_item!(self, interface_group_list, InterfaceGroupList, context);
        let attribute = pop_item!(self, attribute, Attribute, context);
        let interface_group_list_0_built = InterfaceGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        interface_group_list.push(interface_group_list_0_built);
        self.push(ASTType::InterfaceGroupList(interface_group_list), context);
        Ok(())
    }

    /// Semantic action for production 988:
    ///
    /// `InterfaceGroupList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn interface_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_group_list_1_built = Vec::new();
        self.push(
            ASTType::InterfaceGroupList(interface_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 989:
    ///
    /// `InterfaceItem: GenerateItem;`
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_0(&mut self, _generate_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let generate_item = pop_item!(self, generate_item, GenerateItem, context);
        let interface_item_0_built = InterfaceItemGenerateItem {
            generate_item: Box::new(generate_item),
        };
        let interface_item_0_built = InterfaceItem::GenerateItem(interface_item_0_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_0_built)?;
        self.push(ASTType::InterfaceItem(interface_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 990:
    ///
    /// `InterfaceItem: ModportDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn interface_item_1(&mut self, _modport_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_declaration = pop_item!(self, modport_declaration, ModportDeclaration, context);
        let interface_item_1_built = InterfaceItemModportDeclaration {
            modport_declaration: Box::new(modport_declaration),
        };
        let interface_item_1_built = InterfaceItem::ModportDeclaration(interface_item_1_built);
        // Calling user action here
        self.user_grammar.interface_item(&interface_item_1_built)?;
        self.push(ASTType::InterfaceItem(interface_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 991:
    ///
    /// `GenerateIfDeclaration: If Expression GenerateNamedBlock GenerateIfDeclarationList /* Vec */ GenerateIfDeclarationOpt /* Option */;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_if_declaration(
        &mut self,
        _if: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _generate_named_block: &ParseTreeType<'t>,
        _generate_if_declaration_list: &ParseTreeType<'t>,
        _generate_if_declaration_opt: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let generate_if_declaration_opt = pop_item!(
            self,
            generate_if_declaration_opt,
            GenerateIfDeclarationOpt,
            context
        );
        let generate_if_declaration_list = pop_and_reverse_item!(
            self,
            generate_if_declaration_list,
            GenerateIfDeclarationList,
            context
        );
        let generate_named_block =
            pop_item!(self, generate_named_block, GenerateNamedBlock, context);
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let generate_if_declaration_built = GenerateIfDeclaration {
            r#if: Box::new(r#if),
            expression: Box::new(expression),
            generate_named_block: Box::new(generate_named_block),
            generate_if_declaration_list,
            generate_if_declaration_opt,
        };
        // Calling user action here
        self.user_grammar
            .generate_if_declaration(&generate_if_declaration_built)?;
        self.push(
            ASTType::GenerateIfDeclaration(generate_if_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 992:
    ///
    /// `GenerateIfDeclarationList /* Vec<T>::Push */: Else If Expression GenerateOptionalNamedBlock GenerateIfDeclarationList;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_if_declaration_list_0(
        &mut self,
        _else: &ParseTreeType<'t>,
        _if: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
        _generate_optional_named_block: &ParseTreeType<'t>,
        _generate_if_declaration_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut generate_if_declaration_list = pop_item!(
            self,
            generate_if_declaration_list,
            GenerateIfDeclarationList,
            context
        );
        let generate_optional_named_block = pop_item!(
            self,
            generate_optional_named_block,
            GenerateOptionalNamedBlock,
            context
        );
        let expression = pop_item!(self, expression, Expression, context);
        let r#if = pop_item!(self, r#if, If, context);
        let r#else = pop_item!(self, r#else, Else, context);
        let generate_if_declaration_list_0_built = GenerateIfDeclarationList {
            generate_optional_named_block: Box::new(generate_optional_named_block),
            expression: Box::new(expression),
            r#if: Box::new(r#if),
            r#else: Box::new(r#else),
        };
        // Add an element to the vector
        generate_if_declaration_list.push(generate_if_declaration_list_0_built);
        self.push(
            ASTType::GenerateIfDeclarationList(generate_if_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 993:
    ///
    /// `GenerateIfDeclarationList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_if_declaration_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let generate_if_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::GenerateIfDeclarationList(generate_if_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 994:
    ///
    /// `GenerateIfDeclarationOpt /* Option<T>::Some */: Else GenerateOptionalNamedBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_if_declaration_opt_0(
        &mut self,
        _else: &ParseTreeType<'t>,
        _generate_optional_named_block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let generate_optional_named_block = pop_item!(
            self,
            generate_optional_named_block,
            GenerateOptionalNamedBlock,
            context
        );
        let r#else = pop_item!(self, r#else, Else, context);
        let generate_if_declaration_opt_0_built = GenerateIfDeclarationOpt {
            r#else: Box::new(r#else),
            generate_optional_named_block: Box::new(generate_optional_named_block),
        };
        self.push(
            ASTType::GenerateIfDeclarationOpt(Some(generate_if_declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 995:
    ///
    /// `GenerateIfDeclarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_if_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::GenerateIfDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 996:
    ///
    /// `GenerateForDeclaration: For Identifier In GenerateForDeclarationOpt /* Option */ Range GenerateForDeclarationOpt0 /* Option */ GenerateNamedBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_for_declaration(
        &mut self,
        _for: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _in: &ParseTreeType<'t>,
        _generate_for_declaration_opt: &ParseTreeType<'t>,
        _range: &ParseTreeType<'t>,
        _generate_for_declaration_opt0: &ParseTreeType<'t>,
        _generate_named_block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let generate_named_block =
            pop_item!(self, generate_named_block, GenerateNamedBlock, context);
        let generate_for_declaration_opt0 = pop_item!(
            self,
            generate_for_declaration_opt0,
            GenerateForDeclarationOpt0,
            context
        );
        let range = pop_item!(self, range, Range, context);
        let generate_for_declaration_opt = pop_item!(
            self,
            generate_for_declaration_opt,
            GenerateForDeclarationOpt,
            context
        );
        let r#in = pop_item!(self, r#in, In, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let r#for = pop_item!(self, r#for, For, context);
        let generate_for_declaration_built = GenerateForDeclaration {
            r#for: Box::new(r#for),
            identifier: Box::new(identifier),
            r#in: Box::new(r#in),
            generate_for_declaration_opt,
            range: Box::new(range),
            generate_for_declaration_opt0,
            generate_named_block: Box::new(generate_named_block),
        };
        // Calling user action here
        self.user_grammar
            .generate_for_declaration(&generate_for_declaration_built)?;
        self.push(
            ASTType::GenerateForDeclaration(generate_for_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 997:
    ///
    /// `GenerateForDeclarationOpt0 /* Option<T>::Some */: Step AssignmentOperator Expression;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_for_declaration_opt0_0(
        &mut self,
        _step: &ParseTreeType<'t>,
        _assignment_operator: &ParseTreeType<'t>,
        _expression: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let expression = pop_item!(self, expression, Expression, context);
        let assignment_operator = pop_item!(self, assignment_operator, AssignmentOperator, context);
        let step = pop_item!(self, step, Step, context);
        let generate_for_declaration_opt0_0_built = GenerateForDeclarationOpt0 {
            step: Box::new(step),
            assignment_operator: Box::new(assignment_operator),
            expression: Box::new(expression),
        };
        self.push(
            ASTType::GenerateForDeclarationOpt0(Some(generate_for_declaration_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 998:
    ///
    /// `GenerateForDeclarationOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_for_declaration_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::GenerateForDeclarationOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 999:
    ///
    /// `GenerateForDeclarationOpt /* Option<T>::Some */: Rev;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_for_declaration_opt_0(&mut self, _rev: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let rev = pop_item!(self, rev, Rev, context);
        let generate_for_declaration_opt_0_built = GenerateForDeclarationOpt { rev: Box::new(rev) };
        self.push(
            ASTType::GenerateForDeclarationOpt(Some(generate_for_declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1000:
    ///
    /// `GenerateForDeclarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_for_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::GenerateForDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 1001:
    ///
    /// `GenerateBlockDeclaration: GenerateNamedBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_block_declaration(
        &mut self,
        _generate_named_block: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let generate_named_block =
            pop_item!(self, generate_named_block, GenerateNamedBlock, context);
        let generate_block_declaration_built = GenerateBlockDeclaration {
            generate_named_block: Box::new(generate_named_block),
        };
        // Calling user action here
        self.user_grammar
            .generate_block_declaration(&generate_block_declaration_built)?;
        self.push(
            ASTType::GenerateBlockDeclaration(generate_block_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1002:
    ///
    /// `GenerateNamedBlock: Colon Identifier LBrace GenerateNamedBlockList /* Vec */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_named_block(
        &mut self,
        _colon: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _generate_named_block_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let generate_named_block_list = pop_and_reverse_item!(
            self,
            generate_named_block_list,
            GenerateNamedBlockList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let colon = pop_item!(self, colon, Colon, context);
        let generate_named_block_built = GenerateNamedBlock {
            colon: Box::new(colon),
            identifier: Box::new(identifier),
            l_brace: Box::new(l_brace),
            generate_named_block_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .generate_named_block(&generate_named_block_built)?;
        self.push(
            ASTType::GenerateNamedBlock(generate_named_block_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1003:
    ///
    /// `GenerateNamedBlockList /* Vec<T>::Push */: GenerateGroup GenerateNamedBlockList;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_named_block_list_0(
        &mut self,
        _generate_group: &ParseTreeType<'t>,
        _generate_named_block_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut generate_named_block_list = pop_item!(
            self,
            generate_named_block_list,
            GenerateNamedBlockList,
            context
        );
        let generate_group = pop_item!(self, generate_group, GenerateGroup, context);
        let generate_named_block_list_0_built = GenerateNamedBlockList {
            generate_group: Box::new(generate_group),
        };
        // Add an element to the vector
        generate_named_block_list.push(generate_named_block_list_0_built);
        self.push(
            ASTType::GenerateNamedBlockList(generate_named_block_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1004:
    ///
    /// `GenerateNamedBlockList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_named_block_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let generate_named_block_list_1_built = Vec::new();
        self.push(
            ASTType::GenerateNamedBlockList(generate_named_block_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1005:
    ///
    /// `GenerateOptionalNamedBlock: GenerateOptionalNamedBlockOpt /* Option */ LBrace GenerateOptionalNamedBlockList /* Vec */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_optional_named_block(
        &mut self,
        _generate_optional_named_block_opt: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _generate_optional_named_block_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let generate_optional_named_block_list = pop_and_reverse_item!(
            self,
            generate_optional_named_block_list,
            GenerateOptionalNamedBlockList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let generate_optional_named_block_opt = pop_item!(
            self,
            generate_optional_named_block_opt,
            GenerateOptionalNamedBlockOpt,
            context
        );
        let generate_optional_named_block_built = GenerateOptionalNamedBlock {
            generate_optional_named_block_opt,
            l_brace: Box::new(l_brace),
            generate_optional_named_block_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .generate_optional_named_block(&generate_optional_named_block_built)?;
        self.push(
            ASTType::GenerateOptionalNamedBlock(generate_optional_named_block_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1006:
    ///
    /// `GenerateOptionalNamedBlockList /* Vec<T>::Push */: GenerateGroup GenerateOptionalNamedBlockList;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_optional_named_block_list_0(
        &mut self,
        _generate_group: &ParseTreeType<'t>,
        _generate_optional_named_block_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut generate_optional_named_block_list = pop_item!(
            self,
            generate_optional_named_block_list,
            GenerateOptionalNamedBlockList,
            context
        );
        let generate_group = pop_item!(self, generate_group, GenerateGroup, context);
        let generate_optional_named_block_list_0_built = GenerateOptionalNamedBlockList {
            generate_group: Box::new(generate_group),
        };
        // Add an element to the vector
        generate_optional_named_block_list.push(generate_optional_named_block_list_0_built);
        self.push(
            ASTType::GenerateOptionalNamedBlockList(generate_optional_named_block_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1007:
    ///
    /// `GenerateOptionalNamedBlockList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_optional_named_block_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let generate_optional_named_block_list_1_built = Vec::new();
        self.push(
            ASTType::GenerateOptionalNamedBlockList(generate_optional_named_block_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1008:
    ///
    /// `GenerateOptionalNamedBlockOpt /* Option<T>::Some */: Colon Identifier;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_optional_named_block_opt_0(
        &mut self,
        _colon: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let identifier = pop_item!(self, identifier, Identifier, context);
        let colon = pop_item!(self, colon, Colon, context);
        let generate_optional_named_block_opt_0_built = GenerateOptionalNamedBlockOpt {
            colon: Box::new(colon),
            identifier: Box::new(identifier),
        };
        self.push(
            ASTType::GenerateOptionalNamedBlockOpt(Some(generate_optional_named_block_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1009:
    ///
    /// `GenerateOptionalNamedBlockOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_optional_named_block_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::GenerateOptionalNamedBlockOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 1010:
    ///
    /// `GenerateGroup: GenerateGroupList /* Vec */ GenerateGroupGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_group(
        &mut self,
        _generate_group_list: &ParseTreeType<'t>,
        _generate_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let generate_group_group =
            pop_item!(self, generate_group_group, GenerateGroupGroup, context);
        let generate_group_list =
            pop_and_reverse_item!(self, generate_group_list, GenerateGroupList, context);
        let generate_group_built = GenerateGroup {
            generate_group_list,
            generate_group_group: Box::new(generate_group_group),
        };
        // Calling user action here
        self.user_grammar.generate_group(&generate_group_built)?;
        self.push(ASTType::GenerateGroup(generate_group_built), context);
        Ok(())
    }

    /// Semantic action for production 1011:
    ///
    /// `GenerateGroupGroup: LBrace GenerateGroupGroupList /* Vec */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _generate_group_group_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let generate_group_group_list = pop_and_reverse_item!(
            self,
            generate_group_group_list,
            GenerateGroupGroupList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let generate_group_group_0_built = GenerateGroupGroupLBraceGenerateGroupGroupListRBrace {
            l_brace: Box::new(l_brace),
            generate_group_group_list,
            r_brace: Box::new(r_brace),
        };
        let generate_group_group_0_built =
            GenerateGroupGroup::LBraceGenerateGroupGroupListRBrace(generate_group_group_0_built);
        self.push(
            ASTType::GenerateGroupGroup(generate_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1012:
    ///
    /// `GenerateGroupGroupList /* Vec<T>::Push */: GenerateGroup GenerateGroupGroupList;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_group_group_list_0(
        &mut self,
        _generate_group: &ParseTreeType<'t>,
        _generate_group_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut generate_group_group_list = pop_item!(
            self,
            generate_group_group_list,
            GenerateGroupGroupList,
            context
        );
        let generate_group = pop_item!(self, generate_group, GenerateGroup, context);
        let generate_group_group_list_0_built = GenerateGroupGroupList {
            generate_group: Box::new(generate_group),
        };
        // Add an element to the vector
        generate_group_group_list.push(generate_group_group_list_0_built);
        self.push(
            ASTType::GenerateGroupGroupList(generate_group_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1013:
    ///
    /// `GenerateGroupGroupList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_group_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let generate_group_group_list_1_built = Vec::new();
        self.push(
            ASTType::GenerateGroupGroupList(generate_group_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1014:
    ///
    /// `GenerateGroupGroup: GenerateItem;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_group_group_1(&mut self, _generate_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let generate_item = pop_item!(self, generate_item, GenerateItem, context);
        let generate_group_group_1_built = GenerateGroupGroupGenerateItem {
            generate_item: Box::new(generate_item),
        };
        let generate_group_group_1_built =
            GenerateGroupGroup::GenerateItem(generate_group_group_1_built);
        self.push(
            ASTType::GenerateGroupGroup(generate_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1015:
    ///
    /// `GenerateGroupList /* Vec<T>::Push */: Attribute GenerateGroupList;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _generate_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut generate_group_list =
            pop_item!(self, generate_group_list, GenerateGroupList, context);
        let attribute = pop_item!(self, attribute, Attribute, context);
        let generate_group_list_0_built = GenerateGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        generate_group_list.push(generate_group_list_0_built);
        self.push(ASTType::GenerateGroupList(generate_group_list), context);
        Ok(())
    }

    /// Semantic action for production 1016:
    ///
    /// `GenerateGroupList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let generate_group_list_1_built = Vec::new();
        self.push(
            ASTType::GenerateGroupList(generate_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1017:
    ///
    /// `GenerateItem: LetDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_0(&mut self, _let_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let let_declaration = pop_item!(self, let_declaration, LetDeclaration, context);
        let generate_item_0_built = GenerateItemLetDeclaration {
            let_declaration: Box::new(let_declaration),
        };
        let generate_item_0_built = GenerateItem::LetDeclaration(generate_item_0_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_0_built)?;
        self.push(ASTType::GenerateItem(generate_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 1018:
    ///
    /// `GenerateItem: VarDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_1(&mut self, _var_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_declaration = pop_item!(self, var_declaration, VarDeclaration, context);
        let generate_item_1_built = GenerateItemVarDeclaration {
            var_declaration: Box::new(var_declaration),
        };
        let generate_item_1_built = GenerateItem::VarDeclaration(generate_item_1_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_1_built)?;
        self.push(ASTType::GenerateItem(generate_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 1019:
    ///
    /// `GenerateItem: InstDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_2(&mut self, _inst_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let inst_declaration = pop_item!(self, inst_declaration, InstDeclaration, context);
        let generate_item_2_built = GenerateItemInstDeclaration {
            inst_declaration: Box::new(inst_declaration),
        };
        let generate_item_2_built = GenerateItem::InstDeclaration(generate_item_2_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_2_built)?;
        self.push(ASTType::GenerateItem(generate_item_2_built), context);
        Ok(())
    }

    /// Semantic action for production 1020:
    ///
    /// `GenerateItem: BindDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_3(&mut self, _bind_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bind_declaration = pop_item!(self, bind_declaration, BindDeclaration, context);
        let generate_item_3_built = GenerateItemBindDeclaration {
            bind_declaration: Box::new(bind_declaration),
        };
        let generate_item_3_built = GenerateItem::BindDeclaration(generate_item_3_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_3_built)?;
        self.push(ASTType::GenerateItem(generate_item_3_built), context);
        Ok(())
    }

    /// Semantic action for production 1021:
    ///
    /// `GenerateItem: ConstDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_4(&mut self, _const_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_declaration = pop_item!(self, const_declaration, ConstDeclaration, context);
        let generate_item_4_built = GenerateItemConstDeclaration {
            const_declaration: Box::new(const_declaration),
        };
        let generate_item_4_built = GenerateItem::ConstDeclaration(generate_item_4_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_4_built)?;
        self.push(ASTType::GenerateItem(generate_item_4_built), context);
        Ok(())
    }

    /// Semantic action for production 1022:
    ///
    /// `GenerateItem: AlwaysFfDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_5(&mut self, _always_ff_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_ff_declaration =
            pop_item!(self, always_ff_declaration, AlwaysFfDeclaration, context);
        let generate_item_5_built = GenerateItemAlwaysFfDeclaration {
            always_ff_declaration: Box::new(always_ff_declaration),
        };
        let generate_item_5_built = GenerateItem::AlwaysFfDeclaration(generate_item_5_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_5_built)?;
        self.push(ASTType::GenerateItem(generate_item_5_built), context);
        Ok(())
    }

    /// Semantic action for production 1023:
    ///
    /// `GenerateItem: AlwaysCombDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_6(&mut self, _always_comb_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let always_comb_declaration = pop_item!(
            self,
            always_comb_declaration,
            AlwaysCombDeclaration,
            context
        );
        let generate_item_6_built = GenerateItemAlwaysCombDeclaration {
            always_comb_declaration: Box::new(always_comb_declaration),
        };
        let generate_item_6_built = GenerateItem::AlwaysCombDeclaration(generate_item_6_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_6_built)?;
        self.push(ASTType::GenerateItem(generate_item_6_built), context);
        Ok(())
    }

    /// Semantic action for production 1024:
    ///
    /// `GenerateItem: AssignDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_7(&mut self, _assign_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let assign_declaration = pop_item!(self, assign_declaration, AssignDeclaration, context);
        let generate_item_7_built = GenerateItemAssignDeclaration {
            assign_declaration: Box::new(assign_declaration),
        };
        let generate_item_7_built = GenerateItem::AssignDeclaration(generate_item_7_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_7_built)?;
        self.push(ASTType::GenerateItem(generate_item_7_built), context);
        Ok(())
    }

    /// Semantic action for production 1025:
    ///
    /// `GenerateItem: ConnectDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_8(&mut self, _connect_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let connect_declaration = pop_item!(self, connect_declaration, ConnectDeclaration, context);
        let generate_item_8_built = GenerateItemConnectDeclaration {
            connect_declaration: Box::new(connect_declaration),
        };
        let generate_item_8_built = GenerateItem::ConnectDeclaration(generate_item_8_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_8_built)?;
        self.push(ASTType::GenerateItem(generate_item_8_built), context);
        Ok(())
    }

    /// Semantic action for production 1026:
    ///
    /// `GenerateItem: FunctionDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_9(&mut self, _function_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_declaration =
            pop_item!(self, function_declaration, FunctionDeclaration, context);
        let generate_item_9_built = GenerateItemFunctionDeclaration {
            function_declaration: Box::new(function_declaration),
        };
        let generate_item_9_built = GenerateItem::FunctionDeclaration(generate_item_9_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_9_built)?;
        self.push(ASTType::GenerateItem(generate_item_9_built), context);
        Ok(())
    }

    /// Semantic action for production 1027:
    ///
    /// `GenerateItem: GenerateIfDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_10(&mut self, _generate_if_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let generate_if_declaration = pop_item!(
            self,
            generate_if_declaration,
            GenerateIfDeclaration,
            context
        );
        let generate_item_10_built = GenerateItemGenerateIfDeclaration {
            generate_if_declaration: Box::new(generate_if_declaration),
        };
        let generate_item_10_built = GenerateItem::GenerateIfDeclaration(generate_item_10_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_10_built)?;
        self.push(ASTType::GenerateItem(generate_item_10_built), context);
        Ok(())
    }

    /// Semantic action for production 1028:
    ///
    /// `GenerateItem: GenerateForDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_11(&mut self, _generate_for_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let generate_for_declaration = pop_item!(
            self,
            generate_for_declaration,
            GenerateForDeclaration,
            context
        );
        let generate_item_11_built = GenerateItemGenerateForDeclaration {
            generate_for_declaration: Box::new(generate_for_declaration),
        };
        let generate_item_11_built = GenerateItem::GenerateForDeclaration(generate_item_11_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_11_built)?;
        self.push(ASTType::GenerateItem(generate_item_11_built), context);
        Ok(())
    }

    /// Semantic action for production 1029:
    ///
    /// `GenerateItem: GenerateBlockDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_12(&mut self, _generate_block_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let generate_block_declaration = pop_item!(
            self,
            generate_block_declaration,
            GenerateBlockDeclaration,
            context
        );
        let generate_item_12_built = GenerateItemGenerateBlockDeclaration {
            generate_block_declaration: Box::new(generate_block_declaration),
        };
        let generate_item_12_built = GenerateItem::GenerateBlockDeclaration(generate_item_12_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_12_built)?;
        self.push(ASTType::GenerateItem(generate_item_12_built), context);
        Ok(())
    }

    /// Semantic action for production 1030:
    ///
    /// `GenerateItem: TypeDefDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_13(&mut self, _type_def_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def_declaration =
            pop_item!(self, type_def_declaration, TypeDefDeclaration, context);
        let generate_item_13_built = GenerateItemTypeDefDeclaration {
            type_def_declaration: Box::new(type_def_declaration),
        };
        let generate_item_13_built = GenerateItem::TypeDefDeclaration(generate_item_13_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_13_built)?;
        self.push(ASTType::GenerateItem(generate_item_13_built), context);
        Ok(())
    }

    /// Semantic action for production 1031:
    ///
    /// `GenerateItem: EnumDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_14(&mut self, _enum_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_declaration = pop_item!(self, enum_declaration, EnumDeclaration, context);
        let generate_item_14_built = GenerateItemEnumDeclaration {
            enum_declaration: Box::new(enum_declaration),
        };
        let generate_item_14_built = GenerateItem::EnumDeclaration(generate_item_14_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_14_built)?;
        self.push(ASTType::GenerateItem(generate_item_14_built), context);
        Ok(())
    }

    /// Semantic action for production 1032:
    ///
    /// `GenerateItem: StructUnionDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_15(&mut self, _struct_union_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_union_declaration = pop_item!(
            self,
            struct_union_declaration,
            StructUnionDeclaration,
            context
        );
        let generate_item_15_built = GenerateItemStructUnionDeclaration {
            struct_union_declaration: Box::new(struct_union_declaration),
        };
        let generate_item_15_built = GenerateItem::StructUnionDeclaration(generate_item_15_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_15_built)?;
        self.push(ASTType::GenerateItem(generate_item_15_built), context);
        Ok(())
    }

    /// Semantic action for production 1033:
    ///
    /// `GenerateItem: ImportDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_16(&mut self, _import_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_declaration = pop_item!(self, import_declaration, ImportDeclaration, context);
        let generate_item_16_built = GenerateItemImportDeclaration {
            import_declaration: Box::new(import_declaration),
        };
        let generate_item_16_built = GenerateItem::ImportDeclaration(generate_item_16_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_16_built)?;
        self.push(ASTType::GenerateItem(generate_item_16_built), context);
        Ok(())
    }

    /// Semantic action for production 1034:
    ///
    /// `GenerateItem: AliasDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_17(&mut self, _alias_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alias_declaration = pop_item!(self, alias_declaration, AliasDeclaration, context);
        let generate_item_17_built = GenerateItemAliasDeclaration {
            alias_declaration: Box::new(alias_declaration),
        };
        let generate_item_17_built = GenerateItem::AliasDeclaration(generate_item_17_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_17_built)?;
        self.push(ASTType::GenerateItem(generate_item_17_built), context);
        Ok(())
    }

    /// Semantic action for production 1035:
    ///
    /// `GenerateItem: InitialDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_18(&mut self, _initial_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let initial_declaration = pop_item!(self, initial_declaration, InitialDeclaration, context);
        let generate_item_18_built = GenerateItemInitialDeclaration {
            initial_declaration: Box::new(initial_declaration),
        };
        let generate_item_18_built = GenerateItem::InitialDeclaration(generate_item_18_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_18_built)?;
        self.push(ASTType::GenerateItem(generate_item_18_built), context);
        Ok(())
    }

    /// Semantic action for production 1036:
    ///
    /// `GenerateItem: FinalDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_19(&mut self, _final_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let final_declaration = pop_item!(self, final_declaration, FinalDeclaration, context);
        let generate_item_19_built = GenerateItemFinalDeclaration {
            final_declaration: Box::new(final_declaration),
        };
        let generate_item_19_built = GenerateItem::FinalDeclaration(generate_item_19_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_19_built)?;
        self.push(ASTType::GenerateItem(generate_item_19_built), context);
        Ok(())
    }

    /// Semantic action for production 1037:
    ///
    /// `GenerateItem: UnsafeBlock;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_20(&mut self, _unsafe_block: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let unsafe_block = pop_item!(self, unsafe_block, UnsafeBlock, context);
        let generate_item_20_built = GenerateItemUnsafeBlock {
            unsafe_block: Box::new(unsafe_block),
        };
        let generate_item_20_built = GenerateItem::UnsafeBlock(generate_item_20_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_20_built)?;
        self.push(ASTType::GenerateItem(generate_item_20_built), context);
        Ok(())
    }

    /// Semantic action for production 1038:
    ///
    /// `GenerateItem: EmbedDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn generate_item_21(&mut self, _embed_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let embed_declaration = pop_item!(self, embed_declaration, EmbedDeclaration, context);
        let generate_item_21_built = GenerateItemEmbedDeclaration {
            embed_declaration: Box::new(embed_declaration),
        };
        let generate_item_21_built = GenerateItem::EmbedDeclaration(generate_item_21_built);
        // Calling user action here
        self.user_grammar.generate_item(&generate_item_21_built)?;
        self.push(ASTType::GenerateItem(generate_item_21_built), context);
        Ok(())
    }

    /// Semantic action for production 1039:
    ///
    /// `PackageDeclaration: Package Identifier PackageDeclarationOpt /* Option */ PackageDeclarationOpt0 /* Option */ LBrace PackageDeclarationList /* Vec */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn package_declaration(
        &mut self,
        _package: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _package_declaration_opt: &ParseTreeType<'t>,
        _package_declaration_opt0: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _package_declaration_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let package_declaration_list = pop_and_reverse_item!(
            self,
            package_declaration_list,
            PackageDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let package_declaration_opt0 = pop_item!(
            self,
            package_declaration_opt0,
            PackageDeclarationOpt0,
            context
        );
        let package_declaration_opt = pop_item!(
            self,
            package_declaration_opt,
            PackageDeclarationOpt,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let package = pop_item!(self, package, Package, context);
        let package_declaration_built = PackageDeclaration {
            package: Box::new(package),
            identifier: Box::new(identifier),
            package_declaration_opt,
            package_declaration_opt0,
            l_brace: Box::new(l_brace),
            package_declaration_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .package_declaration(&package_declaration_built)?;
        self.push(
            ASTType::PackageDeclaration(package_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1040:
    ///
    /// `PackageDeclarationList /* Vec<T>::Push */: PackageGroup PackageDeclarationList;`
    ///
    #[parol_runtime::function_name::named]
    fn package_declaration_list_0(
        &mut self,
        _package_group: &ParseTreeType<'t>,
        _package_declaration_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut package_declaration_list = pop_item!(
            self,
            package_declaration_list,
            PackageDeclarationList,
            context
        );
        let package_group = pop_item!(self, package_group, PackageGroup, context);
        let package_declaration_list_0_built = PackageDeclarationList {
            package_group: Box::new(package_group),
        };
        // Add an element to the vector
        package_declaration_list.push(package_declaration_list_0_built);
        self.push(
            ASTType::PackageDeclarationList(package_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1041:
    ///
    /// `PackageDeclarationList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn package_declaration_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::PackageDeclarationList(package_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1042:
    ///
    /// `PackageDeclarationOpt0 /* Option<T>::Some */: For ScopedIdentifier;`
    ///
    #[parol_runtime::function_name::named]
    fn package_declaration_opt0_0(
        &mut self,
        _for: &ParseTreeType<'t>,
        _scoped_identifier: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scoped_identifier = pop_item!(self, scoped_identifier, ScopedIdentifier, context);
        let r#for = pop_item!(self, r#for, For, context);
        let package_declaration_opt0_0_built = PackageDeclarationOpt0 {
            r#for: Box::new(r#for),
            scoped_identifier: Box::new(scoped_identifier),
        };
        self.push(
            ASTType::PackageDeclarationOpt0(Some(package_declaration_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1043:
    ///
    /// `PackageDeclarationOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn package_declaration_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::PackageDeclarationOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 1044:
    ///
    /// `PackageDeclarationOpt /* Option<T>::Some */: WithGenericParameter;`
    ///
    #[parol_runtime::function_name::named]
    fn package_declaration_opt_0(
        &mut self,
        _with_generic_parameter: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_generic_parameter =
            pop_item!(self, with_generic_parameter, WithGenericParameter, context);
        let package_declaration_opt_0_built = PackageDeclarationOpt {
            with_generic_parameter: Box::new(with_generic_parameter),
        };
        self.push(
            ASTType::PackageDeclarationOpt(Some(package_declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1045:
    ///
    /// `PackageDeclarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn package_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::PackageDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 1046:
    ///
    /// `PackageGroup: PackageGroupList /* Vec */ PackageGroupGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn package_group(
        &mut self,
        _package_group_list: &ParseTreeType<'t>,
        _package_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package_group_group = pop_item!(self, package_group_group, PackageGroupGroup, context);
        let package_group_list =
            pop_and_reverse_item!(self, package_group_list, PackageGroupList, context);
        let package_group_built = PackageGroup {
            package_group_list,
            package_group_group: Box::new(package_group_group),
        };
        // Calling user action here
        self.user_grammar.package_group(&package_group_built)?;
        self.push(ASTType::PackageGroup(package_group_built), context);
        Ok(())
    }

    /// Semantic action for production 1047:
    ///
    /// `PackageGroupGroup: LBrace PackageGroupGroupList /* Vec */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn package_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _package_group_group_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let package_group_group_list = pop_and_reverse_item!(
            self,
            package_group_group_list,
            PackageGroupGroupList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let package_group_group_0_built = PackageGroupGroupLBracePackageGroupGroupListRBrace {
            l_brace: Box::new(l_brace),
            package_group_group_list,
            r_brace: Box::new(r_brace),
        };
        let package_group_group_0_built =
            PackageGroupGroup::LBracePackageGroupGroupListRBrace(package_group_group_0_built);
        self.push(
            ASTType::PackageGroupGroup(package_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1048:
    ///
    /// `PackageGroupGroupList /* Vec<T>::Push */: PackageGroup PackageGroupGroupList;`
    ///
    #[parol_runtime::function_name::named]
    fn package_group_group_list_0(
        &mut self,
        _package_group: &ParseTreeType<'t>,
        _package_group_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut package_group_group_list = pop_item!(
            self,
            package_group_group_list,
            PackageGroupGroupList,
            context
        );
        let package_group = pop_item!(self, package_group, PackageGroup, context);
        let package_group_group_list_0_built = PackageGroupGroupList {
            package_group: Box::new(package_group),
        };
        // Add an element to the vector
        package_group_group_list.push(package_group_group_list_0_built);
        self.push(
            ASTType::PackageGroupGroupList(package_group_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1049:
    ///
    /// `PackageGroupGroupList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn package_group_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package_group_group_list_1_built = Vec::new();
        self.push(
            ASTType::PackageGroupGroupList(package_group_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1050:
    ///
    /// `PackageGroupGroup: PackageItem;`
    ///
    #[parol_runtime::function_name::named]
    fn package_group_group_1(&mut self, _package_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package_item = pop_item!(self, package_item, PackageItem, context);
        let package_group_group_1_built = PackageGroupGroupPackageItem {
            package_item: Box::new(package_item),
        };
        let package_group_group_1_built =
            PackageGroupGroup::PackageItem(package_group_group_1_built);
        self.push(
            ASTType::PackageGroupGroup(package_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1051:
    ///
    /// `PackageGroupList /* Vec<T>::Push */: Attribute PackageGroupList;`
    ///
    #[parol_runtime::function_name::named]
    fn package_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _package_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut package_group_list = pop_item!(self, package_group_list, PackageGroupList, context);
        let attribute = pop_item!(self, attribute, Attribute, context);
        let package_group_list_0_built = PackageGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        package_group_list.push(package_group_list_0_built);
        self.push(ASTType::PackageGroupList(package_group_list), context);
        Ok(())
    }

    /// Semantic action for production 1052:
    ///
    /// `PackageGroupList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn package_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package_group_list_1_built = Vec::new();
        self.push(
            ASTType::PackageGroupList(package_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1053:
    ///
    /// `PackageItem: ConstDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn package_item_0(&mut self, _const_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let const_declaration = pop_item!(self, const_declaration, ConstDeclaration, context);
        let package_item_0_built = PackageItemConstDeclaration {
            const_declaration: Box::new(const_declaration),
        };
        let package_item_0_built = PackageItem::ConstDeclaration(package_item_0_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_0_built)?;
        self.push(ASTType::PackageItem(package_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 1054:
    ///
    /// `PackageItem: TypeDefDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn package_item_1(&mut self, _type_def_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let type_def_declaration =
            pop_item!(self, type_def_declaration, TypeDefDeclaration, context);
        let package_item_1_built = PackageItemTypeDefDeclaration {
            type_def_declaration: Box::new(type_def_declaration),
        };
        let package_item_1_built = PackageItem::TypeDefDeclaration(package_item_1_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_1_built)?;
        self.push(ASTType::PackageItem(package_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 1055:
    ///
    /// `PackageItem: EnumDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn package_item_2(&mut self, _enum_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_declaration = pop_item!(self, enum_declaration, EnumDeclaration, context);
        let package_item_2_built = PackageItemEnumDeclaration {
            enum_declaration: Box::new(enum_declaration),
        };
        let package_item_2_built = PackageItem::EnumDeclaration(package_item_2_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_2_built)?;
        self.push(ASTType::PackageItem(package_item_2_built), context);
        Ok(())
    }

    /// Semantic action for production 1056:
    ///
    /// `PackageItem: StructUnionDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn package_item_3(&mut self, _struct_union_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_union_declaration = pop_item!(
            self,
            struct_union_declaration,
            StructUnionDeclaration,
            context
        );
        let package_item_3_built = PackageItemStructUnionDeclaration {
            struct_union_declaration: Box::new(struct_union_declaration),
        };
        let package_item_3_built = PackageItem::StructUnionDeclaration(package_item_3_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_3_built)?;
        self.push(ASTType::PackageItem(package_item_3_built), context);
        Ok(())
    }

    /// Semantic action for production 1057:
    ///
    /// `PackageItem: FunctionDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn package_item_4(&mut self, _function_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let function_declaration =
            pop_item!(self, function_declaration, FunctionDeclaration, context);
        let package_item_4_built = PackageItemFunctionDeclaration {
            function_declaration: Box::new(function_declaration),
        };
        let package_item_4_built = PackageItem::FunctionDeclaration(package_item_4_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_4_built)?;
        self.push(ASTType::PackageItem(package_item_4_built), context);
        Ok(())
    }

    /// Semantic action for production 1058:
    ///
    /// `PackageItem: ImportDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn package_item_5(&mut self, _import_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_declaration = pop_item!(self, import_declaration, ImportDeclaration, context);
        let package_item_5_built = PackageItemImportDeclaration {
            import_declaration: Box::new(import_declaration),
        };
        let package_item_5_built = PackageItem::ImportDeclaration(package_item_5_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_5_built)?;
        self.push(ASTType::PackageItem(package_item_5_built), context);
        Ok(())
    }

    /// Semantic action for production 1059:
    ///
    /// `PackageItem: AliasDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn package_item_6(&mut self, _alias_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alias_declaration = pop_item!(self, alias_declaration, AliasDeclaration, context);
        let package_item_6_built = PackageItemAliasDeclaration {
            alias_declaration: Box::new(alias_declaration),
        };
        let package_item_6_built = PackageItem::AliasDeclaration(package_item_6_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_6_built)?;
        self.push(ASTType::PackageItem(package_item_6_built), context);
        Ok(())
    }

    /// Semantic action for production 1060:
    ///
    /// `PackageItem: EmbedDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn package_item_7(&mut self, _embed_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let embed_declaration = pop_item!(self, embed_declaration, EmbedDeclaration, context);
        let package_item_7_built = PackageItemEmbedDeclaration {
            embed_declaration: Box::new(embed_declaration),
        };
        let package_item_7_built = PackageItem::EmbedDeclaration(package_item_7_built);
        // Calling user action here
        self.user_grammar.package_item(&package_item_7_built)?;
        self.push(ASTType::PackageItem(package_item_7_built), context);
        Ok(())
    }

    /// Semantic action for production 1061:
    ///
    /// `AliasDeclaration: Alias AliasDeclarationGroup Identifier Equ ScopedIdentifier Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn alias_declaration(
        &mut self,
        _alias: &ParseTreeType<'t>,
        _alias_declaration_group: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _equ: &ParseTreeType<'t>,
        _scoped_identifier: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let scoped_identifier = pop_item!(self, scoped_identifier, ScopedIdentifier, context);
        let equ = pop_item!(self, equ, Equ, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let alias_declaration_group = pop_item!(
            self,
            alias_declaration_group,
            AliasDeclarationGroup,
            context
        );
        let alias = pop_item!(self, alias, Alias, context);
        let alias_declaration_built = AliasDeclaration {
            alias: Box::new(alias),
            alias_declaration_group: Box::new(alias_declaration_group),
            identifier: Box::new(identifier),
            equ: Box::new(equ),
            scoped_identifier: Box::new(scoped_identifier),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .alias_declaration(&alias_declaration_built)?;
        self.push(ASTType::AliasDeclaration(alias_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 1062:
    ///
    /// `AliasDeclarationGroup: Module;`
    ///
    #[parol_runtime::function_name::named]
    fn alias_declaration_group_0(&mut self, _module: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module = pop_item!(self, module, Module, context);
        let alias_declaration_group_0_built = AliasDeclarationGroupModule {
            module: Box::new(module),
        };
        let alias_declaration_group_0_built =
            AliasDeclarationGroup::Module(alias_declaration_group_0_built);
        self.push(
            ASTType::AliasDeclarationGroup(alias_declaration_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1063:
    ///
    /// `AliasDeclarationGroup: Interface;`
    ///
    #[parol_runtime::function_name::named]
    fn alias_declaration_group_1(&mut self, _interface: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface = pop_item!(self, interface, Interface, context);
        let alias_declaration_group_1_built = AliasDeclarationGroupInterface {
            interface: Box::new(interface),
        };
        let alias_declaration_group_1_built =
            AliasDeclarationGroup::Interface(alias_declaration_group_1_built);
        self.push(
            ASTType::AliasDeclarationGroup(alias_declaration_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1064:
    ///
    /// `AliasDeclarationGroup: Package;`
    ///
    #[parol_runtime::function_name::named]
    fn alias_declaration_group_2(&mut self, _package: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package = pop_item!(self, package, Package, context);
        let alias_declaration_group_2_built = AliasDeclarationGroupPackage {
            package: Box::new(package),
        };
        let alias_declaration_group_2_built =
            AliasDeclarationGroup::Package(alias_declaration_group_2_built);
        self.push(
            ASTType::AliasDeclarationGroup(alias_declaration_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1065:
    ///
    /// `ProtoDeclaration: Proto ProtoDeclarationGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_declaration(
        &mut self,
        _proto: &ParseTreeType<'t>,
        _proto_declaration_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let proto_declaration_group = pop_item!(
            self,
            proto_declaration_group,
            ProtoDeclarationGroup,
            context
        );
        let proto = pop_item!(self, proto, Proto, context);
        let proto_declaration_built = ProtoDeclaration {
            proto: Box::new(proto),
            proto_declaration_group: Box::new(proto_declaration_group),
        };
        // Calling user action here
        self.user_grammar
            .proto_declaration(&proto_declaration_built)?;
        self.push(ASTType::ProtoDeclaration(proto_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 1066:
    ///
    /// `ProtoDeclarationGroup: ProtoModuleDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_declaration_group_0(
        &mut self,
        _proto_module_declaration: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let proto_module_declaration = pop_item!(
            self,
            proto_module_declaration,
            ProtoModuleDeclaration,
            context
        );
        let proto_declaration_group_0_built = ProtoDeclarationGroupProtoModuleDeclaration {
            proto_module_declaration: Box::new(proto_module_declaration),
        };
        let proto_declaration_group_0_built =
            ProtoDeclarationGroup::ProtoModuleDeclaration(proto_declaration_group_0_built);
        self.push(
            ASTType::ProtoDeclarationGroup(proto_declaration_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1067:
    ///
    /// `ProtoDeclarationGroup: ProtoInterfaceDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_declaration_group_1(
        &mut self,
        _proto_interface_declaration: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let proto_interface_declaration = pop_item!(
            self,
            proto_interface_declaration,
            ProtoInterfaceDeclaration,
            context
        );
        let proto_declaration_group_1_built = ProtoDeclarationGroupProtoInterfaceDeclaration {
            proto_interface_declaration: Box::new(proto_interface_declaration),
        };
        let proto_declaration_group_1_built =
            ProtoDeclarationGroup::ProtoInterfaceDeclaration(proto_declaration_group_1_built);
        self.push(
            ASTType::ProtoDeclarationGroup(proto_declaration_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1068:
    ///
    /// `ProtoDeclarationGroup: ProtoPackageDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_declaration_group_2(
        &mut self,
        _proto_package_declaration: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let proto_package_declaration = pop_item!(
            self,
            proto_package_declaration,
            ProtoPackageDeclaration,
            context
        );
        let proto_declaration_group_2_built = ProtoDeclarationGroupProtoPackageDeclaration {
            proto_package_declaration: Box::new(proto_package_declaration),
        };
        let proto_declaration_group_2_built =
            ProtoDeclarationGroup::ProtoPackageDeclaration(proto_declaration_group_2_built);
        self.push(
            ASTType::ProtoDeclarationGroup(proto_declaration_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1069:
    ///
    /// `ProtoModuleDeclaration: Module Identifier ProtoModuleDeclarationOpt /* Option */ ProtoModuleDeclarationOpt0 /* Option */ Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_module_declaration(
        &mut self,
        _module: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _proto_module_declaration_opt: &ParseTreeType<'t>,
        _proto_module_declaration_opt0: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let proto_module_declaration_opt0 = pop_item!(
            self,
            proto_module_declaration_opt0,
            ProtoModuleDeclarationOpt0,
            context
        );
        let proto_module_declaration_opt = pop_item!(
            self,
            proto_module_declaration_opt,
            ProtoModuleDeclarationOpt,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let module = pop_item!(self, module, Module, context);
        let proto_module_declaration_built = ProtoModuleDeclaration {
            module: Box::new(module),
            identifier: Box::new(identifier),
            proto_module_declaration_opt,
            proto_module_declaration_opt0,
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .proto_module_declaration(&proto_module_declaration_built)?;
        self.push(
            ASTType::ProtoModuleDeclaration(proto_module_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1070:
    ///
    /// `ProtoModuleDeclarationOpt0 /* Option<T>::Some */: PortDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_module_declaration_opt0_0(
        &mut self,
        _port_declaration: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration = pop_item!(self, port_declaration, PortDeclaration, context);
        let proto_module_declaration_opt0_0_built = ProtoModuleDeclarationOpt0 {
            port_declaration: Box::new(port_declaration),
        };
        self.push(
            ASTType::ProtoModuleDeclarationOpt0(Some(proto_module_declaration_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1071:
    ///
    /// `ProtoModuleDeclarationOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_module_declaration_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ProtoModuleDeclarationOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 1072:
    ///
    /// `ProtoModuleDeclarationOpt /* Option<T>::Some */: WithParameter;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_module_declaration_opt_0(
        &mut self,
        _with_parameter: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter = pop_item!(self, with_parameter, WithParameter, context);
        let proto_module_declaration_opt_0_built = ProtoModuleDeclarationOpt {
            with_parameter: Box::new(with_parameter),
        };
        self.push(
            ASTType::ProtoModuleDeclarationOpt(Some(proto_module_declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1073:
    ///
    /// `ProtoModuleDeclarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_module_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ProtoModuleDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 1074:
    ///
    /// `ProtoInterfaceDeclaration: Interface Identifier ProtoInterfaceDeclarationOpt /* Option */ LBrace ProtoInterfaceDeclarationList /* Vec */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_interface_declaration(
        &mut self,
        _interface: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _proto_interface_declaration_opt: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _proto_interface_declaration_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let proto_interface_declaration_list = pop_and_reverse_item!(
            self,
            proto_interface_declaration_list,
            ProtoInterfaceDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let proto_interface_declaration_opt = pop_item!(
            self,
            proto_interface_declaration_opt,
            ProtoInterfaceDeclarationOpt,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let interface = pop_item!(self, interface, Interface, context);
        let proto_interface_declaration_built = ProtoInterfaceDeclaration {
            interface: Box::new(interface),
            identifier: Box::new(identifier),
            proto_interface_declaration_opt,
            l_brace: Box::new(l_brace),
            proto_interface_declaration_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .proto_interface_declaration(&proto_interface_declaration_built)?;
        self.push(
            ASTType::ProtoInterfaceDeclaration(proto_interface_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1075:
    ///
    /// `ProtoInterfaceDeclarationList /* Vec<T>::Push */: ProtoInterfaceItem ProtoInterfaceDeclarationList;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_interface_declaration_list_0(
        &mut self,
        _proto_interface_item: &ParseTreeType<'t>,
        _proto_interface_declaration_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut proto_interface_declaration_list = pop_item!(
            self,
            proto_interface_declaration_list,
            ProtoInterfaceDeclarationList,
            context
        );
        let proto_interface_item =
            pop_item!(self, proto_interface_item, ProtoInterfaceItem, context);
        let proto_interface_declaration_list_0_built = ProtoInterfaceDeclarationList {
            proto_interface_item: Box::new(proto_interface_item),
        };
        // Add an element to the vector
        proto_interface_declaration_list.push(proto_interface_declaration_list_0_built);
        self.push(
            ASTType::ProtoInterfaceDeclarationList(proto_interface_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1076:
    ///
    /// `ProtoInterfaceDeclarationList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_interface_declaration_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let proto_interface_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::ProtoInterfaceDeclarationList(proto_interface_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1077:
    ///
    /// `ProtoInterfaceDeclarationOpt /* Option<T>::Some */: WithParameter;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_interface_declaration_opt_0(
        &mut self,
        _with_parameter: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_parameter = pop_item!(self, with_parameter, WithParameter, context);
        let proto_interface_declaration_opt_0_built = ProtoInterfaceDeclarationOpt {
            with_parameter: Box::new(with_parameter),
        };
        self.push(
            ASTType::ProtoInterfaceDeclarationOpt(Some(proto_interface_declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1078:
    ///
    /// `ProtoInterfaceDeclarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_interface_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ProtoInterfaceDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 1079:
    ///
    /// `ProtoInterfaceItem: VarDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_interface_item_0(&mut self, _var_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let var_declaration = pop_item!(self, var_declaration, VarDeclaration, context);
        let proto_interface_item_0_built = ProtoInterfaceItemVarDeclaration {
            var_declaration: Box::new(var_declaration),
        };
        let proto_interface_item_0_built =
            ProtoInterfaceItem::VarDeclaration(proto_interface_item_0_built);
        // Calling user action here
        self.user_grammar
            .proto_interface_item(&proto_interface_item_0_built)?;
        self.push(
            ASTType::ProtoInterfaceItem(proto_interface_item_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1080:
    ///
    /// `ProtoInterfaceItem: ProtoConstDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_interface_item_1(
        &mut self,
        _proto_const_declaration: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let proto_const_declaration = pop_item!(
            self,
            proto_const_declaration,
            ProtoConstDeclaration,
            context
        );
        let proto_interface_item_1_built = ProtoInterfaceItemProtoConstDeclaration {
            proto_const_declaration: Box::new(proto_const_declaration),
        };
        let proto_interface_item_1_built =
            ProtoInterfaceItem::ProtoConstDeclaration(proto_interface_item_1_built);
        // Calling user action here
        self.user_grammar
            .proto_interface_item(&proto_interface_item_1_built)?;
        self.push(
            ASTType::ProtoInterfaceItem(proto_interface_item_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1081:
    ///
    /// `ProtoInterfaceItem: ProtoFunctionDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_interface_item_2(
        &mut self,
        _proto_function_declaration: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let proto_function_declaration = pop_item!(
            self,
            proto_function_declaration,
            ProtoFunctionDeclaration,
            context
        );
        let proto_interface_item_2_built = ProtoInterfaceItemProtoFunctionDeclaration {
            proto_function_declaration: Box::new(proto_function_declaration),
        };
        let proto_interface_item_2_built =
            ProtoInterfaceItem::ProtoFunctionDeclaration(proto_interface_item_2_built);
        // Calling user action here
        self.user_grammar
            .proto_interface_item(&proto_interface_item_2_built)?;
        self.push(
            ASTType::ProtoInterfaceItem(proto_interface_item_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1082:
    ///
    /// `ProtoInterfaceItem: ProtoTypeDefDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_interface_item_3(
        &mut self,
        _proto_type_def_declaration: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let proto_type_def_declaration = pop_item!(
            self,
            proto_type_def_declaration,
            ProtoTypeDefDeclaration,
            context
        );
        let proto_interface_item_3_built = ProtoInterfaceItemProtoTypeDefDeclaration {
            proto_type_def_declaration: Box::new(proto_type_def_declaration),
        };
        let proto_interface_item_3_built =
            ProtoInterfaceItem::ProtoTypeDefDeclaration(proto_interface_item_3_built);
        // Calling user action here
        self.user_grammar
            .proto_interface_item(&proto_interface_item_3_built)?;
        self.push(
            ASTType::ProtoInterfaceItem(proto_interface_item_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1083:
    ///
    /// `ProtoInterfaceItem: ProtoAliasDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_interface_item_4(
        &mut self,
        _proto_alias_declaration: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let proto_alias_declaration = pop_item!(
            self,
            proto_alias_declaration,
            ProtoAliasDeclaration,
            context
        );
        let proto_interface_item_4_built = ProtoInterfaceItemProtoAliasDeclaration {
            proto_alias_declaration: Box::new(proto_alias_declaration),
        };
        let proto_interface_item_4_built =
            ProtoInterfaceItem::ProtoAliasDeclaration(proto_interface_item_4_built);
        // Calling user action here
        self.user_grammar
            .proto_interface_item(&proto_interface_item_4_built)?;
        self.push(
            ASTType::ProtoInterfaceItem(proto_interface_item_4_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1084:
    ///
    /// `ProtoInterfaceItem: ModportDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_interface_item_5(&mut self, _modport_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let modport_declaration = pop_item!(self, modport_declaration, ModportDeclaration, context);
        let proto_interface_item_5_built = ProtoInterfaceItemModportDeclaration {
            modport_declaration: Box::new(modport_declaration),
        };
        let proto_interface_item_5_built =
            ProtoInterfaceItem::ModportDeclaration(proto_interface_item_5_built);
        // Calling user action here
        self.user_grammar
            .proto_interface_item(&proto_interface_item_5_built)?;
        self.push(
            ASTType::ProtoInterfaceItem(proto_interface_item_5_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1085:
    ///
    /// `ProtoInterfaceItem: ImportDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_interface_item_6(&mut self, _import_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_declaration = pop_item!(self, import_declaration, ImportDeclaration, context);
        let proto_interface_item_6_built = ProtoInterfaceItemImportDeclaration {
            import_declaration: Box::new(import_declaration),
        };
        let proto_interface_item_6_built =
            ProtoInterfaceItem::ImportDeclaration(proto_interface_item_6_built);
        // Calling user action here
        self.user_grammar
            .proto_interface_item(&proto_interface_item_6_built)?;
        self.push(
            ASTType::ProtoInterfaceItem(proto_interface_item_6_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1086:
    ///
    /// `ProtoPackageDeclaration: Package Identifier LBrace ProtoPackageDeclarationList /* Vec */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_package_declaration(
        &mut self,
        _package: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _l_brace: &ParseTreeType<'t>,
        _proto_package_declaration_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let proto_package_declaration_list = pop_and_reverse_item!(
            self,
            proto_package_declaration_list,
            ProtoPackageDeclarationList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let package = pop_item!(self, package, Package, context);
        let proto_package_declaration_built = ProtoPackageDeclaration {
            package: Box::new(package),
            identifier: Box::new(identifier),
            l_brace: Box::new(l_brace),
            proto_package_declaration_list,
            r_brace: Box::new(r_brace),
        };
        // Calling user action here
        self.user_grammar
            .proto_package_declaration(&proto_package_declaration_built)?;
        self.push(
            ASTType::ProtoPackageDeclaration(proto_package_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1087:
    ///
    /// `ProtoPackageDeclarationList /* Vec<T>::Push */: ProtoPacakgeItem ProtoPackageDeclarationList;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_package_declaration_list_0(
        &mut self,
        _proto_pacakge_item: &ParseTreeType<'t>,
        _proto_package_declaration_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut proto_package_declaration_list = pop_item!(
            self,
            proto_package_declaration_list,
            ProtoPackageDeclarationList,
            context
        );
        let proto_pacakge_item = pop_item!(self, proto_pacakge_item, ProtoPacakgeItem, context);
        let proto_package_declaration_list_0_built = ProtoPackageDeclarationList {
            proto_pacakge_item: Box::new(proto_pacakge_item),
        };
        // Add an element to the vector
        proto_package_declaration_list.push(proto_package_declaration_list_0_built);
        self.push(
            ASTType::ProtoPackageDeclarationList(proto_package_declaration_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1088:
    ///
    /// `ProtoPackageDeclarationList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_package_declaration_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let proto_package_declaration_list_1_built = Vec::new();
        self.push(
            ASTType::ProtoPackageDeclarationList(proto_package_declaration_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1089:
    ///
    /// `ProtoPacakgeItem: ProtoConstDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_pacakge_item_0(&mut self, _proto_const_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let proto_const_declaration = pop_item!(
            self,
            proto_const_declaration,
            ProtoConstDeclaration,
            context
        );
        let proto_pacakge_item_0_built = ProtoPacakgeItemProtoConstDeclaration {
            proto_const_declaration: Box::new(proto_const_declaration),
        };
        let proto_pacakge_item_0_built =
            ProtoPacakgeItem::ProtoConstDeclaration(proto_pacakge_item_0_built);
        // Calling user action here
        self.user_grammar
            .proto_pacakge_item(&proto_pacakge_item_0_built)?;
        self.push(
            ASTType::ProtoPacakgeItem(proto_pacakge_item_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1090:
    ///
    /// `ProtoPacakgeItem: ProtoTypeDefDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_pacakge_item_1(
        &mut self,
        _proto_type_def_declaration: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let proto_type_def_declaration = pop_item!(
            self,
            proto_type_def_declaration,
            ProtoTypeDefDeclaration,
            context
        );
        let proto_pacakge_item_1_built = ProtoPacakgeItemProtoTypeDefDeclaration {
            proto_type_def_declaration: Box::new(proto_type_def_declaration),
        };
        let proto_pacakge_item_1_built =
            ProtoPacakgeItem::ProtoTypeDefDeclaration(proto_pacakge_item_1_built);
        // Calling user action here
        self.user_grammar
            .proto_pacakge_item(&proto_pacakge_item_1_built)?;
        self.push(
            ASTType::ProtoPacakgeItem(proto_pacakge_item_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1091:
    ///
    /// `ProtoPacakgeItem: EnumDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_pacakge_item_2(&mut self, _enum_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let enum_declaration = pop_item!(self, enum_declaration, EnumDeclaration, context);
        let proto_pacakge_item_2_built = ProtoPacakgeItemEnumDeclaration {
            enum_declaration: Box::new(enum_declaration),
        };
        let proto_pacakge_item_2_built =
            ProtoPacakgeItem::EnumDeclaration(proto_pacakge_item_2_built);
        // Calling user action here
        self.user_grammar
            .proto_pacakge_item(&proto_pacakge_item_2_built)?;
        self.push(
            ASTType::ProtoPacakgeItem(proto_pacakge_item_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1092:
    ///
    /// `ProtoPacakgeItem: StructUnionDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_pacakge_item_3(
        &mut self,
        _struct_union_declaration: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let struct_union_declaration = pop_item!(
            self,
            struct_union_declaration,
            StructUnionDeclaration,
            context
        );
        let proto_pacakge_item_3_built = ProtoPacakgeItemStructUnionDeclaration {
            struct_union_declaration: Box::new(struct_union_declaration),
        };
        let proto_pacakge_item_3_built =
            ProtoPacakgeItem::StructUnionDeclaration(proto_pacakge_item_3_built);
        // Calling user action here
        self.user_grammar
            .proto_pacakge_item(&proto_pacakge_item_3_built)?;
        self.push(
            ASTType::ProtoPacakgeItem(proto_pacakge_item_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1093:
    ///
    /// `ProtoPacakgeItem: ProtoFunctionDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_pacakge_item_4(
        &mut self,
        _proto_function_declaration: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let proto_function_declaration = pop_item!(
            self,
            proto_function_declaration,
            ProtoFunctionDeclaration,
            context
        );
        let proto_pacakge_item_4_built = ProtoPacakgeItemProtoFunctionDeclaration {
            proto_function_declaration: Box::new(proto_function_declaration),
        };
        let proto_pacakge_item_4_built =
            ProtoPacakgeItem::ProtoFunctionDeclaration(proto_pacakge_item_4_built);
        // Calling user action here
        self.user_grammar
            .proto_pacakge_item(&proto_pacakge_item_4_built)?;
        self.push(
            ASTType::ProtoPacakgeItem(proto_pacakge_item_4_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1094:
    ///
    /// `ProtoPacakgeItem: ProtoAliasDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_pacakge_item_5(&mut self, _proto_alias_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let proto_alias_declaration = pop_item!(
            self,
            proto_alias_declaration,
            ProtoAliasDeclaration,
            context
        );
        let proto_pacakge_item_5_built = ProtoPacakgeItemProtoAliasDeclaration {
            proto_alias_declaration: Box::new(proto_alias_declaration),
        };
        let proto_pacakge_item_5_built =
            ProtoPacakgeItem::ProtoAliasDeclaration(proto_pacakge_item_5_built);
        // Calling user action here
        self.user_grammar
            .proto_pacakge_item(&proto_pacakge_item_5_built)?;
        self.push(
            ASTType::ProtoPacakgeItem(proto_pacakge_item_5_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1095:
    ///
    /// `ProtoPacakgeItem: ImportDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_pacakge_item_6(&mut self, _import_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_declaration = pop_item!(self, import_declaration, ImportDeclaration, context);
        let proto_pacakge_item_6_built = ProtoPacakgeItemImportDeclaration {
            import_declaration: Box::new(import_declaration),
        };
        let proto_pacakge_item_6_built =
            ProtoPacakgeItem::ImportDeclaration(proto_pacakge_item_6_built);
        // Calling user action here
        self.user_grammar
            .proto_pacakge_item(&proto_pacakge_item_6_built)?;
        self.push(
            ASTType::ProtoPacakgeItem(proto_pacakge_item_6_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1096:
    ///
    /// `ProtoConstDeclaration: Const Identifier Colon ProtoConstDeclarationGroup Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_const_declaration(
        &mut self,
        _const: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _proto_const_declaration_group: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let proto_const_declaration_group = pop_item!(
            self,
            proto_const_declaration_group,
            ProtoConstDeclarationGroup,
            context
        );
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let r#const = pop_item!(self, r#const, Const, context);
        let proto_const_declaration_built = ProtoConstDeclaration {
            r#const: Box::new(r#const),
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            proto_const_declaration_group: Box::new(proto_const_declaration_group),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .proto_const_declaration(&proto_const_declaration_built)?;
        self.push(
            ASTType::ProtoConstDeclaration(proto_const_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1097:
    ///
    /// `ProtoConstDeclarationGroup: ArrayType;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_const_declaration_group_0(&mut self, _array_type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_type = pop_item!(self, array_type, ArrayType, context);
        let proto_const_declaration_group_0_built = ProtoConstDeclarationGroupArrayType {
            array_type: Box::new(array_type),
        };
        let proto_const_declaration_group_0_built =
            ProtoConstDeclarationGroup::ArrayType(proto_const_declaration_group_0_built);
        self.push(
            ASTType::ProtoConstDeclarationGroup(proto_const_declaration_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1098:
    ///
    /// `ProtoConstDeclarationGroup: Type;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_const_declaration_group_1(&mut self, _type: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#type = pop_item!(self, r#type, Type, context);
        let proto_const_declaration_group_1_built = ProtoConstDeclarationGroupType {
            r#type: Box::new(r#type),
        };
        let proto_const_declaration_group_1_built =
            ProtoConstDeclarationGroup::Type(proto_const_declaration_group_1_built);
        self.push(
            ASTType::ProtoConstDeclarationGroup(proto_const_declaration_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1099:
    ///
    /// `ProtoTypeDefDeclaration: Type Identifier ProtoTypeDefDeclarationOpt /* Option */ Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_type_def_declaration(
        &mut self,
        _type: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _proto_type_def_declaration_opt: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let proto_type_def_declaration_opt = pop_item!(
            self,
            proto_type_def_declaration_opt,
            ProtoTypeDefDeclarationOpt,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let r#type = pop_item!(self, r#type, Type, context);
        let proto_type_def_declaration_built = ProtoTypeDefDeclaration {
            r#type: Box::new(r#type),
            identifier: Box::new(identifier),
            proto_type_def_declaration_opt,
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .proto_type_def_declaration(&proto_type_def_declaration_built)?;
        self.push(
            ASTType::ProtoTypeDefDeclaration(proto_type_def_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1100:
    ///
    /// `ProtoTypeDefDeclarationOpt /* Option<T>::Some */: Equ ArrayType;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_type_def_declaration_opt_0(
        &mut self,
        _equ: &ParseTreeType<'t>,
        _array_type: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let array_type = pop_item!(self, array_type, ArrayType, context);
        let equ = pop_item!(self, equ, Equ, context);
        let proto_type_def_declaration_opt_0_built = ProtoTypeDefDeclarationOpt {
            equ: Box::new(equ),
            array_type: Box::new(array_type),
        };
        self.push(
            ASTType::ProtoTypeDefDeclarationOpt(Some(proto_type_def_declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1101:
    ///
    /// `ProtoTypeDefDeclarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_type_def_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ProtoTypeDefDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 1102:
    ///
    /// `ProtoFunctionDeclaration: Function Identifier ProtoFunctionDeclarationOpt /* Option */ ProtoFunctionDeclarationOpt0 /* Option */ ProtoFunctionDeclarationOpt1 /* Option */ Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_function_declaration(
        &mut self,
        _function: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _proto_function_declaration_opt: &ParseTreeType<'t>,
        _proto_function_declaration_opt0: &ParseTreeType<'t>,
        _proto_function_declaration_opt1: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let proto_function_declaration_opt1 = pop_item!(
            self,
            proto_function_declaration_opt1,
            ProtoFunctionDeclarationOpt1,
            context
        );
        let proto_function_declaration_opt0 = pop_item!(
            self,
            proto_function_declaration_opt0,
            ProtoFunctionDeclarationOpt0,
            context
        );
        let proto_function_declaration_opt = pop_item!(
            self,
            proto_function_declaration_opt,
            ProtoFunctionDeclarationOpt,
            context
        );
        let identifier = pop_item!(self, identifier, Identifier, context);
        let function = pop_item!(self, function, Function, context);
        let proto_function_declaration_built = ProtoFunctionDeclaration {
            function: Box::new(function),
            identifier: Box::new(identifier),
            proto_function_declaration_opt,
            proto_function_declaration_opt0,
            proto_function_declaration_opt1,
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .proto_function_declaration(&proto_function_declaration_built)?;
        self.push(
            ASTType::ProtoFunctionDeclaration(proto_function_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1103:
    ///
    /// `ProtoFunctionDeclarationOpt1 /* Option<T>::Some */: MinusGT ScalarType;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_function_declaration_opt1_0(
        &mut self,
        _minus_g_t: &ParseTreeType<'t>,
        _scalar_type: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let scalar_type = pop_item!(self, scalar_type, ScalarType, context);
        let minus_g_t = pop_item!(self, minus_g_t, MinusGT, context);
        let proto_function_declaration_opt1_0_built = ProtoFunctionDeclarationOpt1 {
            minus_g_t: Box::new(minus_g_t),
            scalar_type: Box::new(scalar_type),
        };
        self.push(
            ASTType::ProtoFunctionDeclarationOpt1(Some(proto_function_declaration_opt1_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1104:
    ///
    /// `ProtoFunctionDeclarationOpt1 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_function_declaration_opt1_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ProtoFunctionDeclarationOpt1(None), context);
        Ok(())
    }

    /// Semantic action for production 1105:
    ///
    /// `ProtoFunctionDeclarationOpt0 /* Option<T>::Some */: PortDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_function_declaration_opt0_0(
        &mut self,
        _port_declaration: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let port_declaration = pop_item!(self, port_declaration, PortDeclaration, context);
        let proto_function_declaration_opt0_0_built = ProtoFunctionDeclarationOpt0 {
            port_declaration: Box::new(port_declaration),
        };
        self.push(
            ASTType::ProtoFunctionDeclarationOpt0(Some(proto_function_declaration_opt0_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1106:
    ///
    /// `ProtoFunctionDeclarationOpt0 /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_function_declaration_opt0_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ProtoFunctionDeclarationOpt0(None), context);
        Ok(())
    }

    /// Semantic action for production 1107:
    ///
    /// `ProtoFunctionDeclarationOpt /* Option<T>::Some */: WithGenericParameter;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_function_declaration_opt_0(
        &mut self,
        _with_generic_parameter: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let with_generic_parameter =
            pop_item!(self, with_generic_parameter, WithGenericParameter, context);
        let proto_function_declaration_opt_0_built = ProtoFunctionDeclarationOpt {
            with_generic_parameter: Box::new(with_generic_parameter),
        };
        self.push(
            ASTType::ProtoFunctionDeclarationOpt(Some(proto_function_declaration_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1108:
    ///
    /// `ProtoFunctionDeclarationOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_function_declaration_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::ProtoFunctionDeclarationOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 1109:
    ///
    /// `ProtoAliasDeclaration: Alias ProtoAliasDeclarationGroup Identifier Colon ScopedIdentifier Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_alias_declaration(
        &mut self,
        _alias: &ParseTreeType<'t>,
        _proto_alias_declaration_group: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _colon: &ParseTreeType<'t>,
        _scoped_identifier: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let scoped_identifier = pop_item!(self, scoped_identifier, ScopedIdentifier, context);
        let colon = pop_item!(self, colon, Colon, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let proto_alias_declaration_group = pop_item!(
            self,
            proto_alias_declaration_group,
            ProtoAliasDeclarationGroup,
            context
        );
        let alias = pop_item!(self, alias, Alias, context);
        let proto_alias_declaration_built = ProtoAliasDeclaration {
            alias: Box::new(alias),
            proto_alias_declaration_group: Box::new(proto_alias_declaration_group),
            identifier: Box::new(identifier),
            colon: Box::new(colon),
            scoped_identifier: Box::new(scoped_identifier),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .proto_alias_declaration(&proto_alias_declaration_built)?;
        self.push(
            ASTType::ProtoAliasDeclaration(proto_alias_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1110:
    ///
    /// `ProtoAliasDeclarationGroup: Module;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_alias_declaration_group_0(&mut self, _module: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module = pop_item!(self, module, Module, context);
        let proto_alias_declaration_group_0_built = ProtoAliasDeclarationGroupModule {
            module: Box::new(module),
        };
        let proto_alias_declaration_group_0_built =
            ProtoAliasDeclarationGroup::Module(proto_alias_declaration_group_0_built);
        self.push(
            ASTType::ProtoAliasDeclarationGroup(proto_alias_declaration_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1111:
    ///
    /// `ProtoAliasDeclarationGroup: Interface;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_alias_declaration_group_1(&mut self, _interface: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface = pop_item!(self, interface, Interface, context);
        let proto_alias_declaration_group_1_built = ProtoAliasDeclarationGroupInterface {
            interface: Box::new(interface),
        };
        let proto_alias_declaration_group_1_built =
            ProtoAliasDeclarationGroup::Interface(proto_alias_declaration_group_1_built);
        self.push(
            ASTType::ProtoAliasDeclarationGroup(proto_alias_declaration_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1112:
    ///
    /// `ProtoAliasDeclarationGroup: Package;`
    ///
    #[parol_runtime::function_name::named]
    fn proto_alias_declaration_group_2(&mut self, _package: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package = pop_item!(self, package, Package, context);
        let proto_alias_declaration_group_2_built = ProtoAliasDeclarationGroupPackage {
            package: Box::new(package),
        };
        let proto_alias_declaration_group_2_built =
            ProtoAliasDeclarationGroup::Package(proto_alias_declaration_group_2_built);
        self.push(
            ASTType::ProtoAliasDeclarationGroup(proto_alias_declaration_group_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1113:
    ///
    /// `EmbedDeclaration: Embed LParen Identifier RParen Identifier EmbedContent;`
    ///
    #[parol_runtime::function_name::named]
    fn embed_declaration(
        &mut self,
        _embed: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
        _identifier0: &ParseTreeType<'t>,
        _embed_content: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let embed_content = pop_item!(self, embed_content, EmbedContent, context);
        let identifier0 = pop_item!(self, identifier0, Identifier, context);
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let embed = pop_item!(self, embed, Embed, context);
        let embed_declaration_built = EmbedDeclaration {
            embed: Box::new(embed),
            l_paren: Box::new(l_paren),
            identifier: Box::new(identifier),
            r_paren: Box::new(r_paren),
            identifier0: Box::new(identifier0),
            embed_content: Box::new(embed_content),
        };
        // Calling user action here
        self.user_grammar
            .embed_declaration(&embed_declaration_built)?;
        self.push(ASTType::EmbedDeclaration(embed_declaration_built), context);
        Ok(())
    }

    /// Semantic action for production 1114:
    ///
    /// `EmbedContent: TripleLBrace EmbedContentList /* Vec */ TripleRBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn embed_content(
        &mut self,
        _triple_l_brace: &ParseTreeType<'t>,
        _embed_content_list: &ParseTreeType<'t>,
        _triple_r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let triple_r_brace = pop_item!(self, triple_r_brace, TripleRBrace, context);
        let embed_content_list =
            pop_and_reverse_item!(self, embed_content_list, EmbedContentList, context);
        let triple_l_brace = pop_item!(self, triple_l_brace, TripleLBrace, context);
        let embed_content_built = EmbedContent {
            triple_l_brace: Box::new(triple_l_brace),
            embed_content_list,
            triple_r_brace: Box::new(triple_r_brace),
        };
        // Calling user action here
        self.user_grammar.embed_content(&embed_content_built)?;
        self.push(ASTType::EmbedContent(embed_content_built), context);
        Ok(())
    }

    /// Semantic action for production 1115:
    ///
    /// `EmbedContentList /* Vec<T>::Push */: EmbedItem EmbedContentList;`
    ///
    #[parol_runtime::function_name::named]
    fn embed_content_list_0(
        &mut self,
        _embed_item: &ParseTreeType<'t>,
        _embed_content_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut embed_content_list = pop_item!(self, embed_content_list, EmbedContentList, context);
        let embed_item = pop_item!(self, embed_item, EmbedItem, context);
        let embed_content_list_0_built = EmbedContentList {
            embed_item: Box::new(embed_item),
        };
        // Add an element to the vector
        embed_content_list.push(embed_content_list_0_built);
        self.push(ASTType::EmbedContentList(embed_content_list), context);
        Ok(())
    }

    /// Semantic action for production 1116:
    ///
    /// `EmbedContentList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn embed_content_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let embed_content_list_1_built = Vec::new();
        self.push(
            ASTType::EmbedContentList(embed_content_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1117:
    ///
    /// `EmbedScopedIdentifier: EscapedLBrace ScopedIdentifier EscapedRBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn embed_scoped_identifier(
        &mut self,
        _escaped_l_brace: &ParseTreeType<'t>,
        _scoped_identifier: &ParseTreeType<'t>,
        _escaped_r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let escaped_r_brace = pop_item!(self, escaped_r_brace, EscapedRBrace, context);
        let scoped_identifier = pop_item!(self, scoped_identifier, ScopedIdentifier, context);
        let escaped_l_brace = pop_item!(self, escaped_l_brace, EscapedLBrace, context);
        let embed_scoped_identifier_built = EmbedScopedIdentifier {
            escaped_l_brace: Box::new(escaped_l_brace),
            scoped_identifier: Box::new(scoped_identifier),
            escaped_r_brace: Box::new(escaped_r_brace),
        };
        // Calling user action here
        self.user_grammar
            .embed_scoped_identifier(&embed_scoped_identifier_built)?;
        self.push(
            ASTType::EmbedScopedIdentifier(embed_scoped_identifier_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1118:
    ///
    /// `EmbedItem: EmbedLBrace EmbedItemList /* Vec */ EmbedRBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn embed_item_0(
        &mut self,
        _embed_l_brace: &ParseTreeType<'t>,
        _embed_item_list: &ParseTreeType<'t>,
        _embed_r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let embed_r_brace = pop_item!(self, embed_r_brace, EmbedRBrace, context);
        let embed_item_list = pop_and_reverse_item!(self, embed_item_list, EmbedItemList, context);
        let embed_l_brace = pop_item!(self, embed_l_brace, EmbedLBrace, context);
        let embed_item_0_built = EmbedItemEmbedLBraceEmbedItemListEmbedRBrace {
            embed_l_brace: Box::new(embed_l_brace),
            embed_item_list,
            embed_r_brace: Box::new(embed_r_brace),
        };
        let embed_item_0_built = EmbedItem::EmbedLBraceEmbedItemListEmbedRBrace(embed_item_0_built);
        // Calling user action here
        self.user_grammar.embed_item(&embed_item_0_built)?;
        self.push(ASTType::EmbedItem(embed_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 1119:
    ///
    /// `EmbedItemList /* Vec<T>::Push */: EmbedItem EmbedItemList;`
    ///
    #[parol_runtime::function_name::named]
    fn embed_item_list_0(
        &mut self,
        _embed_item: &ParseTreeType<'t>,
        _embed_item_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut embed_item_list = pop_item!(self, embed_item_list, EmbedItemList, context);
        let embed_item = pop_item!(self, embed_item, EmbedItem, context);
        let embed_item_list_0_built = EmbedItemList {
            embed_item: Box::new(embed_item),
        };
        // Add an element to the vector
        embed_item_list.push(embed_item_list_0_built);
        self.push(ASTType::EmbedItemList(embed_item_list), context);
        Ok(())
    }

    /// Semantic action for production 1120:
    ///
    /// `EmbedItemList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn embed_item_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let embed_item_list_1_built = Vec::new();
        self.push(ASTType::EmbedItemList(embed_item_list_1_built), context);
        Ok(())
    }

    /// Semantic action for production 1121:
    ///
    /// `EmbedItem: EmbedScopedIdentifier;`
    ///
    #[parol_runtime::function_name::named]
    fn embed_item_1(&mut self, _embed_scoped_identifier: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let embed_scoped_identifier = pop_item!(
            self,
            embed_scoped_identifier,
            EmbedScopedIdentifier,
            context
        );
        let embed_item_1_built = EmbedItemEmbedScopedIdentifier {
            embed_scoped_identifier: Box::new(embed_scoped_identifier),
        };
        let embed_item_1_built = EmbedItem::EmbedScopedIdentifier(embed_item_1_built);
        // Calling user action here
        self.user_grammar.embed_item(&embed_item_1_built)?;
        self.push(ASTType::EmbedItem(embed_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 1122:
    ///
    /// `EmbedItem: Any;`
    ///
    #[parol_runtime::function_name::named]
    fn embed_item_2(&mut self, _any: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let any = pop_item!(self, any, Any, context);
        let embed_item_2_built = EmbedItemAny { any: Box::new(any) };
        let embed_item_2_built = EmbedItem::Any(embed_item_2_built);
        // Calling user action here
        self.user_grammar.embed_item(&embed_item_2_built)?;
        self.push(ASTType::EmbedItem(embed_item_2_built), context);
        Ok(())
    }

    /// Semantic action for production 1123:
    ///
    /// `IncludeDeclaration: Include LParen Identifier Comma StringLiteral RParen Semicolon;`
    ///
    #[parol_runtime::function_name::named]
    fn include_declaration(
        &mut self,
        _include: &ParseTreeType<'t>,
        _l_paren: &ParseTreeType<'t>,
        _identifier: &ParseTreeType<'t>,
        _comma: &ParseTreeType<'t>,
        _string_literal: &ParseTreeType<'t>,
        _r_paren: &ParseTreeType<'t>,
        _semicolon: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let semicolon = pop_item!(self, semicolon, Semicolon, context);
        let r_paren = pop_item!(self, r_paren, RParen, context);
        let string_literal = pop_item!(self, string_literal, StringLiteral, context);
        let comma = pop_item!(self, comma, Comma, context);
        let identifier = pop_item!(self, identifier, Identifier, context);
        let l_paren = pop_item!(self, l_paren, LParen, context);
        let include = pop_item!(self, include, Include, context);
        let include_declaration_built = IncludeDeclaration {
            include: Box::new(include),
            l_paren: Box::new(l_paren),
            identifier: Box::new(identifier),
            comma: Box::new(comma),
            string_literal: Box::new(string_literal),
            r_paren: Box::new(r_paren),
            semicolon: Box::new(semicolon),
        };
        // Calling user action here
        self.user_grammar
            .include_declaration(&include_declaration_built)?;
        self.push(
            ASTType::IncludeDeclaration(include_declaration_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1124:
    ///
    /// `DescriptionGroup: DescriptionGroupList /* Vec */ DescriptionGroupGroup;`
    ///
    #[parol_runtime::function_name::named]
    fn description_group(
        &mut self,
        _description_group_list: &ParseTreeType<'t>,
        _description_group_group: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description_group_group = pop_item!(
            self,
            description_group_group,
            DescriptionGroupGroup,
            context
        );
        let description_group_list =
            pop_and_reverse_item!(self, description_group_list, DescriptionGroupList, context);
        let description_group_built = DescriptionGroup {
            description_group_list,
            description_group_group: Box::new(description_group_group),
        };
        // Calling user action here
        self.user_grammar
            .description_group(&description_group_built)?;
        self.push(ASTType::DescriptionGroup(description_group_built), context);
        Ok(())
    }

    /// Semantic action for production 1125:
    ///
    /// `DescriptionGroupGroup: LBrace DescriptionGroupGroupList /* Vec */ RBrace;`
    ///
    #[parol_runtime::function_name::named]
    fn description_group_group_0(
        &mut self,
        _l_brace: &ParseTreeType<'t>,
        _description_group_group_list: &ParseTreeType<'t>,
        _r_brace: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r_brace = pop_item!(self, r_brace, RBrace, context);
        let description_group_group_list = pop_and_reverse_item!(
            self,
            description_group_group_list,
            DescriptionGroupGroupList,
            context
        );
        let l_brace = pop_item!(self, l_brace, LBrace, context);
        let description_group_group_0_built =
            DescriptionGroupGroupLBraceDescriptionGroupGroupListRBrace {
                l_brace: Box::new(l_brace),
                description_group_group_list,
                r_brace: Box::new(r_brace),
            };
        let description_group_group_0_built =
            DescriptionGroupGroup::LBraceDescriptionGroupGroupListRBrace(
                description_group_group_0_built,
            );
        self.push(
            ASTType::DescriptionGroupGroup(description_group_group_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1126:
    ///
    /// `DescriptionGroupGroupList /* Vec<T>::Push */: DescriptionGroup DescriptionGroupGroupList;`
    ///
    #[parol_runtime::function_name::named]
    fn description_group_group_list_0(
        &mut self,
        _description_group: &ParseTreeType<'t>,
        _description_group_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut description_group_group_list = pop_item!(
            self,
            description_group_group_list,
            DescriptionGroupGroupList,
            context
        );
        let description_group = pop_item!(self, description_group, DescriptionGroup, context);
        let description_group_group_list_0_built = DescriptionGroupGroupList {
            description_group: Box::new(description_group),
        };
        // Add an element to the vector
        description_group_group_list.push(description_group_group_list_0_built);
        self.push(
            ASTType::DescriptionGroupGroupList(description_group_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1127:
    ///
    /// `DescriptionGroupGroupList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn description_group_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description_group_group_list_1_built = Vec::new();
        self.push(
            ASTType::DescriptionGroupGroupList(description_group_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1128:
    ///
    /// `DescriptionGroupGroup: DescriptionItem;`
    ///
    #[parol_runtime::function_name::named]
    fn description_group_group_1(&mut self, _description_item: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description_item = pop_item!(self, description_item, DescriptionItem, context);
        let description_group_group_1_built = DescriptionGroupGroupDescriptionItem {
            description_item: Box::new(description_item),
        };
        let description_group_group_1_built =
            DescriptionGroupGroup::DescriptionItem(description_group_group_1_built);
        self.push(
            ASTType::DescriptionGroupGroup(description_group_group_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1129:
    ///
    /// `DescriptionGroupList /* Vec<T>::Push */: Attribute DescriptionGroupList;`
    ///
    #[parol_runtime::function_name::named]
    fn description_group_list_0(
        &mut self,
        _attribute: &ParseTreeType<'t>,
        _description_group_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut description_group_list =
            pop_item!(self, description_group_list, DescriptionGroupList, context);
        let attribute = pop_item!(self, attribute, Attribute, context);
        let description_group_list_0_built = DescriptionGroupList {
            attribute: Box::new(attribute),
        };
        // Add an element to the vector
        description_group_list.push(description_group_list_0_built);
        self.push(
            ASTType::DescriptionGroupList(description_group_list),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1130:
    ///
    /// `DescriptionGroupList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn description_group_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let description_group_list_1_built = Vec::new();
        self.push(
            ASTType::DescriptionGroupList(description_group_list_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1131:
    ///
    /// `DescriptionItem: DescriptionItemOpt /* Option */ PublicDescriptionItem;`
    ///
    #[parol_runtime::function_name::named]
    fn description_item_0(
        &mut self,
        _description_item_opt: &ParseTreeType<'t>,
        _public_description_item: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let public_description_item = pop_item!(
            self,
            public_description_item,
            PublicDescriptionItem,
            context
        );
        let description_item_opt =
            pop_item!(self, description_item_opt, DescriptionItemOpt, context);
        let description_item_0_built = DescriptionItemDescriptionItemOptPublicDescriptionItem {
            description_item_opt,
            public_description_item: Box::new(public_description_item),
        };
        let description_item_0_built =
            DescriptionItem::DescriptionItemOptPublicDescriptionItem(description_item_0_built);
        // Calling user action here
        self.user_grammar
            .description_item(&description_item_0_built)?;
        self.push(ASTType::DescriptionItem(description_item_0_built), context);
        Ok(())
    }

    /// Semantic action for production 1132:
    ///
    /// `DescriptionItem: ImportDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn description_item_1(&mut self, _import_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let import_declaration = pop_item!(self, import_declaration, ImportDeclaration, context);
        let description_item_1_built = DescriptionItemImportDeclaration {
            import_declaration: Box::new(import_declaration),
        };
        let description_item_1_built = DescriptionItem::ImportDeclaration(description_item_1_built);
        // Calling user action here
        self.user_grammar
            .description_item(&description_item_1_built)?;
        self.push(ASTType::DescriptionItem(description_item_1_built), context);
        Ok(())
    }

    /// Semantic action for production 1133:
    ///
    /// `DescriptionItem: BindDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn description_item_2(&mut self, _bind_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let bind_declaration = pop_item!(self, bind_declaration, BindDeclaration, context);
        let description_item_2_built = DescriptionItemBindDeclaration {
            bind_declaration: Box::new(bind_declaration),
        };
        let description_item_2_built = DescriptionItem::BindDeclaration(description_item_2_built);
        // Calling user action here
        self.user_grammar
            .description_item(&description_item_2_built)?;
        self.push(ASTType::DescriptionItem(description_item_2_built), context);
        Ok(())
    }

    /// Semantic action for production 1134:
    ///
    /// `DescriptionItem: EmbedDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn description_item_3(&mut self, _embed_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let embed_declaration = pop_item!(self, embed_declaration, EmbedDeclaration, context);
        let description_item_3_built = DescriptionItemEmbedDeclaration {
            embed_declaration: Box::new(embed_declaration),
        };
        let description_item_3_built = DescriptionItem::EmbedDeclaration(description_item_3_built);
        // Calling user action here
        self.user_grammar
            .description_item(&description_item_3_built)?;
        self.push(ASTType::DescriptionItem(description_item_3_built), context);
        Ok(())
    }

    /// Semantic action for production 1135:
    ///
    /// `DescriptionItem: IncludeDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn description_item_4(&mut self, _include_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let include_declaration = pop_item!(self, include_declaration, IncludeDeclaration, context);
        let description_item_4_built = DescriptionItemIncludeDeclaration {
            include_declaration: Box::new(include_declaration),
        };
        let description_item_4_built =
            DescriptionItem::IncludeDeclaration(description_item_4_built);
        // Calling user action here
        self.user_grammar
            .description_item(&description_item_4_built)?;
        self.push(ASTType::DescriptionItem(description_item_4_built), context);
        Ok(())
    }

    /// Semantic action for production 1136:
    ///
    /// `DescriptionItemOpt /* Option<T>::Some */: Pub;`
    ///
    #[parol_runtime::function_name::named]
    fn description_item_opt_0(&mut self, _pub: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let r#pub = pop_item!(self, r#pub, Pub, context);
        let description_item_opt_0_built = DescriptionItemOpt {
            r#pub: Box::new(r#pub),
        };
        self.push(
            ASTType::DescriptionItemOpt(Some(description_item_opt_0_built)),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1137:
    ///
    /// `DescriptionItemOpt /* Option<T>::None */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn description_item_opt_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        self.push(ASTType::DescriptionItemOpt(None), context);
        Ok(())
    }

    /// Semantic action for production 1138:
    ///
    /// `PublicDescriptionItem: ModuleDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn public_description_item_0(&mut self, _module_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let module_declaration = pop_item!(self, module_declaration, ModuleDeclaration, context);
        let public_description_item_0_built = PublicDescriptionItemModuleDeclaration {
            module_declaration: Box::new(module_declaration),
        };
        let public_description_item_0_built =
            PublicDescriptionItem::ModuleDeclaration(public_description_item_0_built);
        // Calling user action here
        self.user_grammar
            .public_description_item(&public_description_item_0_built)?;
        self.push(
            ASTType::PublicDescriptionItem(public_description_item_0_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1139:
    ///
    /// `PublicDescriptionItem: InterfaceDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn public_description_item_1(
        &mut self,
        _interface_declaration: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let interface_declaration =
            pop_item!(self, interface_declaration, InterfaceDeclaration, context);
        let public_description_item_1_built = PublicDescriptionItemInterfaceDeclaration {
            interface_declaration: Box::new(interface_declaration),
        };
        let public_description_item_1_built =
            PublicDescriptionItem::InterfaceDeclaration(public_description_item_1_built);
        // Calling user action here
        self.user_grammar
            .public_description_item(&public_description_item_1_built)?;
        self.push(
            ASTType::PublicDescriptionItem(public_description_item_1_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1140:
    ///
    /// `PublicDescriptionItem: PackageDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn public_description_item_2(
        &mut self,
        _package_declaration: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let package_declaration = pop_item!(self, package_declaration, PackageDeclaration, context);
        let public_description_item_2_built = PublicDescriptionItemPackageDeclaration {
            package_declaration: Box::new(package_declaration),
        };
        let public_description_item_2_built =
            PublicDescriptionItem::PackageDeclaration(public_description_item_2_built);
        // Calling user action here
        self.user_grammar
            .public_description_item(&public_description_item_2_built)?;
        self.push(
            ASTType::PublicDescriptionItem(public_description_item_2_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1141:
    ///
    /// `PublicDescriptionItem: AliasDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn public_description_item_3(&mut self, _alias_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let alias_declaration = pop_item!(self, alias_declaration, AliasDeclaration, context);
        let public_description_item_3_built = PublicDescriptionItemAliasDeclaration {
            alias_declaration: Box::new(alias_declaration),
        };
        let public_description_item_3_built =
            PublicDescriptionItem::AliasDeclaration(public_description_item_3_built);
        // Calling user action here
        self.user_grammar
            .public_description_item(&public_description_item_3_built)?;
        self.push(
            ASTType::PublicDescriptionItem(public_description_item_3_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1142:
    ///
    /// `PublicDescriptionItem: ProtoDeclaration;`
    ///
    #[parol_runtime::function_name::named]
    fn public_description_item_4(&mut self, _proto_declaration: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let proto_declaration = pop_item!(self, proto_declaration, ProtoDeclaration, context);
        let public_description_item_4_built = PublicDescriptionItemProtoDeclaration {
            proto_declaration: Box::new(proto_declaration),
        };
        let public_description_item_4_built =
            PublicDescriptionItem::ProtoDeclaration(public_description_item_4_built);
        // Calling user action here
        self.user_grammar
            .public_description_item(&public_description_item_4_built)?;
        self.push(
            ASTType::PublicDescriptionItem(public_description_item_4_built),
            context,
        );
        Ok(())
    }

    /// Semantic action for production 1143:
    ///
    /// `Veryl: Start VerylList /* Vec */;`
    ///
    #[parol_runtime::function_name::named]
    fn veryl(&mut self, _start: &ParseTreeType<'t>, _veryl_list: &ParseTreeType<'t>) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let veryl_list = pop_and_reverse_item!(self, veryl_list, VerylList, context);
        let start = pop_item!(self, start, Start, context);
        let veryl_built = Veryl {
            start: Box::new(start),
            veryl_list,
        };
        // Calling user action here
        self.user_grammar.veryl(&veryl_built)?;
        self.push(ASTType::Veryl(veryl_built), context);
        Ok(())
    }

    /// Semantic action for production 1144:
    ///
    /// `VerylList /* Vec<T>::Push */: DescriptionGroup VerylList;`
    ///
    #[parol_runtime::function_name::named]
    fn veryl_list_0(
        &mut self,
        _description_group: &ParseTreeType<'t>,
        _veryl_list: &ParseTreeType<'t>,
    ) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let mut veryl_list = pop_item!(self, veryl_list, VerylList, context);
        let description_group = pop_item!(self, description_group, DescriptionGroup, context);
        let veryl_list_0_built = VerylList {
            description_group: Box::new(description_group),
        };
        // Add an element to the vector
        veryl_list.push(veryl_list_0_built);
        self.push(ASTType::VerylList(veryl_list), context);
        Ok(())
    }

    /// Semantic action for production 1145:
    ///
    /// `VerylList /* Vec<T>::New */: ;`
    ///
    #[parol_runtime::function_name::named]
    fn veryl_list_1(&mut self) -> Result<()> {
        let context = function_name!();
        trace!("{}", self.trace_item_stack(context));
        let veryl_list_1_built = Vec::new();
        self.push(ASTType::VerylList(veryl_list_1_built), context);
        Ok(())
    }
}

impl<'t> UserActionsTrait<'t> for VerylGrammarAuto<'t, '_> {
    ///
    /// This function is implemented automatically for the user's item VerylGrammar.
    ///
    fn call_semantic_action_for_production_number(
        &mut self,
        prod_num: usize,
        children: &[ParseTreeType<'t>],
    ) -> Result<()> {
        match prod_num {
            0 => self.comments_term(&children[0]),
            1 => self.string_literal_term(&children[0]),
            2 => self.exponent_term(&children[0]),
            3 => self.fixed_point_term(&children[0]),
            4 => self.based_term(&children[0]),
            5 => self.all_bit_term(&children[0]),
            6 => self.base_less_term(&children[0]),
            7 => self.minus_colon_term(&children[0]),
            8 => self.minus_g_t_term(&children[0]),
            9 => self.l_t_minus_term(&children[0]),
            10 => self.plus_colon_term(&children[0]),
            11 => self.assignment_operator_term(&children[0]),
            12 => self.diamond_operator_term(&children[0]),
            13 => self.operator12_term(&children[0]),
            14 => self.operator11_term(&children[0]),
            15 => self.operator10_term(&children[0]),
            16 => self.operator09_term(&children[0]),
            17 => self.operator08_term(&children[0]),
            18 => self.operator07_term(&children[0]),
            19 => self.operator03_term(&children[0]),
            20 => self.operator02_term(&children[0]),
            21 => self.operator06_term(&children[0]),
            22 => self.operator05_term(&children[0]),
            23 => self.operator04_term(&children[0]),
            24 => self.unary_operator_term(&children[0]),
            25 => self.colon_colon_l_angle_term(&children[0]),
            26 => self.colon_colon_term(&children[0]),
            27 => self.colon_term(&children[0]),
            28 => self.comma_term(&children[0]),
            29 => self.dot_dot_equ_term(&children[0]),
            30 => self.dot_dot_term(&children[0]),
            31 => self.dot_term(&children[0]),
            32 => self.equ_term(&children[0]),
            33 => self.hash_l_bracket_term(&children[0]),
            34 => self.hash_term(&children[0]),
            35 => self.l_angle_term(&children[0]),
            36 => self.question_term(&children[0]),
            37 => self.quote_l_brace_term(&children[0]),
            38 => self.quote_term(&children[0]),
            39 => self.escaped_l_brace_term(&children[0]),
            40 => self.triple_l_brace_term(&children[0]),
            41 => self.l_brace_term(&children[0]),
            42 => self.l_bracket_term(&children[0]),
            43 => self.l_paren_term(&children[0]),
            44 => self.r_angle_term(&children[0]),
            45 => self.escaped_r_brace_term(&children[0]),
            46 => self.triple_r_brace_term(&children[0]),
            47 => self.r_brace_term(&children[0]),
            48 => self.r_bracket_term(&children[0]),
            49 => self.r_paren_term(&children[0]),
            50 => self.semicolon_term(&children[0]),
            51 => self.star_term(&children[0]),
            52 => self.alias_term(&children[0]),
            53 => self.always_comb_term(&children[0]),
            54 => self.always_ff_term(&children[0]),
            55 => self.assign_term(&children[0]),
            56 => self.as_term(&children[0]),
            57 => self.bind_term(&children[0]),
            58 => self.bit_term(&children[0]),
            59 => self.bool_term(&children[0]),
            60 => self.case_term(&children[0]),
            61 => self.clock_term(&children[0]),
            62 => self.clock_posedge_term(&children[0]),
            63 => self.clock_negedge_term(&children[0]),
            64 => self.connect_term(&children[0]),
            65 => self.const_term(&children[0]),
            66 => self.converse_term(&children[0]),
            67 => self.default_term(&children[0]),
            68 => self.else_term(&children[0]),
            69 => self.embed_term(&children[0]),
            70 => self.enum_term(&children[0]),
            71 => self.f32_term(&children[0]),
            72 => self.f64_term(&children[0]),
            73 => self.false_term(&children[0]),
            74 => self.final_term(&children[0]),
            75 => self.for_term(&children[0]),
            76 => self.function_term(&children[0]),
            77 => self.i8_term(&children[0]),
            78 => self.i16_term(&children[0]),
            79 => self.i32_term(&children[0]),
            80 => self.i64_term(&children[0]),
            81 => self.if_reset_term(&children[0]),
            82 => self.if_term(&children[0]),
            83 => self.import_term(&children[0]),
            84 => self.include_term(&children[0]),
            85 => self.initial_term(&children[0]),
            86 => self.inout_term(&children[0]),
            87 => self.input_term(&children[0]),
            88 => self.inside_term(&children[0]),
            89 => self.inst_term(&children[0]),
            90 => self.interface_term(&children[0]),
            91 => self.in_term(&children[0]),
            92 => self.let_term(&children[0]),
            93 => self.logic_term(&children[0]),
            94 => self.lsb_term(&children[0]),
            95 => self.modport_term(&children[0]),
            96 => self.module_term(&children[0]),
            97 => self.msb_term(&children[0]),
            98 => self.output_term(&children[0]),
            99 => self.outside_term(&children[0]),
            100 => self.package_term(&children[0]),
            101 => self.param_term(&children[0]),
            102 => self.proto_term(&children[0]),
            103 => self.pub_term(&children[0]),
            104 => self.repeat_term(&children[0]),
            105 => self.reset_term(&children[0]),
            106 => self.reset_async_high_term(&children[0]),
            107 => self.reset_async_low_term(&children[0]),
            108 => self.reset_sync_high_term(&children[0]),
            109 => self.reset_sync_low_term(&children[0]),
            110 => self.return_term(&children[0]),
            111 => self.rev_term(&children[0]),
            112 => self.break_term(&children[0]),
            113 => self.same_term(&children[0]),
            114 => self.signed_term(&children[0]),
            115 => self.step_term(&children[0]),
            116 => self.string_term(&children[0]),
            117 => self.struct_term(&children[0]),
            118 => self.switch_term(&children[0]),
            119 => self.tri_term(&children[0]),
            120 => self.true_term(&children[0]),
            121 => self.type_term(&children[0]),
            122 => self.u8_term(&children[0]),
            123 => self.u16_term(&children[0]),
            124 => self.u32_term(&children[0]),
            125 => self.u64_term(&children[0]),
            126 => self.union_term(&children[0]),
            127 => self.unsafe_term(&children[0]),
            128 => self.var_term(&children[0]),
            129 => self.dollar_identifier_term(&children[0]),
            130 => self.identifier_term(&children[0]),
            131 => self.any_term(&children[0]),
            132 => self.comments(&children[0]),
            133 => self.comments_opt_0(&children[0]),
            134 => self.comments_opt_1(),
            135 => self.start_token(&children[0]),
            136 => self.string_literal_token(&children[0], &children[1]),
            137 => self.exponent_token(&children[0], &children[1]),
            138 => self.fixed_point_token(&children[0], &children[1]),
            139 => self.based_token(&children[0], &children[1]),
            140 => self.base_less_token(&children[0], &children[1]),
            141 => self.all_bit_token(&children[0], &children[1]),
            142 => self.assignment_operator_token(&children[0], &children[1]),
            143 => self.diamond_operator_token(&children[0], &children[1]),
            144 => self.operator02_token(&children[0], &children[1]),
            145 => self.operator03_token(&children[0], &children[1]),
            146 => self.operator04_token(&children[0], &children[1]),
            147 => self.operator05_token(&children[0], &children[1]),
            148 => self.operator06_token(&children[0], &children[1]),
            149 => self.operator07_token(&children[0], &children[1]),
            150 => self.operator08_token(&children[0], &children[1]),
            151 => self.operator09_token(&children[0], &children[1]),
            152 => self.operator10_token(&children[0], &children[1]),
            153 => self.operator11_token(&children[0], &children[1]),
            154 => self.operator12_token(&children[0], &children[1]),
            155 => self.unary_operator_token(&children[0], &children[1]),
            156 => self.colon_token(&children[0], &children[1]),
            157 => self.colon_colon_l_angle_token(&children[0], &children[1]),
            158 => self.colon_colon_token(&children[0], &children[1]),
            159 => self.comma_token(&children[0], &children[1]),
            160 => self.dot_dot_token(&children[0], &children[1]),
            161 => self.dot_dot_equ_token(&children[0], &children[1]),
            162 => self.dot_token(&children[0], &children[1]),
            163 => self.equ_token(&children[0], &children[1]),
            164 => self.hash_l_bracket_token(&children[0], &children[1]),
            165 => self.hash_token(&children[0], &children[1]),
            166 => self.question_token(&children[0], &children[1]),
            167 => self.quote_l_brace_token(&children[0], &children[1]),
            168 => self.quote_token(&children[0], &children[1]),
            169 => self.l_angle_token(&children[0], &children[1]),
            170 => self.embed_l_brace_token(&children[0]),
            171 => self.escaped_l_brace_token(&children[0]),
            172 => self.triple_l_brace_token(&children[0]),
            173 => self.l_brace_token(&children[0], &children[1]),
            174 => self.l_bracket_token(&children[0], &children[1]),
            175 => self.l_paren_token(&children[0], &children[1]),
            176 => self.l_t_minus_token(&children[0], &children[1]),
            177 => self.minus_colon_token(&children[0], &children[1]),
            178 => self.minus_g_t_token(&children[0], &children[1]),
            179 => self.plus_colon_token(&children[0], &children[1]),
            180 => self.r_angle_token(&children[0], &children[1]),
            181 => self.embed_r_brace_token(&children[0]),
            182 => self.escaped_r_brace_token(&children[0]),
            183 => self.triple_r_brace_token(&children[0], &children[1]),
            184 => self.r_brace_token(&children[0], &children[1]),
            185 => self.r_bracket_token(&children[0], &children[1]),
            186 => self.r_paren_token(&children[0], &children[1]),
            187 => self.semicolon_token(&children[0], &children[1]),
            188 => self.star_token(&children[0], &children[1]),
            189 => self.alias_token(&children[0], &children[1]),
            190 => self.always_comb_token(&children[0], &children[1]),
            191 => self.always_ff_token(&children[0], &children[1]),
            192 => self.as_token(&children[0], &children[1]),
            193 => self.assign_token(&children[0], &children[1]),
            194 => self.bind_token(&children[0], &children[1]),
            195 => self.bit_token(&children[0], &children[1]),
            196 => self.bool_token(&children[0], &children[1]),
            197 => self.case_token(&children[0], &children[1]),
            198 => self.clock_token(&children[0], &children[1]),
            199 => self.clock_posedge_token(&children[0], &children[1]),
            200 => self.clock_negedge_token(&children[0], &children[1]),
            201 => self.connect_token(&children[0], &children[1]),
            202 => self.const_token(&children[0], &children[1]),
            203 => self.converse_token(&children[0], &children[1]),
            204 => self.default_token(&children[0], &children[1]),
            205 => self.else_token(&children[0], &children[1]),
            206 => self.embed_token(&children[0], &children[1]),
            207 => self.enum_token(&children[0], &children[1]),
            208 => self.f32_token(&children[0], &children[1]),
            209 => self.f64_token(&children[0], &children[1]),
            210 => self.false_token(&children[0], &children[1]),
            211 => self.final_token(&children[0], &children[1]),
            212 => self.for_token(&children[0], &children[1]),
            213 => self.function_token(&children[0], &children[1]),
            214 => self.i8_token(&children[0], &children[1]),
            215 => self.i16_token(&children[0], &children[1]),
            216 => self.i32_token(&children[0], &children[1]),
            217 => self.i64_token(&children[0], &children[1]),
            218 => self.if_reset_token(&children[0], &children[1]),
            219 => self.if_token(&children[0], &children[1]),
            220 => self.import_token(&children[0], &children[1]),
            221 => self.include_token(&children[0], &children[1]),
            222 => self.initial_token(&children[0], &children[1]),
            223 => self.inout_token(&children[0], &children[1]),
            224 => self.input_token(&children[0], &children[1]),
            225 => self.inside_token(&children[0], &children[1]),
            226 => self.inst_token(&children[0], &children[1]),
            227 => self.interface_token(&children[0], &children[1]),
            228 => self.in_token(&children[0], &children[1]),
            229 => self.let_token(&children[0], &children[1]),
            230 => self.logic_token(&children[0], &children[1]),
            231 => self.lsb_token(&children[0], &children[1]),
            232 => self.modport_token(&children[0], &children[1]),
            233 => self.module_token(&children[0], &children[1]),
            234 => self.msb_token(&children[0], &children[1]),
            235 => self.output_token(&children[0], &children[1]),
            236 => self.outside_token(&children[0], &children[1]),
            237 => self.package_token(&children[0], &children[1]),
            238 => self.param_token(&children[0], &children[1]),
            239 => self.proto_token(&children[0], &children[1]),
            240 => self.pub_token(&children[0], &children[1]),
            241 => self.repeat_token(&children[0], &children[1]),
            242 => self.reset_token(&children[0], &children[1]),
            243 => self.reset_async_high_token(&children[0], &children[1]),
            244 => self.reset_async_low_token(&children[0], &children[1]),
            245 => self.reset_sync_high_token(&children[0], &children[1]),
            246 => self.reset_sync_low_token(&children[0], &children[1]),
            247 => self.return_token(&children[0], &children[1]),
            248 => self.rev_token(&children[0], &children[1]),
            249 => self.break_token(&children[0], &children[1]),
            250 => self.same_token(&children[0], &children[1]),
            251 => self.signed_token(&children[0], &children[1]),
            252 => self.step_token(&children[0], &children[1]),
            253 => self.string_token(&children[0], &children[1]),
            254 => self.struct_token(&children[0], &children[1]),
            255 => self.switch_token(&children[0], &children[1]),
            256 => self.tri_token(&children[0], &children[1]),
            257 => self.true_token(&children[0], &children[1]),
            258 => self.type_token(&children[0], &children[1]),
            259 => self.u8_token(&children[0], &children[1]),
            260 => self.u16_token(&children[0], &children[1]),
            261 => self.u32_token(&children[0], &children[1]),
            262 => self.u64_token(&children[0], &children[1]),
            263 => self.union_token(&children[0], &children[1]),
            264 => self.unsafe_token(&children[0], &children[1]),
            265 => self.var_token(&children[0], &children[1]),
            266 => self.dollar_identifier_token(&children[0], &children[1]),
            267 => self.identifier_token(&children[0], &children[1]),
            268 => self.any_token(&children[0]),
            269 => self.start(&children[0]),
            270 => self.string_literal(&children[0]),
            271 => self.exponent(&children[0]),
            272 => self.fixed_point(&children[0]),
            273 => self.based(&children[0]),
            274 => self.base_less(&children[0]),
            275 => self.all_bit(&children[0]),
            276 => self.assignment_operator(&children[0]),
            277 => self.diamond_operator(&children[0]),
            278 => self.operator02(&children[0]),
            279 => self.operator03(&children[0]),
            280 => self.operator04(&children[0]),
            281 => self.operator05(&children[0]),
            282 => self.operator06(&children[0]),
            283 => self.operator07(&children[0]),
            284 => self.operator08(&children[0]),
            285 => self.operator09(&children[0]),
            286 => self.operator10(&children[0]),
            287 => self.operator11(&children[0]),
            288 => self.operator12(&children[0]),
            289 => self.unary_operator(&children[0]),
            290 => self.colon(&children[0]),
            291 => self.colon_colon_l_angle(&children[0]),
            292 => self.colon_colon(&children[0]),
            293 => self.comma(&children[0]),
            294 => self.dot_dot(&children[0]),
            295 => self.dot_dot_equ(&children[0]),
            296 => self.dot(&children[0]),
            297 => self.equ(&children[0]),
            298 => self.hash_l_bracket(&children[0]),
            299 => self.hash(&children[0]),
            300 => self.question(&children[0]),
            301 => self.quote_l_brace(&children[0]),
            302 => self.quote(&children[0]),
            303 => self.l_angle(&children[0]),
            304 => self.embed_l_brace(&children[0]),
            305 => self.escaped_l_brace(&children[0]),
            306 => self.triple_l_brace(&children[0]),
            307 => self.l_brace(&children[0]),
            308 => self.l_bracket(&children[0]),
            309 => self.l_paren(&children[0]),
            310 => self.l_t_minus(&children[0]),
            311 => self.minus_colon(&children[0]),
            312 => self.minus_g_t(&children[0]),
            313 => self.plus_colon(&children[0]),
            314 => self.r_angle(&children[0]),
            315 => self.embed_r_brace(&children[0]),
            316 => self.escaped_r_brace(&children[0]),
            317 => self.triple_r_brace(&children[0]),
            318 => self.r_brace(&children[0]),
            319 => self.r_bracket(&children[0]),
            320 => self.r_paren(&children[0]),
            321 => self.semicolon(&children[0]),
            322 => self.star(&children[0]),
            323 => self.alias(&children[0]),
            324 => self.always_comb(&children[0]),
            325 => self.always_ff(&children[0]),
            326 => self.r#as(&children[0]),
            327 => self.assign(&children[0]),
            328 => self.bind(&children[0]),
            329 => self.bit(&children[0]),
            330 => self.bool(&children[0]),
            331 => self.r#break(&children[0]),
            332 => self.case(&children[0]),
            333 => self.clock(&children[0]),
            334 => self.clock_posedge(&children[0]),
            335 => self.clock_negedge(&children[0]),
            336 => self.connect(&children[0]),
            337 => self.r#const(&children[0]),
            338 => self.converse(&children[0]),
            339 => self.defaul(&children[0]),
            340 => self.r#else(&children[0]),
            341 => self.embed(&children[0]),
            342 => self.r#enum(&children[0]),
            343 => self.f32(&children[0]),
            344 => self.f64(&children[0]),
            345 => self.r#false(&children[0]),
            346 => self.r#final(&children[0]),
            347 => self.r#for(&children[0]),
            348 => self.function(&children[0]),
            349 => self.i8(&children[0]),
            350 => self.i16(&children[0]),
            351 => self.i32(&children[0]),
            352 => self.i64(&children[0]),
            353 => self.r#if(&children[0]),
            354 => self.if_reset(&children[0]),
            355 => self.import(&children[0]),
            356 => self.r#in(&children[0]),
            357 => self.include(&children[0]),
            358 => self.initial(&children[0]),
            359 => self.inout(&children[0]),
            360 => self.input(&children[0]),
            361 => self.inside(&children[0]),
            362 => self.inst(&children[0]),
            363 => self.interface(&children[0]),
            364 => self.r#let(&children[0]),
            365 => self.logic(&children[0]),
            366 => self.lsb(&children[0]),
            367 => self.modport(&children[0]),
            368 => self.module(&children[0]),
            369 => self.msb(&children[0]),
            370 => self.output(&children[0]),
            371 => self.outside(&children[0]),
            372 => self.package(&children[0]),
            373 => self.param(&children[0]),
            374 => self.proto(&children[0]),
            375 => self.r#pub(&children[0]),
            376 => self.repeat(&children[0]),
            377 => self.reset(&children[0]),
            378 => self.reset_async_high(&children[0]),
            379 => self.reset_async_low(&children[0]),
            380 => self.reset_sync_high(&children[0]),
            381 => self.reset_sync_low(&children[0]),
            382 => self.r#return(&children[0]),
            383 => self.rev(&children[0]),
            384 => self.same(&children[0]),
            385 => self.signed(&children[0]),
            386 => self.step(&children[0]),
            387 => self.strin(&children[0]),
            388 => self.r#struct(&children[0]),
            389 => self.switch(&children[0]),
            390 => self.tri(&children[0]),
            391 => self.r#true(&children[0]),
            392 => self.r#type(&children[0]),
            393 => self.u8(&children[0]),
            394 => self.u16(&children[0]),
            395 => self.u32(&children[0]),
            396 => self.u64(&children[0]),
            397 => self.r#union(&children[0]),
            398 => self.r#unsafe(&children[0]),
            399 => self.var(&children[0]),
            400 => self.dollar_identifier(&children[0]),
            401 => self.identifier(&children[0]),
            402 => self.any(&children[0]),
            403 => self.number_0(&children[0]),
            404 => self.number_1(&children[0]),
            405 => self.integral_number_0(&children[0]),
            406 => self.integral_number_1(&children[0]),
            407 => self.integral_number_2(&children[0]),
            408 => self.real_number_0(&children[0]),
            409 => self.real_number_1(&children[0]),
            410 => self.hierarchical_identifier(&children[0], &children[1], &children[2]),
            411 => self.hierarchical_identifier_list0_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
            ),
            412 => self.hierarchical_identifier_list0_list_0(&children[0], &children[1]),
            413 => self.hierarchical_identifier_list0_list_1(),
            414 => self.hierarchical_identifier_list0_1(),
            415 => self.hierarchical_identifier_list_0(&children[0], &children[1]),
            416 => self.hierarchical_identifier_list_1(),
            417 => self.scoped_identifier(&children[0], &children[1]),
            418 => self.scoped_identifier_group_0(&children[0]),
            419 => self.scoped_identifier_group_1(&children[0], &children[1]),
            420 => self.scoped_identifier_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
            ),
            421 => self.scoped_identifier_list_1(),
            422 => self.scoped_identifier_opt0_0(&children[0]),
            423 => self.scoped_identifier_opt0_1(),
            424 => self.scoped_identifier_opt_0(&children[0]),
            425 => self.scoped_identifier_opt_1(),
            426 => {
                self.expression_identifier(&children[0], &children[1], &children[2], &children[3])
            }
            427 => self.expression_identifier_list0_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
            ),
            428 => self.expression_identifier_list0_list_0(&children[0], &children[1]),
            429 => self.expression_identifier_list0_list_1(),
            430 => self.expression_identifier_list0_1(),
            431 => self.expression_identifier_list_0(&children[0], &children[1]),
            432 => self.expression_identifier_list_1(),
            433 => self.expression_identifier_opt_0(&children[0]),
            434 => self.expression_identifier_opt_1(),
            435 => self.generic_arg_identifier(&children[0], &children[1]),
            436 => self.generic_arg_identifier_list_0(&children[0], &children[1], &children[2]),
            437 => self.generic_arg_identifier_list_1(),
            438 => self.expression(&children[0]),
            439 => self.if_expression(&children[0], &children[1]),
            440 => self.if_expression_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            441 => self.if_expression_list_1(),
            442 => self.expression01(&children[0], &children[1]),
            443 => self.expression01_list_0(&children[0], &children[1], &children[2]),
            444 => self.expression01_list_1(),
            445 => self.expression02(&children[0], &children[1]),
            446 => self.expression02_list_0(&children[0], &children[1], &children[2]),
            447 => self.expression02_list_1(),
            448 => self.expression03(&children[0], &children[1]),
            449 => self.expression03_list_0(&children[0], &children[1], &children[2]),
            450 => self.expression03_list_1(),
            451 => self.expression04(&children[0], &children[1]),
            452 => self.expression04_list_0(&children[0], &children[1], &children[2]),
            453 => self.expression04_list_1(),
            454 => self.expression05(&children[0], &children[1]),
            455 => self.expression05_list_0(&children[0], &children[1], &children[2]),
            456 => self.expression05_list_1(),
            457 => self.expression06(&children[0], &children[1]),
            458 => self.expression06_list_0(&children[0], &children[1], &children[2]),
            459 => self.expression06_list_1(),
            460 => self.expression07(&children[0], &children[1]),
            461 => self.expression07_list_0(&children[0], &children[1], &children[2]),
            462 => self.expression07_list_1(),
            463 => self.expression08(&children[0], &children[1]),
            464 => self.expression08_list_0(&children[0], &children[1], &children[2]),
            465 => self.expression08_list_1(),
            466 => self.expression09(&children[0], &children[1]),
            467 => self.expression09_list_0(&children[0], &children[1], &children[2]),
            468 => self.expression09_list_1(),
            469 => self.expression10(&children[0], &children[1]),
            470 => self.expression10_list_0(&children[0], &children[1], &children[2]),
            471 => self.expression10_list_group_0(&children[0]),
            472 => self.expression10_list_group_1(&children[0]),
            473 => self.expression10_list_1(),
            474 => self.expression11(&children[0], &children[1]),
            475 => self.expression11_list_0(&children[0], &children[1], &children[2]),
            476 => self.expression11_list_1(),
            477 => self.expression12(&children[0], &children[1]),
            478 => self.expression12_opt_0(&children[0], &children[1]),
            479 => self.expression12_opt_1(),
            480 => self.expression13(&children[0], &children[1]),
            481 => self.expression13_list_0(&children[0], &children[1]),
            482 => self.expression13_list_group_0(&children[0]),
            483 => self.expression13_list_group_1(&children[0]),
            484 => self.expression13_list_group_2(&children[0]),
            485 => self.expression13_list_group_3(&children[0]),
            486 => self.expression13_list_group_4(&children[0]),
            487 => self.expression13_list_1(),
            488 => self.factor_0(&children[0]),
            489 => self.factor_1(&children[0]),
            490 => self.factor_2(&children[0]),
            491 => self.factor_3(&children[0], &children[1], &children[2]),
            492 => self.factor_4(&children[0], &children[1], &children[2]),
            493 => self.factor_5(&children[0], &children[1], &children[2]),
            494 => self.factor_6(&children[0]),
            495 => self.factor_7(&children[0]),
            496 => self.factor_8(&children[0]),
            497 => self.factor_9(&children[0]),
            498 => self.factor_group_0(&children[0]),
            499 => self.factor_group_1(&children[0]),
            500 => self.factor_10(&children[0]),
            501 => self.factor_11(&children[0]),
            502 => self.factor_12(&children[0]),
            503 => self.factor_13(&children[0]),
            504 => self.boolean_literal_0(&children[0]),
            505 => self.boolean_literal_1(&children[0]),
            506 => self.identifier_factor(&children[0], &children[1]),
            507 => self.identifier_factor_opt_0(&children[0]),
            508 => self.identifier_factor_opt_group_0(&children[0]),
            509 => self.identifier_factor_opt_group_1(&children[0]),
            510 => self.identifier_factor_opt_1(),
            511 => self.factor_type_factor(&children[0], &children[1]),
            512 => self.factor_type_factor_list_0(&children[0], &children[1]),
            513 => self.factor_type_factor_list_1(),
            514 => self.function_call(&children[0], &children[1], &children[2]),
            515 => self.function_call_opt_0(&children[0]),
            516 => self.function_call_opt_1(),
            517 => self.argument_list(&children[0], &children[1], &children[2]),
            518 => self.argument_list_list_0(&children[0], &children[1], &children[2]),
            519 => self.argument_list_list_1(),
            520 => self.argument_list_opt_0(&children[0]),
            521 => self.argument_list_opt_1(),
            522 => self.argument_item(&children[0], &children[1]),
            523 => self.argument_item_opt_0(&children[0], &children[1]),
            524 => self.argument_item_opt_1(),
            525 => self.argument_expression(&children[0]),
            526 => self.struct_constructor(&children[0], &children[1], &children[2], &children[3]),
            527 => self.struct_constructor_opt_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            528 => self.struct_constructor_opt_1(),
            529 => self.struct_constructor_list(&children[0], &children[1], &children[2]),
            530 => self.struct_constructor_list_list_0(&children[0], &children[1], &children[2]),
            531 => self.struct_constructor_list_list_1(),
            532 => self.struct_constructor_list_opt_0(&children[0]),
            533 => self.struct_constructor_list_opt_1(),
            534 => self.struct_constructor_item(&children[0], &children[1], &children[2]),
            535 => self.concatenation_list(&children[0], &children[1], &children[2]),
            536 => self.concatenation_list_list_0(&children[0], &children[1], &children[2]),
            537 => self.concatenation_list_list_1(),
            538 => self.concatenation_list_opt_0(&children[0]),
            539 => self.concatenation_list_opt_1(),
            540 => self.concatenation_item(&children[0], &children[1]),
            541 => self.concatenation_item_opt_0(&children[0], &children[1]),
            542 => self.concatenation_item_opt_1(),
            543 => self.array_literal_list(&children[0], &children[1], &children[2]),
            544 => self.array_literal_list_list_0(&children[0], &children[1], &children[2]),
            545 => self.array_literal_list_list_1(),
            546 => self.array_literal_list_opt_0(&children[0]),
            547 => self.array_literal_list_opt_1(),
            548 => self.array_literal_item(&children[0]),
            549 => self.array_literal_item_group_0(&children[0], &children[1]),
            550 => self.array_literal_item_group_1(&children[0], &children[1], &children[2]),
            551 => self.array_literal_item_opt_0(&children[0], &children[1]),
            552 => self.array_literal_item_opt_1(),
            553 => self.case_expression(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
                &children[8],
                &children[9],
                &children[10],
                &children[11],
                &children[12],
            ),
            554 => self.case_expression_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            555 => self.case_expression_list_1(),
            556 => self.case_expression_opt_0(&children[0]),
            557 => self.case_expression_opt_1(),
            558 => self.switch_expression(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
                &children[8],
                &children[9],
                &children[10],
                &children[11],
            ),
            559 => self.switch_expression_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            560 => self.switch_expression_list_1(),
            561 => self.switch_expression_opt_0(&children[0]),
            562 => self.switch_expression_opt_1(),
            563 => self.type_expression(&children[0], &children[1], &children[2], &children[3]),
            564 => self.inside_expression(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            565 => self.outside_expression(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            566 => self.range_list(&children[0], &children[1], &children[2]),
            567 => self.range_list_list_0(&children[0], &children[1], &children[2]),
            568 => self.range_list_list_1(),
            569 => self.range_list_opt_0(&children[0]),
            570 => self.range_list_opt_1(),
            571 => self.range_item(&children[0]),
            572 => self.select(&children[0], &children[1], &children[2], &children[3]),
            573 => self.select_opt_0(&children[0], &children[1]),
            574 => self.select_opt_1(),
            575 => self.select_operator_0(&children[0]),
            576 => self.select_operator_1(&children[0]),
            577 => self.select_operator_2(&children[0]),
            578 => self.select_operator_3(&children[0]),
            579 => self.width(&children[0], &children[1], &children[2], &children[3]),
            580 => self.width_list_0(&children[0], &children[1], &children[2]),
            581 => self.width_list_1(),
            582 => self.array(&children[0], &children[1], &children[2], &children[3]),
            583 => self.array_list_0(&children[0], &children[1], &children[2]),
            584 => self.array_list_1(),
            585 => self.range(&children[0], &children[1]),
            586 => self.range_opt_0(&children[0], &children[1]),
            587 => self.range_opt_1(),
            588 => self.range_operator_0(&children[0]),
            589 => self.range_operator_1(&children[0]),
            590 => self.fixed_type_0(&children[0]),
            591 => self.fixed_type_1(&children[0]),
            592 => self.fixed_type_2(&children[0]),
            593 => self.fixed_type_3(&children[0]),
            594 => self.fixed_type_4(&children[0]),
            595 => self.fixed_type_5(&children[0]),
            596 => self.fixed_type_6(&children[0]),
            597 => self.fixed_type_7(&children[0]),
            598 => self.fixed_type_8(&children[0]),
            599 => self.fixed_type_9(&children[0]),
            600 => self.fixed_type_10(&children[0]),
            601 => self.fixed_type_11(&children[0]),
            602 => self.variable_type_0(&children[0]),
            603 => self.variable_type_1(&children[0]),
            604 => self.variable_type_2(&children[0]),
            605 => self.variable_type_3(&children[0]),
            606 => self.variable_type_4(&children[0]),
            607 => self.variable_type_5(&children[0]),
            608 => self.variable_type_6(&children[0]),
            609 => self.variable_type_7(&children[0]),
            610 => self.variable_type_8(&children[0]),
            611 => self.variable_type_9(&children[0]),
            612 => self.user_defined_type(&children[0]),
            613 => self.type_modifier_0(&children[0]),
            614 => self.type_modifier_1(&children[0]),
            615 => self.type_modifier_2(&children[0]),
            616 => self.factor_type(&children[0]),
            617 => self.factor_type_group_0(&children[0], &children[1]),
            618 => self.factor_type_group_1(&children[0]),
            619 => self.factor_type_opt_0(&children[0]),
            620 => self.factor_type_opt_1(),
            621 => self.scalar_type(&children[0], &children[1]),
            622 => self.scalar_type_group_0(&children[0], &children[1]),
            623 => self.scalar_type_group_1(&children[0]),
            624 => self.scalar_type_list_0(&children[0], &children[1]),
            625 => self.scalar_type_list_1(),
            626 => self.scalar_type_opt_0(&children[0]),
            627 => self.scalar_type_opt_1(),
            628 => self.array_type(&children[0], &children[1]),
            629 => self.array_type_opt_0(&children[0]),
            630 => self.array_type_opt_1(),
            631 => self.casting_type_0(&children[0]),
            632 => self.casting_type_1(&children[0]),
            633 => self.casting_type_2(&children[0]),
            634 => self.casting_type_3(&children[0]),
            635 => self.casting_type_4(&children[0]),
            636 => self.casting_type_5(&children[0]),
            637 => self.casting_type_6(&children[0]),
            638 => self.casting_type_7(&children[0]),
            639 => self.casting_type_8(&children[0]),
            640 => self.casting_type_9(&children[0]),
            641 => self.casting_type_10(&children[0]),
            642 => self.casting_type_11(&children[0]),
            643 => self.casting_type_12(&children[0]),
            644 => self.casting_type_13(&children[0]),
            645 => self.casting_type_14(&children[0]),
            646 => self.casting_type_15(&children[0]),
            647 => self.casting_type_16(&children[0]),
            648 => self.casting_type_17(&children[0]),
            649 => self.casting_type_18(&children[0]),
            650 => self.casting_type_19(&children[0]),
            651 => self.casting_type_20(&children[0]),
            652 => self.casting_type_21(&children[0]),
            653 => self.clock_domain(&children[0], &children[1]),
            654 => self.statement_block(&children[0], &children[1], &children[2]),
            655 => self.statement_block_list_0(&children[0], &children[1]),
            656 => self.statement_block_list_1(),
            657 => self.statement_block_group(&children[0], &children[1]),
            658 => self.statement_block_group_group_0(&children[0], &children[1], &children[2]),
            659 => self.statement_block_group_group_list_0(&children[0], &children[1]),
            660 => self.statement_block_group_group_list_1(),
            661 => self.statement_block_group_group_1(&children[0]),
            662 => self.statement_block_group_list_0(&children[0], &children[1]),
            663 => self.statement_block_group_list_1(),
            664 => self.statement_block_item_0(&children[0]),
            665 => self.statement_block_item_1(&children[0]),
            666 => self.statement_block_item_2(&children[0]),
            667 => self.statement_block_item_3(&children[0]),
            668 => self.statement_0(&children[0]),
            669 => self.statement_1(&children[0]),
            670 => self.statement_2(&children[0]),
            671 => self.statement_3(&children[0]),
            672 => self.statement_4(&children[0]),
            673 => self.statement_5(&children[0]),
            674 => self.statement_6(&children[0]),
            675 => self.statement_7(&children[0]),
            676 => self.let_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
            ),
            677 => self.let_statement_opt_0(&children[0]),
            678 => self.let_statement_opt_1(),
            679 => self.identifier_statement(&children[0], &children[1], &children[2]),
            680 => self.identifier_statement_group_0(&children[0]),
            681 => self.identifier_statement_group_1(&children[0]),
            682 => self.assignment(&children[0], &children[1]),
            683 => self.assignment_group_0(&children[0]),
            684 => self.assignment_group_1(&children[0]),
            685 => self.assignment_group_2(&children[0]),
            686 => self.if_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            687 => self.if_statement_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            688 => self.if_statement_list_1(),
            689 => self.if_statement_opt_0(&children[0], &children[1]),
            690 => self.if_statement_opt_1(),
            691 => self.if_reset_statement(&children[0], &children[1], &children[2], &children[3]),
            692 => self.if_reset_statement_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            693 => self.if_reset_statement_list_1(),
            694 => self.if_reset_statement_opt_0(&children[0], &children[1]),
            695 => self.if_reset_statement_opt_1(),
            696 => self.return_statement(&children[0], &children[1], &children[2]),
            697 => self.break_statement(&children[0], &children[1]),
            698 => self.for_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
                &children[8],
            ),
            699 => self.for_statement_opt0_0(&children[0], &children[1], &children[2]),
            700 => self.for_statement_opt0_1(),
            701 => self.for_statement_opt_0(&children[0]),
            702 => self.for_statement_opt_1(),
            703 => self.case_statement(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            704 => self.case_statement_list_0(&children[0], &children[1]),
            705 => self.case_statement_list_1(),
            706 => self.case_item(&children[0], &children[1], &children[2]),
            707 => self.case_item_group0_0(&children[0]),
            708 => self.case_item_group0_1(&children[0]),
            709 => self.case_item_group_0(&children[0]),
            710 => self.case_item_group_1(&children[0]),
            711 => self.case_condition(&children[0], &children[1]),
            712 => self.case_condition_list_0(&children[0], &children[1], &children[2]),
            713 => self.case_condition_list_1(),
            714 => self.switch_statement(&children[0], &children[1], &children[2], &children[3]),
            715 => self.switch_statement_list_0(&children[0], &children[1]),
            716 => self.switch_statement_list_1(),
            717 => self.switch_item(&children[0], &children[1], &children[2]),
            718 => self.switch_item_group0_0(&children[0]),
            719 => self.switch_item_group0_1(&children[0]),
            720 => self.switch_item_group_0(&children[0]),
            721 => self.switch_item_group_1(&children[0]),
            722 => self.switch_condition(&children[0], &children[1]),
            723 => self.switch_condition_list_0(&children[0], &children[1], &children[2]),
            724 => self.switch_condition_list_1(),
            725 => self.attribute(&children[0], &children[1], &children[2], &children[3]),
            726 => self.attribute_opt_0(&children[0], &children[1], &children[2]),
            727 => self.attribute_opt_1(),
            728 => self.attribute_list(&children[0], &children[1], &children[2]),
            729 => self.attribute_list_list_0(&children[0], &children[1], &children[2]),
            730 => self.attribute_list_list_1(),
            731 => self.attribute_list_opt_0(&children[0]),
            732 => self.attribute_list_opt_1(),
            733 => self.attribute_item_0(&children[0]),
            734 => self.attribute_item_1(&children[0]),
            735 => self.let_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
            ),
            736 => self.let_declaration_opt_0(&children[0]),
            737 => self.let_declaration_opt_1(),
            738 => self.var_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            739 => self.var_declaration_opt_0(&children[0]),
            740 => self.var_declaration_opt_1(),
            741 => self.const_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
            ),
            742 => self.const_declaration_group_0(&children[0]),
            743 => self.const_declaration_group_1(&children[0]),
            744 => self.type_def_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            745 => self.always_ff_declaration(&children[0], &children[1], &children[2]),
            746 => self.always_ff_declaration_opt_0(&children[0]),
            747 => self.always_ff_declaration_opt_1(),
            748 => {
                self.always_ff_event_list(&children[0], &children[1], &children[2], &children[3])
            }
            749 => self.always_ff_event_list_opt_0(&children[0], &children[1]),
            750 => self.always_ff_event_list_opt_1(),
            751 => self.always_ff_clock(&children[0]),
            752 => self.always_ff_reset(&children[0]),
            753 => self.always_comb_declaration(&children[0], &children[1]),
            754 => self.assign_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            755 => self.assign_destination_0(&children[0]),
            756 => self.assign_destination_1(&children[0], &children[1], &children[2]),
            757 => self.assign_concatenation_list(&children[0], &children[1], &children[2]),
            758 => self.assign_concatenation_list_list_0(&children[0], &children[1], &children[2]),
            759 => self.assign_concatenation_list_list_1(),
            760 => self.assign_concatenation_list_opt_0(&children[0]),
            761 => self.assign_concatenation_list_opt_1(),
            762 => self.assign_concatenation_item(&children[0]),
            763 => self.connect_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            764 => self.modport_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            765 => self.modport_declaration_opt0_0(&children[0], &children[1]),
            766 => self.modport_declaration_opt0_1(),
            767 => self.modport_declaration_opt_0(&children[0]),
            768 => self.modport_declaration_opt_1(),
            769 => self.modport_list(&children[0], &children[1], &children[2]),
            770 => self.modport_list_list_0(&children[0], &children[1], &children[2]),
            771 => self.modport_list_list_1(),
            772 => self.modport_list_opt_0(&children[0]),
            773 => self.modport_list_opt_1(),
            774 => self.modport_group(&children[0], &children[1]),
            775 => self.modport_group_group_0(&children[0], &children[1], &children[2]),
            776 => self.modport_group_group_1(&children[0]),
            777 => self.modport_group_list_0(&children[0], &children[1]),
            778 => self.modport_group_list_1(),
            779 => self.modport_item(&children[0], &children[1], &children[2]),
            780 => self.modport_default_0(&children[0]),
            781 => self.modport_default_1(&children[0]),
            782 => self.modport_default_2(&children[0], &children[1], &children[2], &children[3]),
            783 => self.modport_default_3(&children[0], &children[1], &children[2], &children[3]),
            784 => self.enum_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            785 => self.enum_declaration_opt_0(&children[0], &children[1]),
            786 => self.enum_declaration_opt_1(),
            787 => self.enum_list(&children[0], &children[1], &children[2]),
            788 => self.enum_list_list_0(&children[0], &children[1], &children[2]),
            789 => self.enum_list_list_1(),
            790 => self.enum_list_opt_0(&children[0]),
            791 => self.enum_list_opt_1(),
            792 => self.enum_group(&children[0], &children[1]),
            793 => self.enum_group_group_0(&children[0], &children[1], &children[2]),
            794 => self.enum_group_group_1(&children[0]),
            795 => self.enum_group_list_0(&children[0], &children[1]),
            796 => self.enum_group_list_1(),
            797 => self.enum_item(&children[0], &children[1]),
            798 => self.enum_item_opt_0(&children[0], &children[1]),
            799 => self.enum_item_opt_1(),
            800 => self.struct_union_0(&children[0]),
            801 => self.struct_union_1(&children[0]),
            802 => self.struct_union_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            803 => self.struct_union_declaration_opt_0(&children[0]),
            804 => self.struct_union_declaration_opt_1(),
            805 => self.struct_union_list(&children[0], &children[1], &children[2]),
            806 => self.struct_union_list_list_0(&children[0], &children[1], &children[2]),
            807 => self.struct_union_list_list_1(),
            808 => self.struct_union_list_opt_0(&children[0]),
            809 => self.struct_union_list_opt_1(),
            810 => self.struct_union_group(&children[0], &children[1]),
            811 => self.struct_union_group_group_0(&children[0], &children[1], &children[2]),
            812 => self.struct_union_group_group_1(&children[0]),
            813 => self.struct_union_group_list_0(&children[0], &children[1]),
            814 => self.struct_union_group_list_1(),
            815 => self.struct_union_item(&children[0], &children[1], &children[2]),
            816 => self.initial_declaration(&children[0], &children[1]),
            817 => self.final_declaration(&children[0], &children[1]),
            818 => self.inst_declaration(&children[0], &children[1], &children[2]),
            819 => self.bind_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            820 => self.component_instantiation(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
            ),
            821 => self.component_instantiation_opt2_0(&children[0]),
            822 => self.component_instantiation_opt2_1(),
            823 => self.component_instantiation_opt1_0(&children[0]),
            824 => self.component_instantiation_opt1_1(),
            825 => self.component_instantiation_opt0_0(&children[0]),
            826 => self.component_instantiation_opt0_1(),
            827 => self.component_instantiation_opt_0(&children[0]),
            828 => self.component_instantiation_opt_1(),
            829 => self.inst_parameter(&children[0], &children[1], &children[2], &children[3]),
            830 => self.inst_parameter_opt_0(&children[0]),
            831 => self.inst_parameter_opt_1(),
            832 => self.inst_parameter_list(&children[0], &children[1], &children[2]),
            833 => self.inst_parameter_list_list_0(&children[0], &children[1], &children[2]),
            834 => self.inst_parameter_list_list_1(),
            835 => self.inst_parameter_list_opt_0(&children[0]),
            836 => self.inst_parameter_list_opt_1(),
            837 => self.inst_parameter_group(&children[0], &children[1]),
            838 => self.inst_parameter_group_group_0(&children[0], &children[1], &children[2]),
            839 => self.inst_parameter_group_group_1(&children[0]),
            840 => self.inst_parameter_group_list_0(&children[0], &children[1]),
            841 => self.inst_parameter_group_list_1(),
            842 => self.inst_parameter_item(&children[0], &children[1]),
            843 => self.inst_parameter_item_opt_0(&children[0], &children[1]),
            844 => self.inst_parameter_item_opt_1(),
            845 => self.inst_port(&children[0], &children[1], &children[2]),
            846 => self.inst_port_opt_0(&children[0]),
            847 => self.inst_port_opt_1(),
            848 => self.inst_port_list(&children[0], &children[1], &children[2]),
            849 => self.inst_port_list_list_0(&children[0], &children[1], &children[2]),
            850 => self.inst_port_list_list_1(),
            851 => self.inst_port_list_opt_0(&children[0]),
            852 => self.inst_port_list_opt_1(),
            853 => self.inst_port_group(&children[0], &children[1]),
            854 => self.inst_port_group_group_0(&children[0], &children[1], &children[2]),
            855 => self.inst_port_group_group_1(&children[0]),
            856 => self.inst_port_group_list_0(&children[0], &children[1]),
            857 => self.inst_port_group_list_1(),
            858 => self.inst_port_item(&children[0], &children[1]),
            859 => self.inst_port_item_opt_0(&children[0], &children[1]),
            860 => self.inst_port_item_opt_1(),
            861 => self.with_parameter(&children[0], &children[1], &children[2], &children[3]),
            862 => self.with_parameter_opt_0(&children[0]),
            863 => self.with_parameter_opt_1(),
            864 => self.with_parameter_list(&children[0], &children[1], &children[2]),
            865 => self.with_parameter_list_list_0(&children[0], &children[1], &children[2]),
            866 => self.with_parameter_list_list_1(),
            867 => self.with_parameter_list_opt_0(&children[0]),
            868 => self.with_parameter_list_opt_1(),
            869 => self.with_parameter_group(&children[0], &children[1]),
            870 => self.with_parameter_group_group_0(&children[0], &children[1], &children[2]),
            871 => self.with_parameter_group_group_1(&children[0]),
            872 => self.with_parameter_group_list_0(&children[0], &children[1]),
            873 => self.with_parameter_group_list_1(),
            874 => self.with_parameter_item(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            875 => self.with_parameter_item_group0_0(&children[0]),
            876 => self.with_parameter_item_group0_1(&children[0]),
            877 => self.with_parameter_item_group_0(&children[0]),
            878 => self.with_parameter_item_group_1(&children[0]),
            879 => self.with_parameter_item_opt_0(&children[0], &children[1]),
            880 => self.with_parameter_item_opt_1(),
            881 => self.generic_bound_0(&children[0]),
            882 => self.generic_bound_1(&children[0], &children[1]),
            883 => self.generic_bound_2(&children[0]),
            884 => self.with_generic_parameter(&children[0], &children[1], &children[2]),
            885 => self.with_generic_parameter_list(&children[0], &children[1], &children[2]),
            886 => {
                self.with_generic_parameter_list_list_0(&children[0], &children[1], &children[2])
            }
            887 => self.with_generic_parameter_list_list_1(),
            888 => self.with_generic_parameter_list_opt_0(&children[0]),
            889 => self.with_generic_parameter_list_opt_1(),
            890 => self.with_generic_parameter_item(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
            ),
            891 => self.with_generic_parameter_item_opt_0(&children[0], &children[1]),
            892 => self.with_generic_parameter_item_opt_1(),
            893 => self.generic_proto_bound_0(&children[0]),
            894 => self.generic_proto_bound_1(&children[0]),
            895 => self.with_generic_argument(&children[0], &children[1], &children[2]),
            896 => self.with_generic_argument_opt_0(&children[0]),
            897 => self.with_generic_argument_opt_1(),
            898 => self.with_generic_argument_list(&children[0], &children[1], &children[2]),
            899 => self.with_generic_argument_list_list_0(&children[0], &children[1], &children[2]),
            900 => self.with_generic_argument_list_list_1(),
            901 => self.with_generic_argument_list_opt_0(&children[0]),
            902 => self.with_generic_argument_list_opt_1(),
            903 => self.with_generic_argument_item_0(&children[0]),
            904 => self.with_generic_argument_item_1(&children[0]),
            905 => self.with_generic_argument_item_2(&children[0]),
            906 => self.with_generic_argument_item_3(&children[0]),
            907 => self.port_declaration(&children[0], &children[1], &children[2]),
            908 => self.port_declaration_opt_0(&children[0]),
            909 => self.port_declaration_opt_1(),
            910 => self.port_declaration_list(&children[0], &children[1], &children[2]),
            911 => self.port_declaration_list_list_0(&children[0], &children[1], &children[2]),
            912 => self.port_declaration_list_list_1(),
            913 => self.port_declaration_list_opt_0(&children[0]),
            914 => self.port_declaration_list_opt_1(),
            915 => self.port_declaration_group(&children[0], &children[1]),
            916 => self.port_declaration_group_group_0(&children[0], &children[1], &children[2]),
            917 => self.port_declaration_group_group_1(&children[0]),
            918 => self.port_declaration_group_list_0(&children[0], &children[1]),
            919 => self.port_declaration_group_list_1(),
            920 => self.port_declaration_item(&children[0], &children[1], &children[2]),
            921 => self.port_declaration_item_group_0(&children[0]),
            922 => self.port_declaration_item_group_1(&children[0]),
            923 => self.port_type_concrete(&children[0], &children[1], &children[2], &children[3]),
            924 => self.port_type_concrete_opt0_0(&children[0], &children[1]),
            925 => self.port_type_concrete_opt0_1(),
            926 => self.port_type_concrete_opt_0(&children[0]),
            927 => self.port_type_concrete_opt_1(),
            928 => self.port_default_value(&children[0]),
            929 => self.port_type_abstract(&children[0], &children[1], &children[2], &children[3]),
            930 => self.port_type_abstract_opt1_0(&children[0]),
            931 => self.port_type_abstract_opt1_1(),
            932 => self.port_type_abstract_opt0_0(&children[0], &children[1]),
            933 => self.port_type_abstract_opt0_1(),
            934 => self.port_type_abstract_opt_0(&children[0]),
            935 => self.port_type_abstract_opt_1(),
            936 => self.direction_0(&children[0]),
            937 => self.direction_1(&children[0]),
            938 => self.direction_2(&children[0]),
            939 => self.direction_3(&children[0]),
            940 => self.direction_4(&children[0]),
            941 => self.function_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            942 => self.function_declaration_opt1_0(&children[0], &children[1]),
            943 => self.function_declaration_opt1_1(),
            944 => self.function_declaration_opt0_0(&children[0]),
            945 => self.function_declaration_opt0_1(),
            946 => self.function_declaration_opt_0(&children[0]),
            947 => self.function_declaration_opt_1(),
            948 => self.import_declaration(&children[0], &children[1], &children[2], &children[3]),
            949 => self.import_declaration_opt_0(&children[0], &children[1]),
            950 => self.import_declaration_opt_1(),
            951 => self.unsafe_block(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
            ),
            952 => self.unsafe_block_list_0(&children[0], &children[1]),
            953 => self.unsafe_block_list_1(),
            954 => self.module_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
                &children[8],
            ),
            955 => self.module_declaration_list_0(&children[0], &children[1]),
            956 => self.module_declaration_list_1(),
            957 => self.module_declaration_opt2_0(&children[0]),
            958 => self.module_declaration_opt2_1(),
            959 => self.module_declaration_opt1_0(&children[0]),
            960 => self.module_declaration_opt1_1(),
            961 => self.module_declaration_opt0_0(&children[0], &children[1]),
            962 => self.module_declaration_opt0_1(),
            963 => self.module_declaration_opt_0(&children[0]),
            964 => self.module_declaration_opt_1(),
            965 => self.module_group(&children[0], &children[1]),
            966 => self.module_group_group_0(&children[0], &children[1], &children[2]),
            967 => self.module_group_group_list_0(&children[0], &children[1]),
            968 => self.module_group_group_list_1(),
            969 => self.module_group_group_1(&children[0]),
            970 => self.module_group_list_0(&children[0], &children[1]),
            971 => self.module_group_list_1(),
            972 => self.module_item(&children[0]),
            973 => self.interface_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
                &children[7],
            ),
            974 => self.interface_declaration_list_0(&children[0], &children[1]),
            975 => self.interface_declaration_list_1(),
            976 => self.interface_declaration_opt1_0(&children[0]),
            977 => self.interface_declaration_opt1_1(),
            978 => self.interface_declaration_opt0_0(&children[0], &children[1]),
            979 => self.interface_declaration_opt0_1(),
            980 => self.interface_declaration_opt_0(&children[0]),
            981 => self.interface_declaration_opt_1(),
            982 => self.interface_group(&children[0], &children[1]),
            983 => self.interface_group_group_0(&children[0], &children[1], &children[2]),
            984 => self.interface_group_group_list_0(&children[0], &children[1]),
            985 => self.interface_group_group_list_1(),
            986 => self.interface_group_group_1(&children[0]),
            987 => self.interface_group_list_0(&children[0], &children[1]),
            988 => self.interface_group_list_1(),
            989 => self.interface_item_0(&children[0]),
            990 => self.interface_item_1(&children[0]),
            991 => self.generate_if_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            992 => self.generate_if_declaration_list_0(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            993 => self.generate_if_declaration_list_1(),
            994 => self.generate_if_declaration_opt_0(&children[0], &children[1]),
            995 => self.generate_if_declaration_opt_1(),
            996 => self.generate_for_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
            ),
            997 => self.generate_for_declaration_opt0_0(&children[0], &children[1], &children[2]),
            998 => self.generate_for_declaration_opt0_1(),
            999 => self.generate_for_declaration_opt_0(&children[0]),
            1000 => self.generate_for_declaration_opt_1(),
            1001 => self.generate_block_declaration(&children[0]),
            1002 => self.generate_named_block(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            1003 => self.generate_named_block_list_0(&children[0], &children[1]),
            1004 => self.generate_named_block_list_1(),
            1005 => self.generate_optional_named_block(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
            ),
            1006 => self.generate_optional_named_block_list_0(&children[0], &children[1]),
            1007 => self.generate_optional_named_block_list_1(),
            1008 => self.generate_optional_named_block_opt_0(&children[0], &children[1]),
            1009 => self.generate_optional_named_block_opt_1(),
            1010 => self.generate_group(&children[0], &children[1]),
            1011 => self.generate_group_group_0(&children[0], &children[1], &children[2]),
            1012 => self.generate_group_group_list_0(&children[0], &children[1]),
            1013 => self.generate_group_group_list_1(),
            1014 => self.generate_group_group_1(&children[0]),
            1015 => self.generate_group_list_0(&children[0], &children[1]),
            1016 => self.generate_group_list_1(),
            1017 => self.generate_item_0(&children[0]),
            1018 => self.generate_item_1(&children[0]),
            1019 => self.generate_item_2(&children[0]),
            1020 => self.generate_item_3(&children[0]),
            1021 => self.generate_item_4(&children[0]),
            1022 => self.generate_item_5(&children[0]),
            1023 => self.generate_item_6(&children[0]),
            1024 => self.generate_item_7(&children[0]),
            1025 => self.generate_item_8(&children[0]),
            1026 => self.generate_item_9(&children[0]),
            1027 => self.generate_item_10(&children[0]),
            1028 => self.generate_item_11(&children[0]),
            1029 => self.generate_item_12(&children[0]),
            1030 => self.generate_item_13(&children[0]),
            1031 => self.generate_item_14(&children[0]),
            1032 => self.generate_item_15(&children[0]),
            1033 => self.generate_item_16(&children[0]),
            1034 => self.generate_item_17(&children[0]),
            1035 => self.generate_item_18(&children[0]),
            1036 => self.generate_item_19(&children[0]),
            1037 => self.generate_item_20(&children[0]),
            1038 => self.generate_item_21(&children[0]),
            1039 => self.package_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
            ),
            1040 => self.package_declaration_list_0(&children[0], &children[1]),
            1041 => self.package_declaration_list_1(),
            1042 => self.package_declaration_opt0_0(&children[0], &children[1]),
            1043 => self.package_declaration_opt0_1(),
            1044 => self.package_declaration_opt_0(&children[0]),
            1045 => self.package_declaration_opt_1(),
            1046 => self.package_group(&children[0], &children[1]),
            1047 => self.package_group_group_0(&children[0], &children[1], &children[2]),
            1048 => self.package_group_group_list_0(&children[0], &children[1]),
            1049 => self.package_group_group_list_1(),
            1050 => self.package_group_group_1(&children[0]),
            1051 => self.package_group_list_0(&children[0], &children[1]),
            1052 => self.package_group_list_1(),
            1053 => self.package_item_0(&children[0]),
            1054 => self.package_item_1(&children[0]),
            1055 => self.package_item_2(&children[0]),
            1056 => self.package_item_3(&children[0]),
            1057 => self.package_item_4(&children[0]),
            1058 => self.package_item_5(&children[0]),
            1059 => self.package_item_6(&children[0]),
            1060 => self.package_item_7(&children[0]),
            1061 => self.alias_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            1062 => self.alias_declaration_group_0(&children[0]),
            1063 => self.alias_declaration_group_1(&children[0]),
            1064 => self.alias_declaration_group_2(&children[0]),
            1065 => self.proto_declaration(&children[0], &children[1]),
            1066 => self.proto_declaration_group_0(&children[0]),
            1067 => self.proto_declaration_group_1(&children[0]),
            1068 => self.proto_declaration_group_2(&children[0]),
            1069 => self.proto_module_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            1070 => self.proto_module_declaration_opt0_0(&children[0]),
            1071 => self.proto_module_declaration_opt0_1(),
            1072 => self.proto_module_declaration_opt_0(&children[0]),
            1073 => self.proto_module_declaration_opt_1(),
            1074 => self.proto_interface_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            1075 => self.proto_interface_declaration_list_0(&children[0], &children[1]),
            1076 => self.proto_interface_declaration_list_1(),
            1077 => self.proto_interface_declaration_opt_0(&children[0]),
            1078 => self.proto_interface_declaration_opt_1(),
            1079 => self.proto_interface_item_0(&children[0]),
            1080 => self.proto_interface_item_1(&children[0]),
            1081 => self.proto_interface_item_2(&children[0]),
            1082 => self.proto_interface_item_3(&children[0]),
            1083 => self.proto_interface_item_4(&children[0]),
            1084 => self.proto_interface_item_5(&children[0]),
            1085 => self.proto_interface_item_6(&children[0]),
            1086 => self.proto_package_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            1087 => self.proto_package_declaration_list_0(&children[0], &children[1]),
            1088 => self.proto_package_declaration_list_1(),
            1089 => self.proto_pacakge_item_0(&children[0]),
            1090 => self.proto_pacakge_item_1(&children[0]),
            1091 => self.proto_pacakge_item_2(&children[0]),
            1092 => self.proto_pacakge_item_3(&children[0]),
            1093 => self.proto_pacakge_item_4(&children[0]),
            1094 => self.proto_pacakge_item_5(&children[0]),
            1095 => self.proto_pacakge_item_6(&children[0]),
            1096 => self.proto_const_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
            ),
            1097 => self.proto_const_declaration_group_0(&children[0]),
            1098 => self.proto_const_declaration_group_1(&children[0]),
            1099 => self.proto_type_def_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
            ),
            1100 => self.proto_type_def_declaration_opt_0(&children[0], &children[1]),
            1101 => self.proto_type_def_declaration_opt_1(),
            1102 => self.proto_function_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            1103 => self.proto_function_declaration_opt1_0(&children[0], &children[1]),
            1104 => self.proto_function_declaration_opt1_1(),
            1105 => self.proto_function_declaration_opt0_0(&children[0]),
            1106 => self.proto_function_declaration_opt0_1(),
            1107 => self.proto_function_declaration_opt_0(&children[0]),
            1108 => self.proto_function_declaration_opt_1(),
            1109 => self.proto_alias_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            1110 => self.proto_alias_declaration_group_0(&children[0]),
            1111 => self.proto_alias_declaration_group_1(&children[0]),
            1112 => self.proto_alias_declaration_group_2(&children[0]),
            1113 => self.embed_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
            ),
            1114 => self.embed_content(&children[0], &children[1], &children[2]),
            1115 => self.embed_content_list_0(&children[0], &children[1]),
            1116 => self.embed_content_list_1(),
            1117 => self.embed_scoped_identifier(&children[0], &children[1], &children[2]),
            1118 => self.embed_item_0(&children[0], &children[1], &children[2]),
            1119 => self.embed_item_list_0(&children[0], &children[1]),
            1120 => self.embed_item_list_1(),
            1121 => self.embed_item_1(&children[0]),
            1122 => self.embed_item_2(&children[0]),
            1123 => self.include_declaration(
                &children[0],
                &children[1],
                &children[2],
                &children[3],
                &children[4],
                &children[5],
                &children[6],
            ),
            1124 => self.description_group(&children[0], &children[1]),
            1125 => self.description_group_group_0(&children[0], &children[1], &children[2]),
            1126 => self.description_group_group_list_0(&children[0], &children[1]),
            1127 => self.description_group_group_list_1(),
            1128 => self.description_group_group_1(&children[0]),
            1129 => self.description_group_list_0(&children[0], &children[1]),
            1130 => self.description_group_list_1(),
            1131 => self.description_item_0(&children[0], &children[1]),
            1132 => self.description_item_1(&children[0]),
            1133 => self.description_item_2(&children[0]),
            1134 => self.description_item_3(&children[0]),
            1135 => self.description_item_4(&children[0]),
            1136 => self.description_item_opt_0(&children[0]),
            1137 => self.description_item_opt_1(),
            1138 => self.public_description_item_0(&children[0]),
            1139 => self.public_description_item_1(&children[0]),
            1140 => self.public_description_item_2(&children[0]),
            1141 => self.public_description_item_3(&children[0]),
            1142 => self.public_description_item_4(&children[0]),
            1143 => self.veryl(&children[0], &children[1]),
            1144 => self.veryl_list_0(&children[0], &children[1]),
            1145 => self.veryl_list_1(),
            _ => Err(ParserError::InternalError(format!(
                "Unhandled production number: {prod_num}"
            ))
            .into()),
        }
    }

    fn on_comment(&mut self, token: Token<'t>) {
        self.user_grammar.on_comment(token)
    }
}
